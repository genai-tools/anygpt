# Simplified Release PR Workflow
# Uses a label-based approach for better control

name: CI and Release

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:
    inputs:
      preid:
        description: 'Prerelease identifier (e.g., beta, rc, alpha)'
        required: false
        type: string

permissions:
  actions: read
  contents: write
  pull-requests: write
  id-token: write

jobs:
  # Step 1: Create Release PR immediately (CI will run on the PR)
  create-release-pr:
    if: |
      github.ref == 'refs/heads/main' && 
      github.event_name == 'push' &&
      !startsWith(github.event.head_commit.message, 'chore(release)')
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.check.outputs.has_changes }}
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v5
        with:
          node-version: '24'

      - run: node -v
      - run: npm install --no-package-lock
      - run: npm run build

      # Check for releasable changes
      - name: Check for releasable changes
        id: check
        run: npx check-releasable-changes

      # Create or update release branch
      - name: Create or update release branch
        if: steps.check.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch remote to check if branch exists
          git fetch origin release-next || true
          
          # Create or checkout release branch
          if git rev-parse --verify origin/release-next >/dev/null 2>&1; then
            echo "Branch exists, checking out..."
            git checkout -B release-next origin/release-next
          else
            echo "Creating new branch..."
            git checkout -b release-next
          fi
          
          # Reset to main to get latest changes
          git reset --hard origin/main
          
          # Run nx release version (generates versions)
          # Add --preid if provided via workflow_dispatch
          PREID_FLAG=""
          if [ -n "${{ inputs.preid }}" ]; then
            PREID_FLAG="--preid=${{ inputs.preid }}"
          fi
          npx nx release version --stage-changes --git-commit=false --git-tag=false $PREID_FLAG
          
          # Generate changelogs for each changed package
          for file in packages/*/package.json packages/connectors/*/package.json; do
            if git diff --cached --quiet "$file"; then
              continue  # Skip if no changes
            fi
            pkg_name=$(jq -r '.name' "$file" | sed 's/@anygpt\///')
            version=$(jq -r '.version' "$file")
            echo "Generating changelog for $pkg_name@$version"
            npx nx release changelog "$version" --projects="$pkg_name" --stage-changes --git-commit=false --git-tag=false || true
          done
          
          # Commit the changes (NO [skip ci] - we want CI to run!)
          git commit -m "chore(release): version bump and changelog"
          
          # Force push to update the branch
          git push origin release-next --force

      # Generate changelog summary for PR
      - name: Generate changelog summary
        if: steps.check.outputs.has_changes == 'true'
        id: changelog
        run: |
          # Get the changelog from the release-next branch
          git fetch origin release-next
          git checkout release-next
          
          # Extract changelogs from all packages
          CHANGELOG=""
          for file in packages/*/CHANGELOG.md packages/connectors/*/CHANGELOG.md; do
            if [ -f "$file" ]; then
              pkg_name=$(dirname "$file")
              echo "## Changes in $pkg_name" >> /tmp/changelog.md
              echo "" >> /tmp/changelog.md
              # Get the latest version section (first section after the header)
              awk '/^## /{if(++count==1)next; if(count==2)exit} count==1' "$file" >> /tmp/changelog.md
              echo "" >> /tmp/changelog.md
            fi
          done
          
          # Save for PR body
          cat /tmp/changelog.md
          echo "CHANGELOG_CONTENT<<EOF" >> $GITHUB_OUTPUT
          cat /tmp/changelog.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          git checkout main

      # Create or update PR
      - name: Create or update Release PR
        if: steps.check.outputs.has_changes == 'true'
        run: |
          # Check if PR already exists
          existing_pr=$(gh pr list --head release-next --base main --state open --json number --jq '.[0].number')
          
          if [ -z "$existing_pr" ]; then
            echo "Creating new Release PR..."
            gh pr create \
            --title "ðŸš€ Release: Next Version" \
            --body "$(cat <<'EOF'
          ## ðŸš€ Release PR
          
          This PR contains version bumps and changelog updates for the next release.
          
          ### ðŸ“‹ Changelog
          
          ${{ steps.changelog.outputs.CHANGELOG_CONTENT }}
          
          ### âœ… CI Status
          
          CI checks will run automatically. All checks must pass before merging.
          
          ### ðŸŽ¯ How to release
          
          1. **Review** the changelog above and changes in the "Files changed" tab
          2. **Wait** for CI checks to pass âœ…
          3. **Edit** CHANGELOGs if needed (commit directly to this branch)
          4. **Merge** this PR to publish to npm
          
          ### ðŸ“ What happens on merge?
          
          - Git tags will be created
          - Packages will be published to npm
          - `production` branch will be updated
          EOF
          )" \
              --head release-next \
              --base main
          else
            echo "Release PR #$existing_pr already exists, updating description..."
            gh pr edit $existing_pr --body "$(cat <<'EOF'
          ## ðŸš€ Release PR
          
          This PR contains version bumps and changelog updates for the next release.
          
          ### ðŸ“‹ Changelog
          
          ${{ steps.changelog.outputs.CHANGELOG_CONTENT }}
          
          ### âœ… CI Status
          
          CI checks will run automatically. All checks must pass before merging.
          
          ### ðŸŽ¯ How to release
          
          1. **Review** the changelog above and changes in the "Files changed" tab
          2. **Wait** for CI checks to pass âœ…
          3. **Edit** CHANGELOGs if needed (commit directly to this branch)
          4. **Merge** this PR to publish to npm
          
          ### ðŸ“ What happens on merge?
          
          - Git tags will be created
          - Packages will be published to npm
          - `production` branch will be updated
          EOF
          )"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Step 2: Run CI on PRs (including Release PR)
  ci:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          filter: tree:0
          fetch-depth: 0

      - uses: actions/setup-node@v5
        with:
          node-version: '24'

      - run: npm install --no-package-lock
      - run: npm run build

      - name: Set affected base
        run: |
          # Use production branch as base (represents last published state)
          # Falls back to HEAD~1 if production branch doesn't exist yet
          if git rev-parse --verify origin/production >/dev/null 2>&1; then
            echo "NX_BASE=origin/production" >> $GITHUB_ENV
            echo "Comparing to production branch (last published state)"
          else
            echo "NX_BASE=HEAD~1" >> $GITHUB_ENV
            echo "Production branch not found, using HEAD~1"
          fi

      - name: Run CI checks
        run: |
          npx nx format:check || true
          npx nx affected -t lint test build typecheck --base=$NX_BASE
          npx nx fix-ci || true

  # Step 3: Publish when Release PR is merged
  publish:
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      startsWith(github.event.head_commit.message, 'Merge pull request') &&
      contains(github.event.head_commit.message, 'Release')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: actions/setup-node@v5
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org'

      - run: npm install --no-package-lock
      - run: npm run build

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # Extract version info and create tags
      - name: Create git tags
        run: |
          # Find all package.json files that were changed
          git diff HEAD~1 HEAD --name-only | grep 'package.json' | while read file; do
            if [[ "$file" == packages/*/package.json ]]; then
              pkg_dir=$(dirname "$file")
              pkg_name=$(jq -r '.name' "$file" | sed 's/@anygpt\///')
              version=$(jq -r '.version' "$file")
              tag="${pkg_name}@${version}"
              
              echo "Creating tag: $tag"
              git tag -a "$tag" -m "Release $tag" || echo "Tag $tag already exists"
            fi
          done

      # Publish to npm
      - name: Publish to npm
        run: |
          # Use nx release publish from the tags
          npx nx release publish --yes
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_ACCESS_TOKEN }}
          NPM_CONFIG_PROVENANCE: true

      # Push tags to GitHub
      - name: Push tags
        run: |
          git push --tags
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Update production branch (source of truth for what's published)
      - name: Update production branch
        run: |
          # Update production branch to current main (what was just published)
          git push origin HEAD:refs/heads/production --force
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
