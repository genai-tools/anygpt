{"version":3,"file":"index.js","names":["errors: string[]","results: SearchResult[]","keysToDelete: string[]","tools: ToolMetadata[]","target: ToolRuleTarget","connection: MCPConnection","errorConnection: MCPConnection","servers: ServerMetadata[]"],"sources":["../src/configuration-loader.ts","../src/search-engine.ts","../../rules/dist/index.js","../src/tool-metadata-manager.ts","../src/caching-layer.ts","../src/tool-execution-proxy.ts","../src/mcp-client.ts","../src/discovery-engine.ts"],"sourcesContent":["import type { DiscoveryConfig } from './types.js';\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n  /** Whether configuration is valid */\n  valid: boolean;\n  /** Validation errors */\n  errors: string[];\n}\n\n/**\n * Configuration loader for discovery engine\n */\nexport class ConfigurationLoader {\n  /**\n   * Get default configuration\n   */\n  getDefaultConfig(): DiscoveryConfig {\n    return {\n      enabled: true,\n      cache: {\n        enabled: true,\n        ttl: 3600 // 1 hour\n      },\n      sources: [],\n      rules: []\n    };\n  }\n\n  /**\n   * Validate discovery configuration\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  validate(config: any): ValidationResult {\n    const errors: string[] = [];\n\n    // Validate enabled field\n    if (typeof config.enabled !== 'boolean') {\n      errors.push('enabled must be a boolean');\n    }\n\n    // Validate cache configuration\n    if (config.cache !== undefined) {\n      if (typeof config.cache !== 'object' || config.cache === null) {\n        errors.push('cache must be an object');\n      } else {\n        if (typeof config.cache.enabled !== 'boolean') {\n          errors.push('cache.enabled must be a boolean');\n        }\n        if (typeof config.cache.ttl !== 'number' || config.cache.ttl <= 0) {\n          errors.push('cache.ttl must be a positive number');\n        }\n      }\n    }\n\n    // Validate sources\n    if (config.sources !== undefined) {\n      if (!Array.isArray(config.sources)) {\n        errors.push('sources must be an array');\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        config.sources.forEach((source: any, index: number) => {\n          if (typeof source.type !== 'string') {\n            errors.push(`sources[${index}].type must be a string`);\n          }\n          if (typeof source.path !== 'string') {\n            errors.push(`sources[${index}].path must be a string`);\n          }\n        });\n      }\n    }\n\n    // Validate rules (basic check - detailed validation handled by RuleEngine)\n    if (config.rules !== undefined) {\n      if (!Array.isArray(config.rules)) {\n        errors.push('rules must be an array');\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Merge partial configuration with defaults\n   */\n  mergeWithDefaults(partial: Partial<DiscoveryConfig>): DiscoveryConfig {\n    const defaults = this.getDefaultConfig();\n\n    return {\n      enabled: partial.enabled ?? defaults.enabled,\n      cache: partial.cache ?? defaults.cache,\n      sources: partial.sources ?? defaults.sources,\n      rules: partial.rules ?? defaults.rules\n    };\n  }\n}\n","import type { ToolMetadata, SearchOptions, SearchResult } from './types.js';\n\n/**\n * Search engine for tool discovery with relevance scoring\n */\nexport class SearchEngine {\n  private tools: ToolMetadata[] = [];\n\n  /**\n   * Index tools for search\n   * \n   * @param tools - Array of tool metadata to index\n   */\n  index(tools: ToolMetadata[]): void {\n    this.tools = tools;\n  }\n\n  /**\n   * Search for tools with relevance scoring\n   * \n   * @param query - Search query\n   * @param options - Search options\n   * @returns Array of search results sorted by relevance\n   */\n  search(query: string, options?: SearchOptions): SearchResult[] {\n    const queryLower = query.toLowerCase();\n    const queryTokens = queryLower.split(/\\s+/).filter(t => t.length > 0);\n\n    // Filter tools\n    let filteredTools = this.tools;\n\n    // Filter by server if specified\n    if (options?.server) {\n      filteredTools = filteredTools.filter(t => t.server === options.server);\n    }\n\n    // Filter by enabled status (exclude disabled by default)\n    if (!options?.includeDisabled) {\n      filteredTools = filteredTools.filter(t => t.enabled);\n    }\n\n    // Calculate relevance scores\n    const results: SearchResult[] = [];\n\n    for (const tool of filteredTools) {\n      const relevance = this.calculateRelevance(tool, queryLower, queryTokens);\n      \n      if (relevance > 0) {\n        results.push({\n          server: tool.server,\n          tool: tool.name,\n          summary: tool.summary,\n          relevance,\n          tags: tool.tags\n        });\n      }\n    }\n\n    // Sort by relevance (descending)\n    results.sort((a, b) => b.relevance - a.relevance);\n\n    // Apply limit if specified\n    if (options?.limit && options.limit > 0) {\n      return results.slice(0, options.limit);\n    }\n\n    return results;\n  }\n\n  /**\n   * Calculate relevance score for a tool\n   * \n   * @param tool - Tool metadata\n   * @param query - Lowercase query string\n   * @param queryTokens - Query split into tokens\n   * @returns Relevance score (0-1)\n   */\n  private calculateRelevance(\n    tool: ToolMetadata,\n    query: string,\n    queryTokens: string[]\n  ): number {\n    const toolNameLower = tool.name.toLowerCase();\n    const summaryLower = tool.summary.toLowerCase();\n    const tagsLower = tool.tags.map(t => t.toLowerCase());\n\n    let score = 0;\n\n    // Exact match in tool name (highest weight)\n    if (toolNameLower === query) {\n      score += 1.0;\n    } else if (toolNameLower.includes(query)) {\n      score += 0.8;\n    }\n\n    // Exact match in summary\n    if (summaryLower.includes(query)) {\n      score += 0.6;\n    }\n\n    // Partial match (tokenized)\n    for (const token of queryTokens) {\n      if (toolNameLower.includes(token)) {\n        score += 0.4;\n      }\n      if (summaryLower.includes(token)) {\n        score += 0.2;\n      }\n    }\n\n    // Tag match\n    for (const tag of tagsLower) {\n      if (query.includes(tag) || tag.includes(query)) {\n        score += 0.3;\n      }\n      for (const token of queryTokens) {\n        if (tag.includes(token)) {\n          score += 0.15;\n        }\n      }\n    }\n\n    // Normalize score to [0, 1]\n    return Math.min(score, 1.0);\n  }\n}\n","//#region src/engine.ts\n/**\n* Rule Engine - applies rules to objects\n* \n* Note: T cannot have fields named 'and', 'or', or 'not' as they are reserved\n* for logical operators. T must only contain primitive values (string, number, boolean)\n* or arrays of primitives.\n*/\nvar RuleEngine = class {\n\tconstructor(rules, defaultRule) {\n\t\tthis.rules = rules;\n\t\tthis.defaultRule = defaultRule;\n\t}\n\t/**\n\t* Apply all matching rules to an object\n\t*/\n\tapply(item) {\n\t\tlet result = this.defaultRule ? {\n\t\t\t...item,\n\t\t\t...this.defaultRule\n\t\t} : { ...item };\n\t\tfor (const rule of this.rules) if (this.matches(item, rule.when)) {\n\t\t\tif (rule.set) result = {\n\t\t\t\t...result,\n\t\t\t\t...rule.set\n\t\t\t};\n\t\t\tif (rule.push) for (const key in rule.push) {\n\t\t\t\tconst pushValue = rule.push[key];\n\t\t\t\tconst currentValue = result[key];\n\t\t\t\tif (Array.isArray(currentValue) && Array.isArray(pushValue)) result = {\n\t\t\t\t\t...result,\n\t\t\t\t\t[key]: [...currentValue, ...pushValue]\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t* Apply rules to multiple objects\n\t*/\n\tapplyAll(items) {\n\t\treturn items.map((item) => this.apply(item));\n\t}\n\t/**\n\t* Check if an object matches a condition\n\t*/\n\tmatches(item, condition) {\n\t\tif (\"and\" in condition && Array.isArray(condition.and)) return condition.and.every((c) => this.matches(item, c));\n\t\tif (\"or\" in condition && Array.isArray(condition.or)) return condition.or.some((c) => this.matches(item, c));\n\t\tif (\"not\" in condition && condition.not) return !this.matches(item, condition.not);\n\t\tconst fieldCondition = condition;\n\t\tfor (const key in fieldCondition) {\n\t\t\tconst operator = fieldCondition[key];\n\t\t\tconst value = item[key];\n\t\t\tif (!this.matchesOperator(value, operator)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t* Check if a value matches a pattern (regex or exact match)\n\t*/\n\tmatchesPattern(value, pattern) {\n\t\tif (pattern instanceof RegExp) return pattern.test(String(value));\n\t\treturn value === pattern;\n\t}\n\t/**\n\t* Normalize shortcut syntax to full operator format\n\t*/\n\tnormalizeOperator(operator) {\n\t\tif (!operator) return null;\n\t\tif (typeof operator === \"object\" && !Array.isArray(operator) && !(operator instanceof RegExp)) return operator;\n\t\tif (operator instanceof RegExp) return { match: operator };\n\t\tif (Array.isArray(operator)) return { in: operator };\n\t\treturn { eq: operator };\n\t}\n\t/**\n\t* Check if a value matches an operator\n\t*/\n\tmatchesOperator(value, operator) {\n\t\tconst normalized = this.normalizeOperator(operator);\n\t\tif (!normalized) return true;\n\t\tconst op = normalized;\n\t\tif (\"eq\" in op) return value === op[\"eq\"];\n\t\tif (\"in\" in op && Array.isArray(op[\"in\"])) {\n\t\t\tconst inArray = op[\"in\"];\n\t\t\tif (Array.isArray(value)) return value.some((v) => inArray.some((pattern) => this.matchesPattern(v, pattern)));\n\t\t\treturn inArray.some((pattern) => this.matchesPattern(value, pattern));\n\t\t}\n\t\tif (\"match\" in op) {\n\t\t\tconst matchValue = op[\"match\"];\n\t\t\treturn (Array.isArray(matchValue) ? matchValue : [matchValue]).some((pattern) => {\n\t\t\t\tif (pattern instanceof RegExp) return pattern.test(String(value));\n\t\t\t\tconst regexPattern = String(pattern).replace(/\\*/g, \"___GLOB_STAR___\").replace(/\\?/g, \"___GLOB_QUESTION___\").replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/___GLOB_STAR___/g, \".*\").replace(/___GLOB_QUESTION___/g, \".\");\n\t\t\t\treturn (/* @__PURE__ */ new RegExp(`^${regexPattern}$`)).test(String(value));\n\t\t\t});\n\t\t}\n\t\treturn true;\n\t}\n};\n\n//#endregion\nexport { RuleEngine };\n//# sourceMappingURL=index.js.map","import type { ToolMetadata } from './types.js';\nimport type { Rule } from '@anygpt/rules';\nimport type { ToolRuleTarget } from '@anygpt/types';\nimport { RuleEngine } from '@anygpt/rules';\n\n/**\n * Tool metadata manager for storing and filtering tools\n */\nexport class ToolMetadataManager {\n  private tools: Map<string, ToolMetadata> = new Map();\n\n  /**\n   * Add or update a tool\n   * \n   * @param tool - Tool metadata to add\n   */\n  addTool(tool: ToolMetadata): void {\n    const key = this.getToolKey(tool.server, tool.name);\n    this.tools.set(key, tool);\n  }\n\n  /**\n   * Add multiple tools at once\n   * \n   * @param tools - Array of tool metadata to add\n   */\n  addTools(tools: ToolMetadata[]): void {\n    for (const tool of tools) {\n      this.addTool(tool);\n    }\n  }\n\n  /**\n   * Clear all tools for a specific server\n   * \n   * @param server - Server name\n   */\n  clearServerTools(server: string): void {\n    const keysToDelete: string[] = [];\n    for (const [key, tool] of this.tools.entries()) {\n      if (tool.server === server) {\n        keysToDelete.push(key);\n      }\n    }\n    for (const key of keysToDelete) {\n      this.tools.delete(key);\n    }\n  }\n\n  /**\n   * Clear all tools\n   */\n  clearAll(): void {\n    this.tools.clear();\n  }\n\n  /**\n   * Get a specific tool\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Tool metadata or null if not found\n   */\n  getTool(server: string, tool: string): ToolMetadata | null {\n    const key = this.getToolKey(server, tool);\n    return this.tools.get(key) || null;\n  }\n\n  /**\n   * Get all tools from a specific server\n   * \n   * @param server - Server name\n   * @param includeDisabled - Include disabled tools\n   * @returns Array of tool metadata\n   */\n  getToolsByServer(server: string, includeDisabled = false): ToolMetadata[] {\n    const tools: ToolMetadata[] = [];\n    \n    for (const tool of this.tools.values()) {\n      if (tool.server === server) {\n        if (includeDisabled || tool.enabled) {\n          tools.push(tool);\n        }\n      }\n    }\n    \n    return tools;\n  }\n\n  /**\n   * Get all tools from all servers\n   * \n   * @param includeDisabled - Include disabled tools\n   * @returns Array of tool metadata\n   */\n  getAllTools(includeDisabled = false): ToolMetadata[] {\n    const tools: ToolMetadata[] = [];\n    \n    for (const tool of this.tools.values()) {\n      if (includeDisabled || tool.enabled) {\n        tools.push(tool);\n      }\n    }\n    \n    return tools;\n  }\n\n  /**\n   * Apply filtering rules to all tools using rule engine\n   * \n   * @param rules - Array of rules from @anygpt/rules\n   */\n  applyRules(rules: Rule<ToolRuleTarget>[]): void {\n    if (!rules || rules.length === 0) {\n      return;\n    }\n\n    const engine = new RuleEngine(rules);\n\n    // Apply rules to each tool\n    for (const tool of this.tools.values()) {\n      // Convert ToolMetadata to ToolRuleTarget\n      const target: ToolRuleTarget = {\n        server: tool.server,\n        name: tool.name,\n        enabled: tool.enabled,\n        tags: [...tool.tags]\n      };\n\n      // Apply rules\n      const result = engine.apply(target);\n\n      // Update tool with results\n      tool.enabled = result.enabled;\n      tool.tags = [...new Set(result.tags)]; // Deduplicate tags\n    }\n  }\n\n  /**\n   * Get total tool count for a server\n   * \n   * @param server - Server name\n   * @returns Total tool count\n   */\n  getToolCount(server: string): number {\n    let count = 0;\n    for (const tool of this.tools.values()) {\n      if (tool.server === server) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get enabled tool count for a server\n   * \n   * @param server - Server name\n   * @returns Enabled tool count\n   */\n  getEnabledCount(server: string): number {\n    let count = 0;\n    for (const tool of this.tools.values()) {\n      if (tool.server === server && tool.enabled) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Generate a unique key for a tool\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Unique key\n   */\n  private getToolKey(server: string, tool: string): string {\n    return `${server}:${tool}`;\n  }\n}\n","import type { ServerMetadata, ToolMetadata } from './types.js';\n\n/**\n * Cache entry with TTL\n */\ninterface CacheEntry<T> {\n  data: T;\n  expiresAt: number | null; // null = never expires\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Caching layer for discovery engine\n * Supports TTL-based caching for servers and tool summaries\n * Indefinite caching for tool details\n */\nexport class CachingLayer {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private cache: Map<string, CacheEntry<any>> = new Map();\n\n  /**\n   * Cache server list with TTL\n   * \n   * @param servers - Array of server metadata\n   * @param ttl - Time-to-live in seconds\n   */\n  cacheServerList(servers: ServerMetadata[], ttl: number): void {\n    this.cache.set('servers', {\n      data: servers,\n      expiresAt: Date.now() + ttl * 1000\n    });\n  }\n\n  /**\n   * Get cached server list\n   * \n   * @returns Cached server list or null if not cached/expired\n   */\n  getServerList(): ServerMetadata[] | null {\n    return this.get<ServerMetadata[]>('servers');\n  }\n\n  /**\n   * Cache tool summaries for a specific server with TTL\n   * \n   * @param server - Server name\n   * @param tools - Array of tool metadata\n   * @param ttl - Time-to-live in seconds\n   */\n  cacheToolSummaries(server: string, tools: ToolMetadata[], ttl: number): void {\n    const key = `tools:${server}`;\n    this.cache.set(key, {\n      data: tools,\n      expiresAt: Date.now() + ttl * 1000\n    });\n  }\n\n  /**\n   * Get cached tool summaries for a specific server\n   * \n   * @param server - Server name\n   * @returns Cached tool summaries or null if not cached/expired\n   */\n  getToolSummaries(server: string): ToolMetadata[] | null {\n    const key = `tools:${server}`;\n    return this.get<ToolMetadata[]>(key);\n  }\n\n  /**\n   * Cache tool details indefinitely\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @param details - Tool metadata with full details\n   */\n  cacheToolDetails(server: string, tool: string, details: ToolMetadata): void {\n    const key = `tool:${server}:${tool}`;\n    this.cache.set(key, {\n      data: details,\n      expiresAt: null // Never expires\n    });\n  }\n\n  /**\n   * Get cached tool details\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Cached tool details or null if not cached\n   */\n  getToolDetails(server: string, tool: string): ToolMetadata | null {\n    const key = `tool:${server}:${tool}`;\n    return this.get<ToolMetadata>(key);\n  }\n\n  /**\n   * Invalidate a specific cache key\n   * \n   * @param key - Cache key to invalidate (e.g., 'servers', 'tools:github')\n   */\n  invalidate(key: string): void {\n    this.cache.delete(key);\n  }\n\n  /**\n   * Invalidate all caches\n   */\n  invalidateAll(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cached value if not expired\n   * \n   * @param key - Cache key\n   * @returns Cached value or null if not cached/expired\n   */\n  private get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired (null expiresAt means never expires)\n    if (entry.expiresAt !== null && Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data as T;\n  }\n}\n","import type { MCPServerConfig, ExecutionResult } from './types.js';\n\n/**\n * Tool execution proxy for connecting to MCP servers\n * \n * Note: This is the initial implementation that provides the interface.\n * Full MCP SDK integration will be added in the next iteration.\n */\nexport class ToolExecutionProxy {\n  private connections: Map<string, boolean> = new Map();\n\n  /**\n   * Execute a tool on a remote MCP server\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @param args - Tool arguments\n   * @returns Execution result\n   */\n  async execute(\n    server: string,\n    tool: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any\n  ): Promise<ExecutionResult> {\n    // Validate arguments\n    if (args === null || args === undefined) {\n      return {\n        success: false,\n        error: {\n          code: 'INVALID_ARGUMENTS',\n          message: 'Tool arguments cannot be null or undefined',\n          server,\n          tool\n        }\n      };\n    }\n\n    // Check if server is connected\n    if (!this.isConnected(server)) {\n      return {\n        success: false,\n        error: {\n          code: 'SERVER_NOT_CONNECTED',\n          message: `Server ${server} is not connected`,\n          server,\n          tool\n        }\n      };\n    }\n\n    // TODO: Implement actual MCP server connection and tool execution\n    // For now, return an error indicating this is not yet implemented\n    return {\n      success: false,\n      error: {\n        code: 'NOT_IMPLEMENTED',\n        message: 'Tool execution proxy is not yet fully implemented',\n        server,\n        tool\n      }\n    };\n  }\n\n  /**\n   * Connect to an MCP server\n   * \n   * @param server - Server name\n   * @param _config - Server configuration (unused in stub implementation)\n   */\n  async connect(server: string, _config: MCPServerConfig): Promise<void> {\n    // TODO: Implement actual MCP server connection using SDK\n    // For now, just mark as connected\n    this.connections.set(server, true);\n  }\n\n  /**\n   * Disconnect from an MCP server\n   * \n   * @param server - Server name\n   */\n  async disconnect(server: string): Promise<void> {\n    this.connections.delete(server);\n  }\n\n  /**\n   * Check if connected to a server\n   * \n   * @param server - Server name\n   * @returns true if connected\n   */\n  isConnected(server: string): boolean {\n    return this.connections.get(server) === true;\n  }\n}\n","/**\n * MCP Client wrapper for connecting to and managing MCP servers\n */\n\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport type { MCPServerConfig, ToolMetadata } from './types.js';\n\nexport interface MCPConnection {\n  client: Client;\n  transport: StdioClientTransport;\n  serverName: string;\n  status: 'connected' | 'disconnected' | 'error';\n  error?: string;\n}\n\n/**\n * MCP Client Manager - handles connections to MCP servers\n */\nexport class MCPClientManager {\n  private connections: Map<string, MCPConnection> = new Map();\n\n  /**\n   * Connect to an MCP server\n   */\n  async connect(serverName: string, config: MCPServerConfig): Promise<MCPConnection> {\n    let stderrOutput = '';\n\n    try {\n      // Create transport for stdio communication with stderr piped\n      const transport = new StdioClientTransport({\n        command: config.command,\n        args: config.args || [],\n        env: config.env ? { ...process.env, ...config.env } : process.env,\n        stderr: 'pipe', // Pipe stderr so we can capture it\n      });\n\n      // Capture stderr output\n      const stderrStream = transport.stderr;\n      if (stderrStream) {\n        stderrStream.on('data', (chunk: Buffer) => {\n          stderrOutput += chunk.toString();\n        });\n      }\n\n      // Create MCP client\n      const client = new Client(\n        {\n          name: 'anygpt-discovery',\n          version: '1.0.0',\n        },\n        {\n          capabilities: {},\n        }\n      );\n\n      // Connect client to transport\n      await client.connect(transport);\n\n      const connection: MCPConnection = {\n        client,\n        transport,\n        serverName,\n        status: 'connected',\n      };\n\n      this.connections.set(serverName, connection);\n      return connection;\n    } catch (error) {\n      // Use captured stderr if available, otherwise use error message\n      let errorMessage = stderrOutput.trim();\n      \n      if (!errorMessage && error instanceof Error) {\n        errorMessage = error.message;\n        \n        // Add helpful context based on error type\n        if (errorMessage.includes('ENOENT')) {\n          errorMessage = `Command not found: ${config.command}`;\n        } else if (errorMessage.includes('EACCES')) {\n          errorMessage = `Permission denied: ${config.command}`;\n        } else if (errorMessage.includes('spawn')) {\n          errorMessage = `Failed to spawn: ${config.command} ${config.args?.join(' ') || ''}`;\n        }\n      } else if (!errorMessage) {\n        errorMessage = String(error);\n      }\n      \n      const errorConnection: MCPConnection = {\n        client: null as any,\n        transport: null as any,\n        serverName,\n        status: 'error',\n        error: errorMessage || 'Unknown error',\n      };\n      this.connections.set(serverName, errorConnection);\n      return errorConnection;\n    }\n  }\n\n  /**\n   * Disconnect from an MCP server\n   */\n  async disconnect(serverName: string): Promise<void> {\n    const connection = this.connections.get(serverName);\n    if (connection) {\n      try {\n        // Close client first\n        if (connection.status === 'connected' && connection.client) {\n          await connection.client.close();\n        }\n        \n        // Then close transport to kill child process\n        if (connection.transport) {\n          await connection.transport.close();\n        }\n        \n        connection.status = 'disconnected';\n      } catch (error) {\n        // Ignore disconnect errors\n      }\n    }\n    this.connections.delete(serverName);\n  }\n\n  /**\n   * Disconnect from all servers\n   */\n  async disconnectAll(): Promise<void> {\n    const disconnectPromises = Array.from(this.connections.keys()).map((name) =>\n      this.disconnect(name)\n    );\n    await Promise.all(disconnectPromises);\n  }\n\n  /**\n   * Get connection for a server\n   */\n  getConnection(serverName: string): MCPConnection | undefined {\n    return this.connections.get(serverName);\n  }\n\n  /**\n   * List tools from a connected server\n   */\n  async listTools(serverName: string): Promise<ToolMetadata[]> {\n    const connection = this.connections.get(serverName);\n    if (!connection || connection.status !== 'connected') {\n      return [];\n    }\n\n    try {\n      const response = await connection.client.listTools();\n      \n      return response.tools.map((tool) => ({\n        name: tool.name,\n        summary: tool.description || '',\n        description: tool.description,\n        server: serverName,\n        enabled: true, // Default to enabled, will be filtered by rules\n        tags: [], // Initialize with empty tags array\n        inputSchema: tool.inputSchema,\n      }));\n    } catch (error) {\n      console.error(`Failed to list tools from ${serverName}:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Execute a tool on a connected server\n   */\n  async executeTool(\n    serverName: string,\n    toolName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any\n  ): Promise<any> {\n    const connection = this.connections.get(serverName);\n    if (!connection || connection.status !== 'connected') {\n      throw new Error(`Server ${serverName} is not connected`);\n    }\n\n    try {\n      const response = await connection.client.callTool({\n        name: toolName,\n        arguments: args,\n      });\n\n      return response;\n    } catch (error) {\n      throw new Error(\n        `Failed to execute tool ${toolName} on ${serverName}: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  /**\n   * Check if a server is connected\n   */\n  isConnected(serverName: string): boolean {\n    const connection = this.connections.get(serverName);\n    return connection?.status === 'connected';\n  }\n\n  /**\n   * Get all connection statuses\n   */\n  getConnectionStatuses(): Map<string, 'connected' | 'disconnected' | 'error'> {\n    const statuses = new Map<string, 'connected' | 'disconnected' | 'error'>();\n    for (const [name, conn] of this.connections.entries()) {\n      statuses.set(name, conn.status);\n    }\n    return statuses;\n  }\n}\n","import type {\n  DiscoveryConfig,\n  ServerMetadata,\n  SearchOptions,\n  SearchResult,\n  ToolMetadata,\n  ExecutionResult,\n  MCPServerConfig\n} from './types.js';\nimport { SearchEngine } from './search-engine.js';\nimport { ToolMetadataManager } from './tool-metadata-manager.js';\nimport { CachingLayer } from './caching-layer.js';\nimport { ToolExecutionProxy } from './tool-execution-proxy.js';\nimport { MCPClientManager } from './mcp-client.js';\n\n/**\n * Main discovery engine facade that coordinates all components\n */\nexport class DiscoveryEngine {\n  private config: DiscoveryConfig;\n  private mcpServers: Record<string, MCPServerConfig>;\n  private searchEngine: SearchEngine;\n  private metadataManager: ToolMetadataManager;\n  private cache: CachingLayer;\n  private executionProxy: ToolExecutionProxy;\n  private clientManager: MCPClientManager;\n  private initialized = false;\n\n  constructor(config: DiscoveryConfig, mcpServers?: Record<string, MCPServerConfig>) {\n    this.config = config;\n    this.mcpServers = mcpServers || {};\n    this.searchEngine = new SearchEngine();\n    this.metadataManager = new ToolMetadataManager();\n    this.cache = new CachingLayer();\n    this.executionProxy = new ToolExecutionProxy();\n    this.clientManager = new MCPClientManager();\n\n    // Apply initial configuration\n    this.applyConfiguration();\n  }\n\n  /**\n   * Initialize connections and discover tools from all servers\n   * \n   * @param onProgress - Optional callback for progress updates\n   */\n  async initialize(onProgress?: (progress: import('./types.js').ServerProgress) => void): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    const { Readable } = await import('node:stream');\n    \n    // Get all server entries\n    const serverEntries = Object.entries(this.mcpServers);\n    \n    // Process servers with concurrency control (max 5 at a time)\n    const MAX_CONCURRENT = 5;\n    \n    await Readable.from(serverEntries)\n      .map(async ([name, config]) => {\n        // Skip disabled servers\n        if (config.enabled === false) {\n          onProgress?.({ server: name, status: 'error', error: 'Server is disabled' });\n          return;\n        }\n        \n        try {\n          // Notify: connecting\n          onProgress?.({ server: name, status: 'connecting', message: 'Connecting to server...' });\n          \n          // Connect to server\n          const connection = await this.clientManager.connect(name, config);\n          \n          if (connection.status === 'connected') {\n            // Notify: discovering tools\n            onProgress?.({ server: name, status: 'discovering', message: 'Discovering tools...' });\n            \n            // Discover tools from this server\n            const tools = await this.clientManager.listTools(name);\n            \n            // Add tools to metadata manager\n            this.metadataManager.addTools(tools);\n            \n            // Notify: connected\n            onProgress?.({ server: name, status: 'connected', toolCount: tools.length });\n          } else {\n            // Notify: error\n            onProgress?.({ \n              server: name, \n              status: 'error', \n              error: connection.error || 'Failed to connect'\n            });\n          }\n        } catch (error) {\n          // Notify: error\n          onProgress?.({ \n            server: name, \n            status: 'error', \n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }, { concurrency: MAX_CONCURRENT })\n      .toArray(); // Consume the stream\n\n    // Apply filtering rules after all tools are discovered\n    if (this.config.rules && this.config.rules.length > 0) {\n      this.metadataManager.applyRules(this.config.rules);\n    }\n\n    this.initialized = true;\n  }\n\n  /**\n   * List all available MCP servers\n   * \n   * @returns Array of server metadata\n   */\n  async listServers(): Promise<ServerMetadata[]> {\n    // Ensure we're initialized\n    await this.initialize();\n\n    // Check cache first if enabled\n    if (this.config.cache?.enabled) {\n      const cached = this.cache.getServerList();\n      if (cached) {\n        return cached;\n      }\n    }\n\n    // Get connection statuses\n    const statuses = this.clientManager.getConnectionStatuses();\n\n    // Convert MCP server configs to ServerMetadata\n    const servers: ServerMetadata[] = Object.entries(this.mcpServers).map(([name, config]) => {\n      // Get tools for this server from metadata manager\n      const tools = this.metadataManager.getToolsByServer(name, true);\n      const enabledTools = tools.filter(t => t.enabled);\n\n      return {\n        name,\n        description: config.description || `MCP server: ${name}`,\n        toolCount: tools.length,\n        enabledCount: enabledTools.length,\n        status: statuses.get(name) || 'disconnected',\n        config: {\n          command: config.command,\n          args: config.args || [],\n          env: config.env\n        }\n      };\n    });\n\n    // Cache if enabled\n    if (this.config.cache?.enabled && this.config.cache.ttl) {\n      this.cache.cacheServerList(servers, this.config.cache.ttl);\n    }\n\n    return servers;\n  }\n\n  /**\n   * Search for tools across all servers\n   * \n   * @param query - Search query\n   * @param options - Search options\n   * @returns Array of search results\n   */\n  async searchTools(query: string, options?: SearchOptions): Promise<SearchResult[]> {\n    // Ensure we're initialized\n    await this.initialize();\n\n    // Get all tools from metadata manager\n    const tools = this.metadataManager.getAllTools(options?.includeDisabled);\n\n    // Index tools in search engine\n    this.searchEngine.index(tools);\n\n    // Perform search\n    return this.searchEngine.search(query, options);\n  }\n\n  /**\n   * List tools from a specific server\n   * \n   * @param server - Server name\n   * @param includeDisabled - Include disabled tools\n   * @returns Array of tool metadata\n   */\n  async listTools(server: string, includeDisabled = false): Promise<ToolMetadata[]> {\n    // Ensure we're initialized\n    await this.initialize();\n\n    // Check cache first if enabled\n    if (this.config.cache?.enabled && !includeDisabled) {\n      const cached = this.cache.getToolSummaries(server);\n      if (cached) {\n        return cached;\n      }\n    }\n\n    // Get tools from metadata manager\n    const tools = this.metadataManager.getToolsByServer(server, includeDisabled);\n\n    // Cache if enabled\n    if (this.config.cache?.enabled && this.config.cache.ttl && !includeDisabled) {\n      this.cache.cacheToolSummaries(server, tools, this.config.cache.ttl);\n    }\n\n    return tools;\n  }\n\n  /**\n   * Get detailed information about a specific tool\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Tool metadata or null if not found\n   */\n  async getToolDetails(server: string, tool: string): Promise<ToolMetadata | null> {\n    // Check cache first if enabled\n    if (this.config.cache?.enabled) {\n      const cached = this.cache.getToolDetails(server, tool);\n      if (cached) {\n        return cached;\n      }\n    }\n\n    // Get tool from metadata manager\n    const toolMetadata = this.metadataManager.getTool(server, tool);\n\n    // Cache if enabled and found\n    if (this.config.cache?.enabled && toolMetadata) {\n      this.cache.cacheToolDetails(server, tool, toolMetadata);\n    }\n\n    return toolMetadata;\n  }\n\n  /**\n   * Execute a tool from any discovered MCP server\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @param args - Tool arguments\n   * @returns Execution result\n   */\n  async executeTool(\n    server: string,\n    tool: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any\n  ): Promise<ExecutionResult> {\n    // Ensure we're initialized\n    await this.initialize();\n\n    // Check if tool is enabled\n    const toolMetadata = this.metadataManager.getTool(server, tool);\n    if (!toolMetadata) {\n      return {\n        success: false,\n        error: {\n          code: 'TOOL_NOT_FOUND',\n          message: `Tool ${tool} not found on server ${server}`,\n          server,\n          tool\n        }\n      };\n    }\n\n    if (!toolMetadata.enabled) {\n      return {\n        success: false,\n        error: {\n          code: 'TOOL_DISABLED',\n          message: `Tool ${tool} is disabled`,\n          server,\n          tool\n        }\n      };\n    }\n\n    // Execute tool via MCP client\n    try {\n      const result = await this.clientManager.executeTool(server, tool, args);\n      return {\n        success: true,\n        result\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          code: 'EXECUTION_ERROR',\n          message: error instanceof Error ? error.message : String(error),\n          server,\n          tool\n        }\n      };\n    }\n  }\n\n  /**\n   * Reload configuration\n   */\n  async reload(): Promise<void> {\n    // Disconnect from all servers\n    await this.clientManager.disconnectAll();\n\n    // Clear all cached data\n    this.cache.invalidateAll();\n    this.metadataManager.clearAll();\n\n    // Mark as uninitialized\n    this.initialized = false;\n\n    // Reinitialize\n    await this.initialize();\n  }\n\n  /**\n   * Cleanup and disconnect from all servers\n   */\n  async dispose(): Promise<void> {\n    await this.clientManager.disconnectAll();\n    this.initialized = false;\n  }\n\n  /**\n   * Get current configuration\n   * \n   * @returns Current discovery configuration\n   */\n  getConfig(): DiscoveryConfig {\n    return this.config;\n  }\n\n  /**\n   * Apply configuration to components\n   */\n  private applyConfiguration(): void {\n    // Apply rules to metadata manager\n    if (this.config.rules && this.config.rules.length > 0) {\n      this.metadataManager.applyRules(this.config.rules);\n    }\n  }\n}\n"],"mappings":"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"}