{"version":3,"file":"index.js","names":["errors: string[]","results: SearchResult[]","tools: ToolMetadata[]","tags: string[]","servers: ServerMetadata[]"],"sources":["../src/configuration-loader.ts","../../config/dist/index.js","../src/pattern-matcher.ts","../src/search-engine.ts","../src/tool-metadata-manager.ts","../src/caching-layer.ts","../src/tool-execution-proxy.ts","../src/discovery-engine.ts"],"sourcesContent":["import type { DiscoveryConfig } from './types.js';\n\n/**\n * Validation result\n */\nexport interface ValidationResult {\n  /** Whether configuration is valid */\n  valid: boolean;\n  /** Validation errors */\n  errors: string[];\n}\n\n/**\n * Configuration loader for discovery engine\n */\nexport class ConfigurationLoader {\n  /**\n   * Get default configuration\n   */\n  getDefaultConfig(): DiscoveryConfig {\n    return {\n      enabled: true,\n      cache: {\n        enabled: true,\n        ttl: 3600 // 1 hour\n      },\n      sources: [],\n      toolRules: []\n    };\n  }\n\n  /**\n   * Validate discovery configuration\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  validate(config: any): ValidationResult {\n    const errors: string[] = [];\n\n    // Validate enabled field\n    if (typeof config.enabled !== 'boolean') {\n      errors.push('enabled must be a boolean');\n    }\n\n    // Validate cache configuration\n    if (config.cache !== undefined) {\n      if (typeof config.cache !== 'object' || config.cache === null) {\n        errors.push('cache must be an object');\n      } else {\n        if (typeof config.cache.enabled !== 'boolean') {\n          errors.push('cache.enabled must be a boolean');\n        }\n        if (typeof config.cache.ttl !== 'number' || config.cache.ttl <= 0) {\n          errors.push('cache.ttl must be a positive number');\n        }\n      }\n    }\n\n    // Validate sources\n    if (config.sources !== undefined) {\n      if (!Array.isArray(config.sources)) {\n        errors.push('sources must be an array');\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        config.sources.forEach((source: any, index: number) => {\n          if (typeof source.type !== 'string') {\n            errors.push(`sources[${index}].type must be a string`);\n          }\n          if (typeof source.path !== 'string') {\n            errors.push(`sources[${index}].path must be a string`);\n          }\n        });\n      }\n    }\n\n    // Validate tool rules\n    if (config.toolRules !== undefined) {\n      if (!Array.isArray(config.toolRules)) {\n        errors.push('toolRules must be an array');\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        config.toolRules.forEach((rule: any, index: number) => {\n          if (!Array.isArray(rule.pattern)) {\n            errors.push(`toolRules[${index}].pattern must be an array`);\n          }\n          if (rule.server !== undefined && typeof rule.server !== 'string') {\n            errors.push(`toolRules[${index}].server must be a string`);\n          }\n          if (rule.enabled !== undefined && typeof rule.enabled !== 'boolean') {\n            errors.push(`toolRules[${index}].enabled must be a boolean`);\n          }\n          if (rule.tags !== undefined && !Array.isArray(rule.tags)) {\n            errors.push(`toolRules[${index}].tags must be an array`);\n          }\n        });\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  /**\n   * Merge partial configuration with defaults\n   */\n  mergeWithDefaults(partial: Partial<DiscoveryConfig>): DiscoveryConfig {\n    const defaults = this.getDefaultConfig();\n\n    return {\n      enabled: partial.enabled ?? defaults.enabled,\n      cache: partial.cache ?? defaults.cache,\n      sources: partial.sources ?? defaults.sources,\n      toolRules: partial.toolRules ?? defaults.toolRules\n    };\n  }\n}\n","import { access, readFile } from \"fs/promises\";\nimport { join, resolve } from \"path\";\nimport { homedir } from \"os\";\nimport { minimatch } from \"minimatch\";\n\n//#region src/errors.ts\n/**\n* Custom error types for configuration loading\n*/\n/**\n* Base class for all configuration errors\n*/\nvar ConfigError = class extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = this.constructor.name;\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n};\n/**\n* Thrown when no configuration file is found\n*/\nvar ConfigNotFoundError = class extends ConfigError {\n\tconstructor(searchPaths) {\n\t\tsuper(`No configuration file found. Searched:\\n${searchPaths.map((p) => `  - ${p}`).join(\"\\n\")}\\n\\nCreate a config file at ./.anygpt/anygpt.config.ts or use default config.`);\n\t\tthis.searchPaths = searchPaths;\n\t}\n};\n/**\n* Thrown when configuration file cannot be parsed\n*/\nvar ConfigParseError = class extends ConfigError {\n\tconstructor(filePath, originalError) {\n\t\tconst causeMessage = originalError instanceof Error ? originalError.message : String(originalError);\n\t\tsuper(`Failed to parse configuration file: ${filePath}\\n\\nError: ${causeMessage}\\n\\nCheck your configuration file syntax.`);\n\t\tthis.filePath = filePath;\n\t\tthis.originalError = originalError;\n\t}\n};\n/**\n* Thrown when configuration fails validation\n*/\nvar ConfigValidationError = class extends ConfigError {\n\tconstructor(errors) {\n\t\tsuper(`Configuration validation failed:\\n${errors.map((e) => `  - ${e}`).join(\"\\n\")}\\n\\nFix the errors above and try again.`);\n\t\tthis.errors = errors;\n\t}\n};\n/**\n* Thrown when a connector module cannot be loaded\n*/\nvar ConnectorLoadError = class extends ConfigError {\n\tconstructor(connectorPackage, providerId, originalError) {\n\t\tconst causeMessage = originalError instanceof Error ? originalError.message : String(originalError);\n\t\tsuper(`Failed to load connector '${connectorPackage}' for provider '${providerId}'\\n\\nError: ${causeMessage}\\n\\nMake sure the connector package is installed:\\n  npm install ${connectorPackage}`);\n\t\tthis.connectorPackage = connectorPackage;\n\t\tthis.providerId = providerId;\n\t\tthis.originalError = originalError;\n\t}\n};\n\n//#endregion\n//#region src/defaults.ts\n/**\n* Get default configuration with common providers\n*/\nfunction getDefaultConfig() {\n\treturn {\n\t\tversion: \"1.0\",\n\t\tproviders: {\n\t\t\topenai: {\n\t\t\t\tname: \"OpenAI\",\n\t\t\t\tconnector: {\n\t\t\t\t\tconnector: \"@anygpt/openai\",\n\t\t\t\t\tconfig: {\n\t\t\t\t\t\tapiKey: process.env[\"OPENAI_API_KEY\"],\n\t\t\t\t\t\tbaseURL: \"https://api.openai.com/v1\",\n\t\t\t\t\t\ttimeout: 3e4,\n\t\t\t\t\t\tmaxRetries: 3\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsettings: { defaultModel: \"gpt-4o-mini\" }\n\t\t\t},\n\t\t\tmock: {\n\t\t\t\tname: \"Mock Provider (Testing)\",\n\t\t\t\tconnector: {\n\t\t\t\t\tconnector: \"@anygpt/mock\",\n\t\t\t\t\tconfig: {\n\t\t\t\t\t\tdelay: 100,\n\t\t\t\t\t\tfailureRate: 0\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsettings: { defaultModel: \"mock-gpt-4\" }\n\t\t\t}\n\t\t},\n\t\tsettings: {\n\t\t\tdefaultProvider: process.env[\"OPENAI_API_KEY\"] ? \"openai\" : \"mock\",\n\t\t\ttimeout: 3e4,\n\t\t\tmaxRetries: 3,\n\t\t\tlogging: { level: \"info\" }\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/connector-loader.ts\n/**\n* Cache for loaded connector factories\n*/\nconst connectorCache = /* @__PURE__ */ new Map();\n/**\n* Dynamically import and create a connector factory\n*/\nasync function loadConnectorFactory(packageName) {\n\tconst cachedFactory = connectorCache.get(packageName);\n\tif (cachedFactory) return cachedFactory;\n\ttry {\n\t\tconst connectorModule = await import(packageName);\n\t\tlet factory;\n\t\tif (connectorModule.default && typeof connectorModule.default === \"function\") {\n\t\t\tconst FactoryCtor = connectorModule.default;\n\t\t\tfactory = new FactoryCtor();\n\t\t} else if (connectorModule.default) factory = connectorModule.default;\n\t\telse {\n\t\t\tconst factoryExports = Object.keys(connectorModule).filter((key) => key.endsWith(\"Factory\") && typeof connectorModule[key] === \"function\");\n\t\t\tif (factoryExports.length === 0) throw new Error(`No connector factory found in package '${packageName}'`);\n\t\t\tconst FactoryClass = connectorModule[factoryExports[0]];\n\t\t\tfactory = new FactoryClass();\n\t\t}\n\t\tif (!factory.getProviderId || !factory.create) throw new Error(`Invalid connector factory in package '${packageName}': missing getProviderId or create methods`);\n\t\tconnectorCache.set(packageName, factory);\n\t\treturn factory;\n\t} catch (error) {\n\t\tthrow new ConnectorLoadError(packageName, \"unknown\", error);\n\t}\n}\n/**\n* Load and register all connectors from configuration\n*/\nasync function loadConnectors(router, config$1, logger) {\n\tconst loadPromises = Object.entries(config$1.providers).map(([providerId, providerConfig]) => loadConnectorForProvider(router, providerId, providerConfig, logger));\n\tawait Promise.all(loadPromises);\n}\n/**\n* Load and register a single connector\n*/\nasync function loadConnectorForProvider(router, providerId, providerConfig, logger) {\n\ttry {\n\t\tconst connectorConfig = providerConfig.connector;\n\t\tconst connectorPackage = connectorConfig.type || connectorConfig.connector;\n\t\tconst factory = await loadConnectorFactory(connectorPackage);\n\t\trouter.registerConnector(factory);\n\t\tlogger?.info(`✓ Loaded connector '${connectorPackage}' for provider '${providerId}'`);\n\t} catch (error) {\n\t\tlogger?.error(`✗ Failed to load connector for provider '${providerId}':`, error);\n\t\tif (error instanceof ConnectorLoadError) throw error;\n\t\tconst connectorConfig = providerConfig.connector;\n\t\tconst connectorPackage = connectorConfig.type || connectorConfig.connector;\n\t\tthrow new ConnectorLoadError(connectorPackage, providerId, error);\n\t}\n}\n/**\n* Get connector configuration for a provider\n*/\nfunction getConnectorConfig(config$1, providerId) {\n\tconst provider = config$1.providers[providerId];\n\tif (!provider) throw new Error(`Provider '${providerId}' not found in configuration`);\n\tconst connectorConfig = provider.connector;\n\tconst mergedOptions = { ...connectorConfig.options || connectorConfig.config || {} };\n\tif (config$1.settings?.timeout !== void 0) mergedOptions[\"timeout\"] = config$1.settings.timeout;\n\tif (config$1.settings?.maxRetries !== void 0) mergedOptions[\"maxRetries\"] = config$1.settings.maxRetries;\n\treturn mergedOptions;\n}\n/**\n* Clear connector cache (useful for testing)\n*/\nfunction clearConnectorCache() {\n\tconnectorCache.clear();\n}\n\n//#endregion\n//#region ../router/dist/index.js\nvar ConnectorRegistry = class {\n\tfactories = /* @__PURE__ */ new Map();\n\tregisterConnector(factory) {\n\t\tconst connectorType = factory.getProviderId();\n\t\tif (!this.factories.has(connectorType)) this.factories.set(connectorType, factory);\n\t}\n\tcreateConnector(providerId, config$1 = {}) {\n\t\tconst factory = this.factories.get(providerId);\n\t\tif (!factory) throw new Error(`No connector registered for provider: ${providerId}`);\n\t\treturn factory.create(config$1);\n\t}\n\tgetConnector(providerId, config$1 = {}) {\n\t\treturn this.createConnector(providerId, config$1);\n\t}\n\thasConnector(providerId) {\n\t\treturn this.factories.has(providerId);\n\t}\n\tgetAvailableProviders() {\n\t\treturn Array.from(this.factories.keys());\n\t}\n\tunregisterConnector(providerId) {\n\t\treturn this.factories.delete(providerId);\n\t}\n\tclear() {\n\t\tthis.factories.clear();\n\t}\n\tasync getAllModels() {\n\t\tconst results = [];\n\t\tfor (const [providerId, factory] of this.factories) try {\n\t\t\tconst models = await factory.create({}).listModels();\n\t\t\tresults.push({\n\t\t\t\tprovider: providerId,\n\t\t\t\tmodels\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Failed to get models from ${providerId}:`, error);\n\t\t}\n\t\treturn results;\n\t}\n};\nnew ConnectorRegistry();\n/**\n* Custom error classes for the router package\n* Following TypeScript best practices for error handling\n*/\n/**\n* Base error class for all router-related errors\n*/\nvar RouterError = class extends Error {\n\tconstructor(message, code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.name = \"RouterError\";\n\t\tif (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);\n\t}\n};\n/**\n* Error thrown when max retries are exceeded\n*/\nvar MaxRetriesExceededError = class extends RouterError {\n\tconstructor(providerId, operation, maxRetries, originalError) {\n\t\tsuper(`Max retries (${maxRetries}) exceeded for ${operation} on provider ${providerId}: ${originalError.message}`, \"MAX_RETRIES_EXCEEDED\");\n\t\tthis.providerId = providerId;\n\t\tthis.operation = operation;\n\t\tthis.maxRetries = maxRetries;\n\t\tthis.originalError = originalError;\n\t\tthis.name = \"MaxRetriesExceededError\";\n\t\tif (originalError?.stack) this.stack = `${this.stack}\\nCaused by: ${originalError.stack}`;\n\t}\n};\n/**\n* ErrorHandler manages retry logic with exponential backoff\n*/\nvar ErrorHandler = class {\n\tconfig;\n\tconstructor(config$1) {\n\t\tthis.config = {\n\t\t\tmaxRetries: config$1.maxRetries,\n\t\t\tbackoffType: config$1.backoffType,\n\t\t\tbaseDelay: config$1.baseDelay,\n\t\t\tmaxDelay: config$1.maxDelay ?? 3e4,\n\t\t\tjitter: config$1.jitter ?? true\n\t\t};\n\t}\n\t/**\n\t* Check if an error is retryable\n\t*/\n\tisRetryable(error) {\n\t\tconst status = error.status || error.statusCode;\n\t\tif (status !== void 0) {\n\t\t\tif (status === 429 || status >= 500 && status < 600) return true;\n\t\t\tif (status >= 400 && status < 500) return false;\n\t\t}\n\t\tconst code = error.code;\n\t\tif (code) {\n\t\t\tif ([\n\t\t\t\t\"ECONNRESET\",\n\t\t\t\t\"ECONNREFUSED\",\n\t\t\t\t\"ETIMEDOUT\",\n\t\t\t\t\"ENOTFOUND\",\n\t\t\t\t\"ENETUNREACH\",\n\t\t\t\t\"EAI_AGAIN\"\n\t\t\t].includes(code)) return true;\n\t\t}\n\t\tif (error.name === \"TimeoutError\" || error.message.includes(\"timeout\")) return true;\n\t\treturn false;\n\t}\n\t/**\n\t* Calculate delay for retry attempt with backoff\n\t*/\n\tcalculateDelay(attempt) {\n\t\tlet delay;\n\t\tif (this.config.backoffType === \"exponential\") delay = this.config.baseDelay * Math.pow(2, attempt);\n\t\telse delay = this.config.baseDelay * (attempt + 1);\n\t\tdelay = Math.min(delay, this.config.maxDelay);\n\t\tif (this.config.jitter) delay += Math.random() * 500;\n\t\treturn Math.floor(delay);\n\t}\n\t/**\n\t* Decide whether to retry based on context\n\t*/\n\tshouldRetry(context) {\n\t\tif (context.attempt >= this.config.maxRetries) return {\n\t\t\tshouldRetry: false,\n\t\t\treason: `Max retries (${this.config.maxRetries}) exceeded`\n\t\t};\n\t\tif (!this.isRetryable(context.error)) return {\n\t\t\tshouldRetry: false,\n\t\t\treason: `Error is not retryable: ${context.error.message}`\n\t\t};\n\t\tconst delay = this.calculateDelay(context.attempt);\n\t\treturn {\n\t\t\tshouldRetry: true,\n\t\t\tdelay,\n\t\t\tnextAttempt: context.attempt + 1,\n\t\t\treason: `Error is retryable, will retry after ${delay}ms`\n\t\t};\n\t}\n\t/**\n\t* Execute an operation with automatic retry logic\n\t*/\n\tasync executeWithRetry(operation, context) {\n\t\tlet attempt = 0;\n\t\twhile (true) try {\n\t\t\treturn await operation();\n\t\t} catch (error) {\n\t\t\tconst errorContext = {\n\t\t\t\t...context,\n\t\t\t\terror,\n\t\t\t\tattempt\n\t\t\t};\n\t\t\tconst decision = this.shouldRetry(errorContext);\n\t\t\tif (!decision.shouldRetry) {\n\t\t\t\tif (errorContext.attempt >= this.config.maxRetries) throw new MaxRetriesExceededError(context.providerId, context.operation, this.config.maxRetries, error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tif (decision.delay) await this.sleep(decision.delay);\n\t\t\tattempt = decision.nextAttempt;\n\t\t}\n\t}\n\t/**\n\t* Get current retry configuration\n\t*/\n\tgetRetryConfig() {\n\t\treturn { ...this.config };\n\t}\n\t/**\n\t* Sleep for specified milliseconds\n\t*/\n\tsleep(ms) {\n\t\treturn new Promise((resolve$1) => setTimeout(resolve$1, ms));\n\t}\n};\n/**\n* Create a default ErrorHandler instance\n*/\nfunction createErrorHandler(config$1) {\n\treturn new ErrorHandler({\n\t\tmaxRetries: config$1?.maxRetries ?? 3,\n\t\tbackoffType: config$1?.backoffType ?? \"exponential\",\n\t\tbaseDelay: config$1?.baseDelay ?? 1e3,\n\t\tmaxDelay: config$1?.maxDelay,\n\t\tjitter: config$1?.jitter\n\t});\n}\nvar GenAIRouter = class {\n\tconfig;\n\tregistry;\n\terrorHandler;\n\tconstructor(config$1) {\n\t\tthis.config = config$1;\n\t\tthis.registry = new ConnectorRegistry();\n\t\tthis.errorHandler = createErrorHandler({\n\t\t\tmaxRetries: config$1.maxRetries ?? 3,\n\t\t\tbackoffType: \"exponential\",\n\t\t\tbaseDelay: 1e3,\n\t\t\tjitter: true\n\t\t});\n\t}\n\tasync chatCompletion(request) {\n\t\tconst { config: normalizedConfig, type } = this.normalizeProviderConfig(request.provider);\n\t\tconst connector = this.getConnector(type, normalizedConfig);\n\t\tconst baseRequest = {\n\t\t\tmessages: request.messages,\n\t\t\tmodel: request.model,\n\t\t\ttemperature: request.temperature,\n\t\t\tmax_tokens: request.max_tokens,\n\t\t\tuseLegacyCompletionAPI: request.useLegacyCompletionAPI,\n\t\t\tfallbackToChatCompletion: request.fallbackToChatCompletion,\n\t\t\tuseLegacyMaxTokens: request.useLegacyMaxTokens,\n\t\t\ttop_p: request.top_p,\n\t\t\tfrequency_penalty: request.frequency_penalty,\n\t\t\tpresence_penalty: request.presence_penalty,\n\t\t\treasoning: request.reasoning,\n\t\t\textra_body: request.extra_body\n\t\t};\n\t\tconst response = await this.errorHandler.executeWithRetry(() => connector.chatCompletion(baseRequest), {\n\t\t\tproviderId: request.provider,\n\t\t\toperation: \"chatCompletion\",\n\t\t\tmetadata: { model: request.model }\n\t\t});\n\t\treturn {\n\t\t\tid: response.id,\n\t\t\tobject: response.object,\n\t\t\tcreated: response.created,\n\t\t\tmodel: response.model,\n\t\t\tprovider: connector.getProviderId(),\n\t\t\tchoices: response.choices.map((choice) => ({\n\t\t\t\tindex: choice.index,\n\t\t\t\tmessage: {\n\t\t\t\t\trole: choice.message.role,\n\t\t\t\t\tcontent: choice.message.content\n\t\t\t\t},\n\t\t\t\tfinish_reason: choice.finish_reason\n\t\t\t})),\n\t\t\tusage: {\n\t\t\t\tprompt_tokens: response.usage.prompt_tokens,\n\t\t\t\tcompletion_tokens: response.usage.completion_tokens,\n\t\t\t\ttotal_tokens: response.usage.total_tokens\n\t\t\t}\n\t\t};\n\t}\n\tasync response(request) {\n\t\tconst { config: normalizedConfig, type } = this.normalizeProviderConfig(request.provider);\n\t\tconst connector = this.getConnector(type, normalizedConfig);\n\t\treturn {\n\t\t\t...await this.errorHandler.executeWithRetry(() => connector.response(request), {\n\t\t\t\tproviderId: request.provider,\n\t\t\t\toperation: \"response\",\n\t\t\t\tmetadata: { model: request.model }\n\t\t\t}),\n\t\t\tprovider: connector.getProviderId()\n\t\t};\n\t}\n\tasync listModels(provider) {\n\t\tconst { config: normalizedConfig, type } = this.normalizeProviderConfig(provider);\n\t\tconst connector = this.getConnector(type, normalizedConfig);\n\t\treturn await this.errorHandler.executeWithRetry(() => connector.listModels(), {\n\t\t\tproviderId: provider,\n\t\t\toperation: \"listModels\"\n\t\t});\n\t}\n\tnormalizeProviderConfig(provider) {\n\t\tif (!this.config.providers?.[provider]) throw new Error(`Provider '${provider}' not configured`);\n\t\tconst providerConfig = this.config.providers[provider];\n\t\treturn {\n\t\t\tconfig: {\n\t\t\t\tbaseURL: providerConfig.api.url,\n\t\t\t\tapiKey: providerConfig.api.token,\n\t\t\t\theaders: providerConfig.api.headers,\n\t\t\t\ttimeout: providerConfig.timeout || this.config.timeout,\n\t\t\t\tmaxRetries: providerConfig.maxRetries || this.config.maxRetries\n\t\t\t},\n\t\t\ttype: providerConfig.type\n\t\t};\n\t}\n\tgetConnector(providerId, config$1) {\n\t\tif (!this.registry.hasConnector(providerId)) throw new Error(`No connector registered for provider: ${providerId}`);\n\t\treturn this.registry.getConnector(providerId, config$1);\n\t}\n\tregisterConnector(factory) {\n\t\tthis.registry.registerConnector(factory);\n\t}\n\tgetAvailableProviders() {\n\t\treturn this.registry.getAvailableProviders();\n\t}\n\thasProvider(providerId) {\n\t\treturn this.registry.hasConnector(providerId);\n\t}\n};\nvar router_default = GenAIRouter;\n\n//#endregion\n//#region src/loader.ts\n/**\n* Default configuration paths to search\n*/\nconst DEFAULT_CONFIG_PATHS = [\n\t\"./.anygpt/anygpt.config.ts\",\n\t\"./.anygpt/anygpt.config.js\",\n\t\"./.anygpt/anygpt.config.json\",\n\t\"./anygpt.config.ts\",\n\t\"./anygpt.config.js\",\n\t\"./anygpt.config.json\",\n\t\"~/.anygpt/anygpt.config.ts\",\n\t\"~/.anygpt/anygpt.config.js\",\n\t\"~/.anygpt/anygpt.config.json\",\n\t\"/etc/anygpt/anygpt.config.ts\",\n\t\"/etc/anygpt/anygpt.config.js\",\n\t\"/etc/anygpt/anygpt.config.json\"\n];\n/**\n* Resolve path with tilde expansion\n*/\nfunction resolvePath(path) {\n\tif (path.startsWith(\"~/\")) return join(homedir(), path.slice(2));\n\treturn resolve(path);\n}\n/**\n* Check if file exists\n*/\nasync function fileExists(path) {\n\ttry {\n\t\tawait access(path);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n/**\n* Load TypeScript/JavaScript config file\n*\n* Strategy: Uses jiti with tryNative option for smart TypeScript loading\n*\n* How it works:\n* 1. Node.js 22.18+ and 24+: Native TS support enabled by default (zero overhead!)\n* 2. Node.js 22.6-22.17: Requires --experimental-strip-types flag\n* 3. Node.js <22.6: Falls back to jiti's Babel transformation\n*\n* The tryNative option makes jiti:\n* - Try native import first (fast path for modern Node.js)\n* - Fall back to transformation only if native fails\n* - Cache transformed files for performance\n*\n* This gives us the best of both worlds:\n* - Zero overhead on Node 22.18+/24+ (native TS)\n* - Automatic fallback for older versions (jiti transformation)\n* - No breaking changes for users on any Node version\n*/\nasync function loadTSConfig(path) {\n\ttry {\n\t\tconst { createJiti } = await import(\"jiti\");\n\t\treturn await createJiti(import.meta.url, {\n\t\t\ttryNative: true,\n\t\t\tfsCache: true,\n\t\t\tinteropDefault: true,\n\t\t\tmoduleCache: true\n\t\t}).import(path, { default: true });\n\t} catch (error) {\n\t\tthrow new ConfigParseError(path, error);\n\t}\n}\n/**\n* Load JSON config file\n*/\nasync function loadJSONConfig(path) {\n\ttry {\n\t\tconst content = await readFile(path, \"utf-8\");\n\t\treturn JSON.parse(content);\n\t} catch (error) {\n\t\tthrow new ConfigParseError(path, error);\n\t}\n}\n/**\n* Load configuration file\n*/\nasync function loadConfigFile(path) {\n\tconst resolvedPath = resolvePath(path);\n\tif (!await fileExists(resolvedPath)) throw new ConfigParseError(resolvedPath, /* @__PURE__ */ new Error(\"File not found\"));\n\tif (path.endsWith(\".json\")) return loadJSONConfig(resolvedPath);\n\telse return loadTSConfig(resolvedPath);\n}\n/**\n* Find first existing config file from default paths\n*/\nasync function findConfigFile() {\n\tfor (const path of DEFAULT_CONFIG_PATHS) {\n\t\tconst resolvedPath = resolvePath(path);\n\t\tif (await fileExists(resolvedPath)) return resolvedPath;\n\t}\n\treturn null;\n}\n/**\n* Merge configurations with deep merge\n*/\nfunction mergeConfigs(base, override) {\n\tconst result = {\n\t\t...base,\n\t\t...override,\n\t\tproviders: {\n\t\t\t...base.providers,\n\t\t\t...override.providers\n\t\t},\n\t\tsettings: {\n\t\t\t...base.settings,\n\t\t\t...override.settings,\n\t\t\tlogging: {\n\t\t\t\t...base.settings?.logging,\n\t\t\t\t...override.settings?.logging\n\t\t\t}\n\t\t}\n\t};\n\tif (base.mcpServers || override.mcpServers) result.mcpServers = {\n\t\t...base.mcpServers,\n\t\t...override.mcpServers\n\t};\n\tif (base.discovery || override.discovery) {\n\t\tresult.discovery = {\n\t\t\t...base.discovery,\n\t\t\t...override.discovery\n\t\t};\n\t\tif (base.discovery?.cache || override.discovery?.cache) result.discovery.cache = {\n\t\t\t...base.discovery?.cache,\n\t\t\t...override.discovery?.cache\n\t\t};\n\t}\n\treturn result;\n}\n/**\n* Load AnyGPT configuration\n*/\nasync function loadConfig(options = {}) {\n\tconst { configPath, mergeDefaults = !configPath } = options;\n\tlet config$1;\n\tif (configPath) config$1 = await loadConfigFile(configPath);\n\telse {\n\t\tconst foundPath = await findConfigFile();\n\t\tif (foundPath) config$1 = await loadConfigFile(foundPath);\n\t\telse config$1 = getDefaultConfig();\n\t}\n\tconst defaultConfig = getDefaultConfig();\n\tif (mergeDefaults && config$1 !== defaultConfig) config$1 = mergeConfigs(defaultConfig, config$1);\n\treturn config$1;\n}\n/**\n* Validate configuration\n*/\nfunction validateConfig(config$1) {\n\tconst errors = [];\n\tif (!config$1.providers || Object.keys(config$1.providers).length === 0) errors.push(\"Configuration must have at least one provider\");\n\tif (config$1.providers) {\n\t\tfor (const [providerId, provider] of Object.entries(config$1.providers)) if (!provider.connector?.connector) errors.push(`Provider '${providerId}' must specify a connector package`);\n\t}\n\tif (errors.length > 0) throw new ConfigValidationError(errors);\n}\n\n//#endregion\n//#region src/setup.ts\n/**\n* Create and configure a router from configuration\n*/\nasync function setupRouter(options = {}, logger) {\n\tconst config$1 = await loadConfig(options);\n\tconst router = new router_default({\n\t\ttimeout: config$1.settings?.timeout,\n\t\tmaxRetries: config$1.settings?.maxRetries,\n\t\tproviders: convertToRouterProviders(config$1)\n\t});\n\tawait loadConnectors(router, config$1, logger);\n\treturn {\n\t\trouter,\n\t\tconfig: config$1\n\t};\n}\n/**\n* Create router from factory config with direct connector instances\n*/\nasync function setupRouterFromFactory(factoryConfig, logger) {\n\tconst routerProviders = {};\n\tfor (const providerId of Object.keys(factoryConfig.providers)) routerProviders[providerId] = {\n\t\ttype: providerId,\n\t\tapi: {\n\t\t\turl: \"\",\n\t\t\ttoken: \"\",\n\t\t\theaders: {}\n\t\t}\n\t};\n\tconst router = new router_default({\n\t\ttimeout: factoryConfig.defaults?.timeout || 3e4,\n\t\tmaxRetries: factoryConfig.defaults?.maxRetries || 3,\n\t\tproviders: routerProviders\n\t});\n\tfor (const [providerId, providerConfig] of Object.entries(factoryConfig.providers)) {\n\t\tconst connector = providerConfig.connector;\n\t\tif (logger && connector) Object.defineProperty(connector, \"logger\", {\n\t\t\tvalue: logger,\n\t\t\twritable: true,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true\n\t\t});\n\t\trouter.registerConnector({\n\t\t\tgetProviderId: () => providerId,\n\t\t\tcreate: (routerConfig) => {\n\t\t\t\treturn connector;\n\t\t\t}\n\t\t});\n\t}\n\treturn {\n\t\trouter,\n\t\tconfig: factoryConfig\n\t};\n}\n/**\n* Convert AnyGPT config providers to router format\n*/\nfunction convertToRouterProviders(config$1) {\n\tconst routerProviders = {};\n\tfor (const [providerId, providerConfig] of Object.entries(config$1.providers)) {\n\t\tconst connectorConfig = providerConfig.connector;\n\t\tconst connectorType = (connectorConfig.type || connectorConfig.connector).split(\"/\").pop()?.replace(\"@anygpt/\", \"\") || \"unknown\";\n\t\tconst connectorOptions = connectorConfig.options ?? connectorConfig.config ?? {};\n\t\tconst baseURL = typeof connectorOptions[\"baseURL\"] === \"string\" ? connectorOptions[\"baseURL\"] : \"\";\n\t\tconst apiKey = typeof connectorOptions[\"apiKey\"] === \"string\" ? connectorOptions[\"apiKey\"] : \"\";\n\t\tconst timeout = typeof connectorOptions[\"timeout\"] === \"number\" ? connectorOptions[\"timeout\"] : void 0;\n\t\tconst maxRetries = typeof connectorOptions[\"maxRetries\"] === \"number\" ? connectorOptions[\"maxRetries\"] : void 0;\n\t\trouterProviders[providerId] = {\n\t\t\ttype: connectorType,\n\t\t\tapi: {\n\t\t\t\turl: baseURL,\n\t\t\t\ttoken: apiKey,\n\t\t\t\theaders: {}\n\t\t\t},\n\t\t\ttimeout,\n\t\t\tmaxRetries\n\t\t};\n\t}\n\treturn routerProviders;\n}\n\n//#endregion\n//#region src/factory.ts\n/**\n* Factory function to create AnyGPT configuration with direct connector instances\n*/\nfunction config(factoryConfig) {\n\treturn factoryConfig;\n}\n\n//#endregion\n//#region src/glob-matcher.ts\n/**\n* Simple glob pattern matcher for model filtering\n* Supports: *, ?, [abc], {a,b,c}, ! for negation, and regex patterns\n* \n* Regex patterns should be wrapped in /.../ or /.../<flags>\n* Examples:\n*   - /gpt-[45]/ - matches gpt-4 or gpt-5\n*   - /^claude.*sonnet$/i - case-insensitive match\n*/\n/**\n* Check if a pattern is a regex pattern (wrapped in /.../)\n*/\nfunction isRegexPattern(pattern) {\n\treturn pattern.startsWith(\"/\") && pattern.lastIndexOf(\"/\") > 0;\n}\n/**\n* Parse a regex pattern string into a RegExp object\n*/\nfunction parseRegexPattern(pattern) {\n\tconst lastSlash = pattern.lastIndexOf(\"/\");\n\tconst regexBody = pattern.substring(1, lastSlash);\n\tconst flags = pattern.substring(lastSlash + 1);\n\treturn new RegExp(regexBody, flags || \"i\");\n}\n/**\n* Convert a glob pattern to a regular expression\n*/\nfunction globToRegex(pattern) {\n\tconst regex = pattern.replace(/[.+^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/\\{([^}]+)\\}/g, (_, group) => `(${group.replace(/,/g, \"|\")})`).replace(/\\\\\\[([^\\]]+)\\\\\\]/g, \"[$1]\").replace(/\\*/g, \".*\").replace(/\\?/g, \".\");\n\treturn new RegExp(`^${regex}$`, \"i\");\n}\n/**\n* Check if a model ID matches any of the glob/regex patterns\n* Supports negation patterns starting with !, regex patterns wrapped in /.../, and RegExp objects\n* \n* @param modelId - The model ID to test\n* @param patterns - Array of glob strings, regex strings, or RegExp objects (can include negation patterns with !)\n* @returns true if the model matches (considering both positive and negative patterns)\n*/\nfunction matchesGlobPatterns(modelId, patterns) {\n\tif (!patterns || patterns.length === 0) return true;\n\tconst positivePatterns = [];\n\tconst negativePatterns = [];\n\tfor (const pattern of patterns) {\n\t\tif (pattern instanceof RegExp) {\n\t\t\tpositivePatterns.push(pattern);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pattern.startsWith(\"!\")) {\n\t\t\tconst actualPattern = pattern.substring(1);\n\t\t\tif (isRegexPattern(actualPattern)) negativePatterns.push(parseRegexPattern(actualPattern));\n\t\t\telse negativePatterns.push(globToRegex(actualPattern));\n\t\t} else if (isRegexPattern(pattern)) positivePatterns.push(parseRegexPattern(pattern));\n\t\telse positivePatterns.push(globToRegex(pattern));\n\t}\n\tfor (const negPattern of negativePatterns) if (negPattern.test(modelId)) return false;\n\tif (positivePatterns.length === 0) return true;\n\tfor (const posPattern of positivePatterns) if (posPattern.test(modelId)) return true;\n\treturn false;\n}\n\n//#endregion\n//#region src/model-pattern-resolver.ts\n/**\n* Normalize reasoning value to ReasoningConfig object form\n*/\nfunction normalizeReasoning(reasoning) {\n\tif (reasoning === true) return { effort: \"medium\" };\n\telse if (typeof reasoning === \"string\") return { effort: reasoning };\n\telse if (typeof reasoning === \"object\") return reasoning;\n}\n/**\n* Apply a single rule to the resolved configuration\n* @param rule - The rule to apply\n* @param resolved - The resolved configuration being built\n* @param accumulatedTags - Set of accumulated tags\n* @param priority - Priority level: 'global' | 'provider' | 'metadata'\n* @param locked - Set of property names that are locked (from higher priority sources)\n*/\nfunction applyRule(rule, resolved, accumulatedTags, priority, locked) {\n\tif (rule.tags) rule.tags.forEach((tag) => accumulatedTags.add(tag));\n\tif (rule.reasoning !== void 0 && !locked.has(\"reasoning\")) {\n\t\tif (priority === \"provider\") {\n\t\t\tresolved.reasoning = rule.reasoning === false ? void 0 : normalizeReasoning(rule.reasoning);\n\t\t\tlocked.add(\"reasoning\");\n\t\t} else if (!resolved.reasoning) resolved.reasoning = normalizeReasoning(rule.reasoning);\n\t}\n\tif (rule.max_tokens !== void 0 && !locked.has(\"max_tokens\")) {\n\t\tif (priority === \"provider\") {\n\t\t\tresolved.max_tokens = rule.max_tokens;\n\t\t\tlocked.add(\"max_tokens\");\n\t\t} else if (resolved.max_tokens === void 0) resolved.max_tokens = rule.max_tokens;\n\t}\n\tif (rule.useLegacyMaxTokens !== void 0 && !locked.has(\"useLegacyMaxTokens\")) {\n\t\tif (priority === \"provider\") {\n\t\t\tresolved.useLegacyMaxTokens = rule.useLegacyMaxTokens;\n\t\t\tlocked.add(\"useLegacyMaxTokens\");\n\t\t} else if (resolved.useLegacyMaxTokens === void 0) resolved.useLegacyMaxTokens = rule.useLegacyMaxTokens;\n\t}\n\tif (rule.useLegacyCompletionAPI !== void 0 && !locked.has(\"useLegacyCompletionAPI\")) {\n\t\tif (priority === \"provider\") {\n\t\t\tresolved.useLegacyCompletionAPI = rule.useLegacyCompletionAPI;\n\t\t\tlocked.add(\"useLegacyCompletionAPI\");\n\t\t} else if (resolved.useLegacyCompletionAPI === void 0) resolved.useLegacyCompletionAPI = rule.useLegacyCompletionAPI;\n\t}\n\tif (rule.fallbackToChatCompletion !== void 0 && !locked.has(\"fallbackToChatCompletion\")) {\n\t\tif (priority === \"provider\") {\n\t\t\tresolved.fallbackToChatCompletion = rule.fallbackToChatCompletion;\n\t\t\tlocked.add(\"fallbackToChatCompletion\");\n\t\t} else if (resolved.fallbackToChatCompletion === void 0) resolved.fallbackToChatCompletion = rule.fallbackToChatCompletion;\n\t}\n\tif (rule.extra_body) resolved.extra_body = {\n\t\t...resolved.extra_body,\n\t\t...rule.extra_body\n\t};\n\tif (rule.enabled !== void 0 && !locked.has(\"enabled\")) {\n\t\tif (priority === \"provider\") {\n\t\t\tresolved.enabled = rule.enabled;\n\t\t\tlocked.add(\"enabled\");\n\t\t} else if (resolved.enabled === void 0) resolved.enabled = rule.enabled;\n\t}\n}\n/**\n* Apply matching rules from a rule set\n*/\nfunction applyMatchingRules(modelId, rules, resolved, accumulatedTags, priority, locked) {\n\tif (!rules) return;\n\tfor (const rule of rules) if (matchesGlobPatterns(modelId, rule.pattern)) applyRule(rule, resolved, accumulatedTags, priority, locked);\n}\n/**\n* Resolve model configuration by matching against rules\n* Priority: explicit model metadata > provider rules > global rules\n* Tags are accumulated (merged), other properties use first-match-wins\n*\n* @param modelId - The model ID to resolve config for\n* @param provider - Provider ID\n* @param providerConfig - Provider configuration\n* @param globalRules - Global model rules from defaults\n* @returns Resolved model configuration\n*/\nfunction resolveModelConfig(modelId, provider, providerConfig, globalRules) {\n\tconst resolved = {};\n\tconst accumulatedTags = /* @__PURE__ */ new Set();\n\tconst locked = /* @__PURE__ */ new Set();\n\tconst hasWhitelistRules = providerConfig.modelRules?.some((rule) => rule.enabled === true) || globalRules?.some((rule) => rule.enabled === true);\n\tconst modelMetadata = providerConfig.models?.[modelId];\n\tif (modelMetadata) {\n\t\tif (modelMetadata.tags) modelMetadata.tags.forEach((tag) => accumulatedTags.add(tag));\n\t\tif (modelMetadata.reasoning) {\n\t\t\tif (typeof modelMetadata.reasoning === \"string\") resolved.reasoning = { effort: modelMetadata.reasoning };\n\t\t\telse resolved.reasoning = modelMetadata.reasoning;\n\t\t\tlocked.add(\"reasoning\");\n\t\t}\n\t\tif (modelMetadata.max_tokens !== void 0) {\n\t\t\tresolved.max_tokens = modelMetadata.max_tokens;\n\t\t\tlocked.add(\"max_tokens\");\n\t\t}\n\t\tif (modelMetadata.useLegacyMaxTokens !== void 0) {\n\t\t\tresolved.useLegacyMaxTokens = modelMetadata.useLegacyMaxTokens;\n\t\t\tlocked.add(\"useLegacyMaxTokens\");\n\t\t}\n\t\tif (modelMetadata.useLegacyCompletionAPI !== void 0) {\n\t\t\tresolved.useLegacyCompletionAPI = modelMetadata.useLegacyCompletionAPI;\n\t\t\tlocked.add(\"useLegacyCompletionAPI\");\n\t\t}\n\t\tif (modelMetadata.fallbackToChatCompletion !== void 0) {\n\t\t\tresolved.fallbackToChatCompletion = modelMetadata.fallbackToChatCompletion;\n\t\t\tlocked.add(\"fallbackToChatCompletion\");\n\t\t}\n\t\tif (modelMetadata.extra_body !== void 0) resolved.extra_body = { ...modelMetadata.extra_body };\n\t}\n\tapplyMatchingRules(modelId, globalRules, resolved, accumulatedTags, \"global\", locked);\n\tapplyMatchingRules(modelId, providerConfig.modelRules, resolved, accumulatedTags, \"provider\", locked);\n\tif (accumulatedTags.size > 0) resolved.tags = Array.from(accumulatedTags);\n\tif (hasWhitelistRules && resolved.enabled === void 0) resolved.enabled = false;\n\treturn resolved;\n}\n\n//#endregion\n//#region src/model-resolver.ts\n/**\n* Search for a model by tag in provider configs\n* Returns { provider, model } or null if not found\n* Searches both explicit models and modelRules\n*/\nfunction findModelByTag(tag, providers, preferredProvider, globalModelRules) {\n\tif (preferredProvider) {\n\t\tconst providerConfig = providers[preferredProvider];\n\t\tif (providerConfig?.models) {\n\t\t\tfor (const [modelName, metadata] of Object.entries(providerConfig.models)) if (metadata.tags?.includes(tag)) return {\n\t\t\t\tprovider: preferredProvider,\n\t\t\t\tmodel: modelName\n\t\t\t};\n\t\t}\n\t\tif (providerConfig?.modelRules) {\n\t\t\tfor (const rule of providerConfig.modelRules) if (rule.tags?.includes(tag)) return null;\n\t\t}\n\t\tif (globalModelRules) {\n\t\t\tfor (const rule of globalModelRules) if (rule.tags?.includes(tag)) return null;\n\t\t}\n\t}\n\tfor (const [providerId, providerConfig] of Object.entries(providers)) if (providerConfig.models) {\n\t\tfor (const [modelName, metadata] of Object.entries(providerConfig.models)) if (metadata.tags?.includes(tag)) return {\n\t\t\tprovider: providerId,\n\t\t\tmodel: modelName\n\t\t};\n\t}\n\treturn null;\n}\n/**\n* Resolve a model name using hybrid approach:\n* 1. Check central aliases (can reference tags or direct models)\n* 2. Search per-provider tags\n* 3. Return null if not found (treat as direct model name)\n*/\nfunction resolveModel(modelName, context, preferredProvider) {\n\tif (context.aliases?.[modelName]) {\n\t\tconst aliasList = context.aliases[modelName];\n\t\tif (preferredProvider) {\n\t\t\tconst match = aliasList.find((a) => a.provider === preferredProvider);\n\t\t\tif (match) {\n\t\t\t\tif (match.tag) {\n\t\t\t\t\tconst tagResult$1 = findModelByTag(match.tag, context.providers, match.provider);\n\t\t\t\t\tif (tagResult$1) return tagResult$1;\n\t\t\t\t}\n\t\t\t\tif (match.model) return {\n\t\t\t\t\tprovider: match.provider,\n\t\t\t\t\tmodel: match.model\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tconst firstAlias = aliasList[0];\n\t\tif (firstAlias.tag) {\n\t\t\tconst tagResult$1 = findModelByTag(firstAlias.tag, context.providers, firstAlias.provider);\n\t\t\tif (tagResult$1) return tagResult$1;\n\t\t}\n\t\tif (firstAlias.model) return {\n\t\t\tprovider: firstAlias.provider,\n\t\t\tmodel: firstAlias.model\n\t\t};\n\t}\n\tconst tagResult = findModelByTag(modelName, context.providers, preferredProvider);\n\tif (tagResult) return tagResult;\n\treturn null;\n}\n/**\n* List all available tags, aliases, and their model mappings from configuration\n* This makes tag resolution discoverable for users and external agents\n* Now includes tags from both explicit models AND modelRules\n*/\nfunction listAvailableTags(context) {\n\tconst tags = [];\n\tconst aliases = [];\n\tconst providers = [];\n\tfor (const [providerId, providerConfig] of Object.entries(context.providers)) providers.push({\n\t\tid: providerId,\n\t\tname: providerConfig.name,\n\t\tisDefault: providerId === context.defaultProvider\n\t});\n\tfor (const [providerId, providerConfig] of Object.entries(context.providers)) {\n\t\tif (!providerConfig.models) continue;\n\t\tfor (const [modelName, metadata] of Object.entries(providerConfig.models)) if (metadata.tags) for (const tag of metadata.tags) tags.push({\n\t\t\ttag,\n\t\t\tprovider: providerId,\n\t\t\tproviderName: providerConfig.name,\n\t\t\tmodel: modelName,\n\t\t\tisDefault: providerId === context.defaultProvider && modelName === providerConfig.settings?.defaultModel\n\t\t});\n\t}\n\tfor (const [providerId, providerConfig] of Object.entries(context.providers)) {\n\t\tif (!providerConfig.modelRules) continue;\n\t\tfor (const rule of providerConfig.modelRules) if (rule.tags) for (const tag of rule.tags) tags.push({\n\t\t\ttag,\n\t\t\tprovider: providerId,\n\t\t\tproviderName: providerConfig.name,\n\t\t\tmodel: `[pattern: ${rule.pattern.join(\", \")}]`,\n\t\t\tisDefault: false\n\t\t});\n\t}\n\tif (context.globalModelRules) {\n\t\tfor (const rule of context.globalModelRules) if (rule.tags) for (const tag of rule.tags) for (const [providerId, providerConfig] of Object.entries(context.providers)) tags.push({\n\t\t\ttag,\n\t\t\tprovider: providerId,\n\t\t\tproviderName: providerConfig.name,\n\t\t\tmodel: `[global pattern: ${rule.pattern.join(\", \")}]`,\n\t\t\tisDefault: false\n\t\t});\n\t}\n\tif (context.aliases) for (const [aliasName, aliasList] of Object.entries(context.aliases)) for (const alias of aliasList) {\n\t\tconst aliasInfo = {\n\t\t\talias: aliasName,\n\t\t\tprovider: alias.provider,\n\t\t\tproviderName: context.providers[alias.provider]?.name,\n\t\t\tmodel: alias.model,\n\t\t\ttag: alias.tag\n\t\t};\n\t\tif (alias.tag) {\n\t\t\tconst resolution = findModelByTag(alias.tag, context.providers, alias.provider);\n\t\t\tif (resolution) aliasInfo.resolvedModel = resolution.model;\n\t\t}\n\t\taliases.push(aliasInfo);\n\t}\n\treturn {\n\t\ttags,\n\t\taliases,\n\t\tproviders\n\t};\n}\n\n//#endregion\n//#region src/tag-registry.ts\n/**\n* Build tag registry from providers and their model lists\n*/\nasync function buildTagRegistry(providers, globalModelRules) {\n\tconst tags = /* @__PURE__ */ new Map();\n\tconst addTag = (tag, provider, model, source) => {\n\t\tconst existing = tags.get(tag);\n\t\tif (existing) existing.push({\n\t\t\tprovider,\n\t\t\tmodel,\n\t\t\tsource\n\t\t});\n\t\telse tags.set(tag, [{\n\t\t\tprovider,\n\t\t\tmodel,\n\t\t\tsource\n\t\t}]);\n\t};\n\tfor (const [providerId, providerConfig] of Object.entries(providers)) {\n\t\tconst explicitModels = [];\n\t\tif (providerConfig.models) for (const [modelName, metadata] of Object.entries(providerConfig.models)) {\n\t\t\texplicitModels.push(modelName);\n\t\t\tif (metadata.tags) for (const tag of metadata.tags) addTag(tag, providerId, modelName, \"explicit\");\n\t\t}\n\t\tlet actualModels = [];\n\t\ttry {\n\t\t\tactualModels = (await providerConfig.connector.listModels()).map((m) => m.id);\n\t\t} catch {}\n\t\tconst modelsForRules = actualModels.length > 0 ? actualModels : explicitModels;\n\t\tif (providerConfig.modelRules && modelsForRules.length > 0) for (const rule of providerConfig.modelRules) {\n\t\t\tif (!rule.tags) continue;\n\t\t\tconst matchingModels = modelsForRules.filter((modelId) => matchesPatterns(modelId, rule.pattern));\n\t\t\tfor (const tag of rule.tags) for (const modelId of matchingModels) addTag(tag, providerId, modelId, \"provider-rule\");\n\t\t}\n\t\tif (globalModelRules && modelsForRules.length > 0) for (const rule of globalModelRules) {\n\t\t\tif (!rule.tags) continue;\n\t\t\tconst matchingModels = modelsForRules.filter((modelId) => matchesPatterns(modelId, rule.pattern));\n\t\t\tfor (const tag of rule.tags) for (const modelId of matchingModels) addTag(tag, providerId, modelId, \"global-rule\");\n\t\t}\n\t}\n\treturn {\n\t\ttags,\n\t\tresolve(tag, preferredProvider) {\n\t\t\tconst mappings = tags.get(tag);\n\t\t\tif (!mappings || mappings.length === 0) return null;\n\t\t\tif (preferredProvider) {\n\t\t\t\tconst match = mappings.find((m) => m.provider === preferredProvider);\n\t\t\t\tif (match) return match;\n\t\t\t}\n\t\t\treturn [...mappings].sort((a, b) => {\n\t\t\t\tconst priority = {\n\t\t\t\t\texplicit: 0,\n\t\t\t\t\t\"provider-rule\": 1,\n\t\t\t\t\t\"global-rule\": 2\n\t\t\t\t};\n\t\t\t\treturn priority[a.source] - priority[b.source];\n\t\t\t})[0];\n\t\t}\n\t};\n}\n/**\n* Check if a model ID matches any of the patterns\n* Supports glob patterns, regex strings, and RegExp objects\n*/\nfunction matchesPatterns(modelId, patterns) {\n\tfor (const pattern of patterns) if (typeof pattern === \"string\") {\n\t\tif (pattern.startsWith(\"/\")) {\n\t\t\tconst regexMatch = pattern.match(/^\\/(.+?)\\/([gimuy]*)$/);\n\t\t\tif (regexMatch) {\n\t\t\t\tif (new RegExp(regexMatch[1], regexMatch[2]).test(modelId)) return true;\n\t\t\t}\n\t\t} else if (minimatch(modelId, pattern)) return true;\n\t} else if (pattern instanceof RegExp) {\n\t\tif (pattern.test(modelId)) return true;\n\t}\n\treturn false;\n}\n\n//#endregion\nexport { ConfigError, ConfigNotFoundError, ConfigParseError, ConfigValidationError, ConnectorLoadError, buildTagRegistry, clearConnectorCache, config, findModelByTag, getConnectorConfig, getDefaultConfig, listAvailableTags, loadConfig, loadConnectors, matchesGlobPatterns, resolveModel, resolveModelConfig, setupRouter, setupRouterFromFactory, validateConfig };\n//# sourceMappingURL=index.js.map","import { matchesGlobPatterns } from '@anygpt/config';\nimport type { ToolRule } from './types.js';\n\n/**\n * Pattern matcher for tool filtering\n * Reuses glob-matcher from @anygpt/config\n */\nexport class PatternMatcher {\n  /**\n   * Check if a tool name matches any of the patterns\n   * \n   * @param toolName - Tool name to match\n   * @param patterns - Array of glob or regex patterns\n   * @returns true if tool matches any pattern\n   */\n  matchTool(toolName: string, patterns: string[]): boolean {\n    return matchesGlobPatterns(toolName, patterns);\n  }\n\n  /**\n   * Check if a tool matches a specific rule\n   * \n   * @param toolName - Tool name to match\n   * @param serverName - Server name\n   * @param rule - Tool rule to check\n   * @returns true if tool matches the rule\n   */\n  matchRule(toolName: string, serverName: string, rule: ToolRule): boolean {\n    // If rule has server filter, check server name first\n    if (rule.server && rule.server !== serverName) {\n      return false;\n    }\n\n    // Check if tool name matches pattern\n    return this.matchTool(toolName, rule.pattern);\n  }\n\n  /**\n   * Find all rules that match a tool\n   * \n   * @param toolName - Tool name to match\n   * @param serverName - Server name\n   * @param rules - Array of tool rules\n   * @returns Array of matching rules\n   */\n  findMatchingRules(toolName: string, serverName: string, rules: ToolRule[]): ToolRule[] {\n    return rules.filter(rule => this.matchRule(toolName, serverName, rule));\n  }\n}\n","import type { ToolMetadata, SearchOptions, SearchResult } from './types.js';\n\n/**\n * Search engine for tool discovery with relevance scoring\n */\nexport class SearchEngine {\n  private tools: ToolMetadata[] = [];\n\n  /**\n   * Index tools for search\n   * \n   * @param tools - Array of tool metadata to index\n   */\n  index(tools: ToolMetadata[]): void {\n    this.tools = tools;\n  }\n\n  /**\n   * Search for tools with relevance scoring\n   * \n   * @param query - Search query\n   * @param options - Search options\n   * @returns Array of search results sorted by relevance\n   */\n  search(query: string, options?: SearchOptions): SearchResult[] {\n    const queryLower = query.toLowerCase();\n    const queryTokens = queryLower.split(/\\s+/).filter(t => t.length > 0);\n\n    // Filter tools\n    let filteredTools = this.tools;\n\n    // Filter by server if specified\n    if (options?.server) {\n      filteredTools = filteredTools.filter(t => t.server === options.server);\n    }\n\n    // Filter by enabled status (exclude disabled by default)\n    if (!options?.includeDisabled) {\n      filteredTools = filteredTools.filter(t => t.enabled);\n    }\n\n    // Calculate relevance scores\n    const results: SearchResult[] = [];\n\n    for (const tool of filteredTools) {\n      const relevance = this.calculateRelevance(tool, queryLower, queryTokens);\n      \n      if (relevance > 0) {\n        results.push({\n          server: tool.server,\n          tool: tool.name,\n          summary: tool.summary,\n          relevance,\n          tags: tool.tags\n        });\n      }\n    }\n\n    // Sort by relevance (descending)\n    results.sort((a, b) => b.relevance - a.relevance);\n\n    // Apply limit if specified\n    if (options?.limit && options.limit > 0) {\n      return results.slice(0, options.limit);\n    }\n\n    return results;\n  }\n\n  /**\n   * Calculate relevance score for a tool\n   * \n   * @param tool - Tool metadata\n   * @param query - Lowercase query string\n   * @param queryTokens - Query split into tokens\n   * @returns Relevance score (0-1)\n   */\n  private calculateRelevance(\n    tool: ToolMetadata,\n    query: string,\n    queryTokens: string[]\n  ): number {\n    const toolNameLower = tool.name.toLowerCase();\n    const summaryLower = tool.summary.toLowerCase();\n    const tagsLower = tool.tags.map(t => t.toLowerCase());\n\n    let score = 0;\n\n    // Exact match in tool name (highest weight)\n    if (toolNameLower === query) {\n      score += 1.0;\n    } else if (toolNameLower.includes(query)) {\n      score += 0.8;\n    }\n\n    // Exact match in summary\n    if (summaryLower.includes(query)) {\n      score += 0.6;\n    }\n\n    // Partial match (tokenized)\n    for (const token of queryTokens) {\n      if (toolNameLower.includes(token)) {\n        score += 0.4;\n      }\n      if (summaryLower.includes(token)) {\n        score += 0.2;\n      }\n    }\n\n    // Tag match\n    for (const tag of tagsLower) {\n      if (query.includes(tag) || tag.includes(query)) {\n        score += 0.3;\n      }\n      for (const token of queryTokens) {\n        if (tag.includes(token)) {\n          score += 0.15;\n        }\n      }\n    }\n\n    // Normalize score to [0, 1]\n    return Math.min(score, 1.0);\n  }\n}\n","import type { ToolMetadata, ToolRule } from './types.js';\nimport { PatternMatcher } from './pattern-matcher.js';\n\n/**\n * Tool metadata manager for storing and filtering tools\n */\nexport class ToolMetadataManager {\n  private tools: Map<string, ToolMetadata> = new Map();\n  private patternMatcher: PatternMatcher = new PatternMatcher();\n\n  /**\n   * Add or update a tool\n   * \n   * @param tool - Tool metadata to add\n   */\n  addTool(tool: ToolMetadata): void {\n    const key = this.getToolKey(tool.server, tool.name);\n    this.tools.set(key, tool);\n  }\n\n  /**\n   * Get a specific tool\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Tool metadata or null if not found\n   */\n  getTool(server: string, tool: string): ToolMetadata | null {\n    const key = this.getToolKey(server, tool);\n    return this.tools.get(key) || null;\n  }\n\n  /**\n   * Get all tools from a specific server\n   * \n   * @param server - Server name\n   * @param includeDisabled - Include disabled tools\n   * @returns Array of tool metadata\n   */\n  getToolsByServer(server: string, includeDisabled = false): ToolMetadata[] {\n    const tools: ToolMetadata[] = [];\n    \n    for (const tool of this.tools.values()) {\n      if (tool.server === server) {\n        if (includeDisabled || tool.enabled) {\n          tools.push(tool);\n        }\n      }\n    }\n    \n    return tools;\n  }\n\n  /**\n   * Get all tools from all servers\n   * \n   * @param includeDisabled - Include disabled tools\n   * @returns Array of tool metadata\n   */\n  getAllTools(includeDisabled = false): ToolMetadata[] {\n    const tools: ToolMetadata[] = [];\n    \n    for (const tool of this.tools.values()) {\n      if (includeDisabled || tool.enabled) {\n        tools.push(tool);\n      }\n    }\n    \n    return tools;\n  }\n\n  /**\n   * Apply filtering rules to all tools\n   * \n   * @param rules - Array of tool rules\n   */\n  applyRules(rules: ToolRule[]): void {\n    // Check if whitelist mode (any rule has enabled: true)\n    const hasWhitelist = rules.some(r => r.enabled === true);\n\n    // Apply rules to each tool\n    for (const tool of this.tools.values()) {\n      // Start with default enabled status\n      let enabled = !hasWhitelist; // In whitelist mode, default is disabled\n      const tags: string[] = [...tool.tags];\n\n      // Process rules in order\n      for (const rule of rules) {\n        // Check if rule matches this tool\n        if (!this.patternMatcher.matchRule(tool.name, tool.server, rule)) {\n          continue;\n        }\n\n        // First matching rule with enabled field sets the status\n        if (rule.enabled !== undefined) {\n          enabled = rule.enabled;\n        }\n\n        // Accumulate tags from all matching rules\n        if (rule.tags) {\n          tags.push(...rule.tags);\n        }\n      }\n\n      // Update tool with new enabled status and tags\n      tool.enabled = enabled;\n      tool.tags = [...new Set(tags)]; // Deduplicate tags\n    }\n  }\n\n  /**\n   * Get total tool count for a server\n   * \n   * @param server - Server name\n   * @returns Total tool count\n   */\n  getToolCount(server: string): number {\n    let count = 0;\n    for (const tool of this.tools.values()) {\n      if (tool.server === server) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get enabled tool count for a server\n   * \n   * @param server - Server name\n   * @returns Enabled tool count\n   */\n  getEnabledCount(server: string): number {\n    let count = 0;\n    for (const tool of this.tools.values()) {\n      if (tool.server === server && tool.enabled) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Generate a unique key for a tool\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Unique key\n   */\n  private getToolKey(server: string, tool: string): string {\n    return `${server}:${tool}`;\n  }\n}\n","import type { ServerMetadata, ToolMetadata } from './types.js';\n\n/**\n * Cache entry with TTL\n */\ninterface CacheEntry<T> {\n  data: T;\n  expiresAt: number | null; // null = never expires\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Caching layer for discovery engine\n * Supports TTL-based caching for servers and tool summaries\n * Indefinite caching for tool details\n */\nexport class CachingLayer {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private cache: Map<string, CacheEntry<any>> = new Map();\n\n  /**\n   * Cache server list with TTL\n   * \n   * @param servers - Array of server metadata\n   * @param ttl - Time-to-live in seconds\n   */\n  cacheServerList(servers: ServerMetadata[], ttl: number): void {\n    this.cache.set('servers', {\n      data: servers,\n      expiresAt: Date.now() + ttl * 1000\n    });\n  }\n\n  /**\n   * Get cached server list\n   * \n   * @returns Cached server list or null if not cached/expired\n   */\n  getServerList(): ServerMetadata[] | null {\n    return this.get<ServerMetadata[]>('servers');\n  }\n\n  /**\n   * Cache tool summaries for a specific server with TTL\n   * \n   * @param server - Server name\n   * @param tools - Array of tool metadata\n   * @param ttl - Time-to-live in seconds\n   */\n  cacheToolSummaries(server: string, tools: ToolMetadata[], ttl: number): void {\n    const key = `tools:${server}`;\n    this.cache.set(key, {\n      data: tools,\n      expiresAt: Date.now() + ttl * 1000\n    });\n  }\n\n  /**\n   * Get cached tool summaries for a specific server\n   * \n   * @param server - Server name\n   * @returns Cached tool summaries or null if not cached/expired\n   */\n  getToolSummaries(server: string): ToolMetadata[] | null {\n    const key = `tools:${server}`;\n    return this.get<ToolMetadata[]>(key);\n  }\n\n  /**\n   * Cache tool details indefinitely\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @param details - Tool metadata with full details\n   */\n  cacheToolDetails(server: string, tool: string, details: ToolMetadata): void {\n    const key = `tool:${server}:${tool}`;\n    this.cache.set(key, {\n      data: details,\n      expiresAt: null // Never expires\n    });\n  }\n\n  /**\n   * Get cached tool details\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Cached tool details or null if not cached\n   */\n  getToolDetails(server: string, tool: string): ToolMetadata | null {\n    const key = `tool:${server}:${tool}`;\n    return this.get<ToolMetadata>(key);\n  }\n\n  /**\n   * Invalidate a specific cache key\n   * \n   * @param key - Cache key to invalidate (e.g., 'servers', 'tools:github')\n   */\n  invalidate(key: string): void {\n    this.cache.delete(key);\n  }\n\n  /**\n   * Invalidate all caches\n   */\n  invalidateAll(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cached value if not expired\n   * \n   * @param key - Cache key\n   * @returns Cached value or null if not cached/expired\n   */\n  private get<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    \n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired (null expiresAt means never expires)\n    if (entry.expiresAt !== null && Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data as T;\n  }\n}\n","import type { MCPServerConfig, ExecutionResult } from './types.js';\n\n/**\n * Tool execution proxy for connecting to MCP servers\n * \n * Note: This is the initial implementation that provides the interface.\n * Full MCP SDK integration will be added in the next iteration.\n */\nexport class ToolExecutionProxy {\n  private connections: Map<string, boolean> = new Map();\n\n  /**\n   * Execute a tool on a remote MCP server\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @param args - Tool arguments\n   * @returns Execution result\n   */\n  async execute(\n    server: string,\n    tool: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any\n  ): Promise<ExecutionResult> {\n    // Validate arguments\n    if (args === null || args === undefined) {\n      return {\n        success: false,\n        error: {\n          code: 'INVALID_ARGUMENTS',\n          message: 'Tool arguments cannot be null or undefined',\n          server,\n          tool\n        }\n      };\n    }\n\n    // Check if server is connected\n    if (!this.isConnected(server)) {\n      return {\n        success: false,\n        error: {\n          code: 'SERVER_NOT_CONNECTED',\n          message: `Server ${server} is not connected`,\n          server,\n          tool\n        }\n      };\n    }\n\n    // TODO: Implement actual MCP server connection and tool execution\n    // For now, return an error indicating this is not yet implemented\n    return {\n      success: false,\n      error: {\n        code: 'NOT_IMPLEMENTED',\n        message: 'Tool execution proxy is not yet fully implemented',\n        server,\n        tool\n      }\n    };\n  }\n\n  /**\n   * Connect to an MCP server\n   * \n   * @param server - Server name\n   * @param _config - Server configuration (unused in stub implementation)\n   */\n  async connect(server: string, _config: MCPServerConfig): Promise<void> {\n    // TODO: Implement actual MCP server connection using SDK\n    // For now, just mark as connected\n    this.connections.set(server, true);\n  }\n\n  /**\n   * Disconnect from an MCP server\n   * \n   * @param server - Server name\n   */\n  async disconnect(server: string): Promise<void> {\n    this.connections.delete(server);\n  }\n\n  /**\n   * Check if connected to a server\n   * \n   * @param server - Server name\n   * @returns true if connected\n   */\n  isConnected(server: string): boolean {\n    return this.connections.get(server) === true;\n  }\n}\n","import type {\n  DiscoveryConfig,\n  ServerMetadata,\n  SearchOptions,\n  SearchResult,\n  ToolMetadata,\n  ExecutionResult,\n  MCPServerConfig\n} from './types.js';\nimport { SearchEngine } from './search-engine.js';\nimport { ToolMetadataManager } from './tool-metadata-manager.js';\nimport { CachingLayer } from './caching-layer.js';\nimport { ToolExecutionProxy } from './tool-execution-proxy.js';\n\n/**\n * Main discovery engine facade that coordinates all components\n */\nexport class DiscoveryEngine {\n  private config: DiscoveryConfig;\n  private mcpServers: Record<string, MCPServerConfig>;\n  private searchEngine: SearchEngine;\n  private metadataManager: ToolMetadataManager;\n  private cache: CachingLayer;\n  private executionProxy: ToolExecutionProxy;\n\n  constructor(config: DiscoveryConfig, mcpServers?: Record<string, MCPServerConfig>) {\n    this.config = config;\n    this.mcpServers = mcpServers || {};\n    this.searchEngine = new SearchEngine();\n    this.metadataManager = new ToolMetadataManager();\n    this.cache = new CachingLayer();\n    this.executionProxy = new ToolExecutionProxy();\n\n    // Apply initial configuration\n    this.applyConfiguration();\n  }\n\n  /**\n   * List all available MCP servers\n   * \n   * @returns Array of server metadata\n   */\n  async listServers(): Promise<ServerMetadata[]> {\n    // Check cache first if enabled\n    if (this.config.cache?.enabled) {\n      const cached = this.cache.getServerList();\n      if (cached) {\n        return cached;\n      }\n    }\n\n    // Convert MCP server configs to ServerMetadata\n    const servers: ServerMetadata[] = Object.entries(this.mcpServers).map(([name, config]) => {\n      // Get tools for this server from metadata manager\n      const tools = this.metadataManager.getToolsByServer(name, true);\n      const enabledTools = tools.filter(t => t.enabled);\n\n      return {\n        name,\n        description: config.description || `MCP server: ${name}`,\n        toolCount: tools.length,\n        enabledCount: enabledTools.length,\n        status: 'connected', // TODO: Actually check connection status\n        config: {\n          command: config.command,\n          args: config.args || [],\n          env: config.env\n        }\n      };\n    });\n\n    // Cache if enabled\n    if (this.config.cache?.enabled && this.config.cache.ttl) {\n      this.cache.cacheServerList(servers, this.config.cache.ttl);\n    }\n\n    return servers;\n  }\n\n  /**\n   * Search for tools across all servers\n   * \n   * @param query - Search query\n   * @param options - Search options\n   * @returns Array of search results\n   */\n  async searchTools(query: string, options?: SearchOptions): Promise<SearchResult[]> {\n    // Get all tools from metadata manager\n    const tools = this.metadataManager.getAllTools(options?.includeDisabled);\n\n    // Index tools in search engine\n    this.searchEngine.index(tools);\n\n    // Perform search\n    return this.searchEngine.search(query, options);\n  }\n\n  /**\n   * List tools from a specific server\n   * \n   * @param server - Server name\n   * @param includeDisabled - Include disabled tools\n   * @returns Array of tool metadata\n   */\n  async listTools(server: string, includeDisabled = false): Promise<ToolMetadata[]> {\n    // Check cache first if enabled\n    if (this.config.cache?.enabled && !includeDisabled) {\n      const cached = this.cache.getToolSummaries(server);\n      if (cached) {\n        return cached;\n      }\n    }\n\n    // Get tools from metadata manager\n    const tools = this.metadataManager.getToolsByServer(server, includeDisabled);\n\n    // Cache if enabled\n    if (this.config.cache?.enabled && this.config.cache.ttl && !includeDisabled) {\n      this.cache.cacheToolSummaries(server, tools, this.config.cache.ttl);\n    }\n\n    return tools;\n  }\n\n  /**\n   * Get detailed information about a specific tool\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @returns Tool metadata or null if not found\n   */\n  async getToolDetails(server: string, tool: string): Promise<ToolMetadata | null> {\n    // Check cache first if enabled\n    if (this.config.cache?.enabled) {\n      const cached = this.cache.getToolDetails(server, tool);\n      if (cached) {\n        return cached;\n      }\n    }\n\n    // Get tool from metadata manager\n    const toolMetadata = this.metadataManager.getTool(server, tool);\n\n    // Cache if enabled and found\n    if (this.config.cache?.enabled && toolMetadata) {\n      this.cache.cacheToolDetails(server, tool, toolMetadata);\n    }\n\n    return toolMetadata;\n  }\n\n  /**\n   * Execute a tool from any discovered MCP server\n   * \n   * @param server - Server name\n   * @param tool - Tool name\n   * @param args - Tool arguments\n   * @returns Execution result\n   */\n  async executeTool(\n    server: string,\n    tool: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any\n  ): Promise<ExecutionResult> {\n    // Check if tool is enabled\n    const toolMetadata = this.metadataManager.getTool(server, tool);\n    if (!toolMetadata) {\n      return {\n        success: false,\n        error: {\n          code: 'TOOL_NOT_FOUND',\n          message: `Tool ${tool} not found on server ${server}`,\n          server,\n          tool\n        }\n      };\n    }\n\n    if (!toolMetadata.enabled) {\n      return {\n        success: false,\n        error: {\n          code: 'TOOL_DISABLED',\n          message: `Tool ${tool} is disabled`,\n          server,\n          tool\n        }\n      };\n    }\n\n    // Execute tool via proxy\n    return this.executionProxy.execute(server, tool, args);\n  }\n\n  /**\n   * Reload configuration\n   */\n  async reload(): Promise<void> {\n    // Invalidate all caches\n    this.cache.invalidateAll();\n\n    // Reapply configuration\n    this.applyConfiguration();\n  }\n\n  /**\n   * Get current configuration\n   * \n   * @returns Current discovery configuration\n   */\n  getConfig(): DiscoveryConfig {\n    return this.config;\n  }\n\n  /**\n   * Apply configuration to components\n   */\n  private applyConfiguration(): void {\n    // Apply tool rules to metadata manager\n    if (this.config.toolRules && this.config.toolRules.length > 0) {\n      this.metadataManager.applyRules(this.config.toolRules);\n    }\n  }\n}\n"],"mappings":"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"}