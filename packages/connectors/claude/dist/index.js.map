{"version":3,"file":"index.js","names":["options: Options","collectedMessages: SDKMessage[]"],"sources":["../../../router/dist/index.js","../src/index.ts"],"sourcesContent":["//#region src/connectors/registry.ts\nvar ConnectorRegistry = class {\n\tfactories = /* @__PURE__ */ new Map();\n\tregisterConnector(factory) {\n\t\tconst connectorType = factory.getProviderId();\n\t\tif (!this.factories.has(connectorType)) this.factories.set(connectorType, factory);\n\t}\n\tcreateConnector(providerId, config = {}) {\n\t\tconst factory = this.factories.get(providerId);\n\t\tif (!factory) throw new Error(`No connector registered for provider: ${providerId}`);\n\t\treturn factory.create(config);\n\t}\n\tgetConnector(providerId, config = {}) {\n\t\treturn this.createConnector(providerId, config);\n\t}\n\thasConnector(providerId) {\n\t\treturn this.factories.has(providerId);\n\t}\n\tgetAvailableProviders() {\n\t\treturn Array.from(this.factories.keys());\n\t}\n\tunregisterConnector(providerId) {\n\t\treturn this.factories.delete(providerId);\n\t}\n\tclear() {\n\t\tthis.factories.clear();\n\t}\n\tasync getAllModels() {\n\t\tconst results = [];\n\t\tfor (const [providerId, factory] of this.factories) try {\n\t\t\tconst models = await factory.create({}).listModels();\n\t\t\tresults.push({\n\t\t\t\tprovider: providerId,\n\t\t\t\tmodels\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tconsole.warn(`Failed to get models from ${providerId}:`, error);\n\t\t}\n\t\treturn results;\n\t}\n};\nconst globalConnectorRegistry = new ConnectorRegistry();\n\n//#endregion\n//#region src/errors.ts\n/**\n* Custom error classes for the router package\n* Following TypeScript best practices for error handling\n*/\n/**\n* Base error class for all router-related errors\n*/\nvar RouterError = class extends Error {\n\tconstructor(message, code) {\n\t\tsuper(message);\n\t\tthis.code = code;\n\t\tthis.name = \"RouterError\";\n\t\tif (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);\n\t}\n};\n/**\n* Error thrown when a connector is not found for a provider\n*/\nvar ConnectorNotFoundError = class extends RouterError {\n\tconstructor(providerId) {\n\t\tsuper(`Connector not found for provider: ${providerId}`, \"CONNECTOR_NOT_FOUND\");\n\t\tthis.providerId = providerId;\n\t\tthis.name = \"ConnectorNotFoundError\";\n\t}\n};\n/**\n* Error thrown when a provider is not configured\n*/\nvar ProviderNotConfiguredError = class extends RouterError {\n\tconstructor(providerId) {\n\t\tsuper(`Provider '${providerId}' is not configured`, \"PROVIDER_NOT_CONFIGURED\");\n\t\tthis.providerId = providerId;\n\t\tthis.name = \"ProviderNotConfiguredError\";\n\t}\n};\n/**\n* Error thrown when request validation fails\n*/\nvar ValidationError = class extends RouterError {\n\tconstructor(message, field) {\n\t\tsuper(message, \"VALIDATION_ERROR\");\n\t\tthis.field = field;\n\t\tthis.name = \"ValidationError\";\n\t}\n};\n/**\n* Error thrown when a connector operation fails\n*/\nvar ConnectorError = class extends RouterError {\n\tconstructor(message, providerId, originalError) {\n\t\tsuper(message, \"CONNECTOR_ERROR\");\n\t\tthis.providerId = providerId;\n\t\tthis.originalError = originalError;\n\t\tthis.name = \"ConnectorError\";\n\t\tif (originalError?.stack) this.stack = `${this.stack}\\nCaused by: ${originalError.stack}`;\n\t}\n};\n/**\n* Error thrown when a model is not supported\n*/\nvar ModelNotSupportedError = class extends RouterError {\n\tconstructor(modelId, providerId) {\n\t\tsuper(`Model '${modelId}' is not supported by provider '${providerId}'`, \"MODEL_NOT_SUPPORTED\");\n\t\tthis.modelId = modelId;\n\t\tthis.providerId = providerId;\n\t\tthis.name = \"ModelNotSupportedError\";\n\t}\n};\n/**\n* Error thrown when a timeout occurs\n*/\nvar TimeoutError = class extends RouterError {\n\tconstructor(operation, timeoutMs) {\n\t\tsuper(`Operation '${operation}' timed out after ${timeoutMs}ms`, \"TIMEOUT\");\n\t\tthis.operation = operation;\n\t\tthis.timeoutMs = timeoutMs;\n\t\tthis.name = \"TimeoutError\";\n\t}\n};\n/**\n* Error thrown when max retries are exceeded\n*/\nvar MaxRetriesExceededError = class extends RouterError {\n\tconstructor(providerId, operation, maxRetries, originalError) {\n\t\tsuper(`Max retries (${maxRetries}) exceeded for ${operation} on provider ${providerId}: ${originalError.message}`, \"MAX_RETRIES_EXCEEDED\");\n\t\tthis.providerId = providerId;\n\t\tthis.operation = operation;\n\t\tthis.maxRetries = maxRetries;\n\t\tthis.originalError = originalError;\n\t\tthis.name = \"MaxRetriesExceededError\";\n\t\tif (originalError?.stack) this.stack = `${this.stack}\\nCaused by: ${originalError.stack}`;\n\t}\n};\n\n//#endregion\n//#region src/error-handler.ts\n/**\n* ErrorHandler manages retry logic with exponential backoff\n*/\nvar ErrorHandler = class {\n\tconfig;\n\tconstructor(config) {\n\t\tthis.config = {\n\t\t\tmaxRetries: config.maxRetries,\n\t\t\tbackoffType: config.backoffType,\n\t\t\tbaseDelay: config.baseDelay,\n\t\t\tmaxDelay: config.maxDelay ?? 3e4,\n\t\t\tjitter: config.jitter ?? true\n\t\t};\n\t}\n\t/**\n\t* Check if an error is retryable\n\t*/\n\tisRetryable(error) {\n\t\tconst status = error.status || error.statusCode;\n\t\tif (status !== void 0) {\n\t\t\tif (status === 429 || status >= 500 && status < 600) return true;\n\t\t\tif (status >= 400 && status < 500) return false;\n\t\t}\n\t\tconst code = error.code;\n\t\tif (code) {\n\t\t\tif ([\n\t\t\t\t\"ECONNRESET\",\n\t\t\t\t\"ECONNREFUSED\",\n\t\t\t\t\"ETIMEDOUT\",\n\t\t\t\t\"ENOTFOUND\",\n\t\t\t\t\"ENETUNREACH\",\n\t\t\t\t\"EAI_AGAIN\"\n\t\t\t].includes(code)) return true;\n\t\t}\n\t\tif (error.name === \"TimeoutError\" || error.message.includes(\"timeout\")) return true;\n\t\treturn false;\n\t}\n\t/**\n\t* Calculate delay for retry attempt with backoff\n\t*/\n\tcalculateDelay(attempt) {\n\t\tlet delay;\n\t\tif (this.config.backoffType === \"exponential\") delay = this.config.baseDelay * Math.pow(2, attempt);\n\t\telse delay = this.config.baseDelay * (attempt + 1);\n\t\tdelay = Math.min(delay, this.config.maxDelay);\n\t\tif (this.config.jitter) delay += Math.random() * 500;\n\t\treturn Math.floor(delay);\n\t}\n\t/**\n\t* Decide whether to retry based on context\n\t*/\n\tshouldRetry(context) {\n\t\tif (context.attempt >= this.config.maxRetries) return {\n\t\t\tshouldRetry: false,\n\t\t\treason: `Max retries (${this.config.maxRetries}) exceeded`\n\t\t};\n\t\tif (!this.isRetryable(context.error)) return {\n\t\t\tshouldRetry: false,\n\t\t\treason: `Error is not retryable: ${context.error.message}`\n\t\t};\n\t\tconst delay = this.calculateDelay(context.attempt);\n\t\treturn {\n\t\t\tshouldRetry: true,\n\t\t\tdelay,\n\t\t\tnextAttempt: context.attempt + 1,\n\t\t\treason: `Error is retryable, will retry after ${delay}ms`\n\t\t};\n\t}\n\t/**\n\t* Execute an operation with automatic retry logic\n\t*/\n\tasync executeWithRetry(operation, context) {\n\t\tlet attempt = 0;\n\t\twhile (true) try {\n\t\t\treturn await operation();\n\t\t} catch (error) {\n\t\t\tconst errorContext = {\n\t\t\t\t...context,\n\t\t\t\terror,\n\t\t\t\tattempt\n\t\t\t};\n\t\t\tconst decision = this.shouldRetry(errorContext);\n\t\t\tif (!decision.shouldRetry) {\n\t\t\t\tif (errorContext.attempt >= this.config.maxRetries) throw new MaxRetriesExceededError(context.providerId, context.operation, this.config.maxRetries, error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tif (decision.delay) await this.sleep(decision.delay);\n\t\t\tattempt = decision.nextAttempt;\n\t\t}\n\t}\n\t/**\n\t* Get current retry configuration\n\t*/\n\tgetRetryConfig() {\n\t\treturn { ...this.config };\n\t}\n\t/**\n\t* Sleep for specified milliseconds\n\t*/\n\tsleep(ms) {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n};\n/**\n* Create a default ErrorHandler instance\n*/\nfunction createErrorHandler(config) {\n\treturn new ErrorHandler({\n\t\tmaxRetries: config?.maxRetries ?? 3,\n\t\tbackoffType: config?.backoffType ?? \"exponential\",\n\t\tbaseDelay: config?.baseDelay ?? 1e3,\n\t\tmaxDelay: config?.maxDelay,\n\t\tjitter: config?.jitter\n\t});\n}\n\n//#endregion\n//#region src/lib/router.ts\nvar GenAIRouter = class {\n\tconfig;\n\tregistry;\n\terrorHandler;\n\tconstructor(config) {\n\t\tthis.config = config;\n\t\tthis.registry = new ConnectorRegistry();\n\t\tthis.errorHandler = createErrorHandler({\n\t\t\tmaxRetries: config.maxRetries ?? 3,\n\t\t\tbackoffType: \"exponential\",\n\t\t\tbaseDelay: 1e3,\n\t\t\tjitter: true\n\t\t});\n\t}\n\tasync chatCompletion(request) {\n\t\tconst { config: normalizedConfig, type } = this.normalizeProviderConfig(request.provider);\n\t\tconst connector = this.getConnector(type, normalizedConfig);\n\t\tconst baseRequest = {\n\t\t\tmessages: request.messages,\n\t\t\tmodel: request.model,\n\t\t\ttemperature: request.temperature,\n\t\t\tmax_tokens: request.max_tokens,\n\t\t\tuseLegacyCompletionAPI: request.useLegacyCompletionAPI,\n\t\t\tfallbackToChatCompletion: request.fallbackToChatCompletion,\n\t\t\tuseLegacyMaxTokens: request.useLegacyMaxTokens,\n\t\t\ttop_p: request.top_p,\n\t\t\tfrequency_penalty: request.frequency_penalty,\n\t\t\tpresence_penalty: request.presence_penalty,\n\t\t\treasoning: request.reasoning,\n\t\t\textra_body: request.extra_body,\n\t\t\ttools: request.tools,\n\t\t\ttool_executor: request.tool_executor\n\t\t};\n\t\tconst response = await this.errorHandler.executeWithRetry(() => connector.chatCompletion(baseRequest), {\n\t\t\tproviderId: request.provider,\n\t\t\toperation: \"chatCompletion\",\n\t\t\tmetadata: { model: request.model }\n\t\t});\n\t\treturn {\n\t\t\tid: response.id,\n\t\t\tobject: response.object,\n\t\t\tcreated: response.created,\n\t\t\tmodel: response.model,\n\t\t\tprovider: connector.getProviderId(),\n\t\t\tchoices: response.choices.map((choice) => ({\n\t\t\t\tindex: choice.index,\n\t\t\t\tmessage: {\n\t\t\t\t\trole: choice.message.role,\n\t\t\t\t\tcontent: choice.message.content,\n\t\t\t\t\t...choice.message.tool_calls && { tool_calls: choice.message.tool_calls }\n\t\t\t\t},\n\t\t\t\tfinish_reason: choice.finish_reason\n\t\t\t})),\n\t\t\tusage: {\n\t\t\t\tprompt_tokens: response.usage.prompt_tokens,\n\t\t\t\tcompletion_tokens: response.usage.completion_tokens,\n\t\t\t\ttotal_tokens: response.usage.total_tokens\n\t\t\t}\n\t\t};\n\t}\n\tasync response(request) {\n\t\tconst { config: normalizedConfig, type } = this.normalizeProviderConfig(request.provider);\n\t\tconst connector = this.getConnector(type, normalizedConfig);\n\t\treturn {\n\t\t\t...await this.errorHandler.executeWithRetry(() => connector.response(request), {\n\t\t\t\tproviderId: request.provider,\n\t\t\t\toperation: \"response\",\n\t\t\t\tmetadata: { model: request.model }\n\t\t\t}),\n\t\t\tprovider: connector.getProviderId()\n\t\t};\n\t}\n\tasync listModels(provider) {\n\t\tconst { config: normalizedConfig, type } = this.normalizeProviderConfig(provider);\n\t\tconst connector = this.getConnector(type, normalizedConfig);\n\t\treturn await this.errorHandler.executeWithRetry(() => connector.listModels(), {\n\t\t\tproviderId: provider,\n\t\t\toperation: \"listModels\"\n\t\t});\n\t}\n\tnormalizeProviderConfig(provider) {\n\t\tif (!this.config.providers?.[provider]) throw new Error(`Provider '${provider}' not configured`);\n\t\tconst providerConfig = this.config.providers[provider];\n\t\treturn {\n\t\t\tconfig: {\n\t\t\t\tbaseURL: providerConfig.api.url,\n\t\t\t\tapiKey: providerConfig.api.token,\n\t\t\t\theaders: providerConfig.api.headers,\n\t\t\t\ttimeout: providerConfig.timeout || this.config.timeout,\n\t\t\t\tmaxRetries: providerConfig.maxRetries || this.config.maxRetries\n\t\t\t},\n\t\t\ttype: providerConfig.type\n\t\t};\n\t}\n\tgetConnector(providerId, config) {\n\t\tif (!this.registry.hasConnector(providerId)) throw new Error(`No connector registered for provider: ${providerId}`);\n\t\treturn this.registry.getConnector(providerId, config);\n\t}\n\tregisterConnector(factory) {\n\t\tthis.registry.registerConnector(factory);\n\t}\n\tgetAvailableProviders() {\n\t\treturn this.registry.getAvailableProviders();\n\t}\n\thasProvider(providerId) {\n\t\treturn this.registry.hasConnector(providerId);\n\t}\n};\nfunction createRouter(config = {}) {\n\treturn new GenAIRouter(config);\n}\nfunction createGateway(config = {}) {\n\treturn new GenAIRouter(config);\n}\nvar router_default = GenAIRouter;\n\n//#endregion\n//#region src/connectors/base/index.ts\nvar NoOpLogger = class {\n\tdebug() {}\n\tinfo() {}\n\twarn() {}\n\terror() {}\n};\nvar BaseConnector = class {\n\tconfig;\n\tuserConfig;\n\tlogger;\n\tproviderId;\n\tstatic packageName;\n\tconstructor(providerId, config = {}) {\n\t\tthis.providerId = providerId;\n\t\tthis.userConfig = { ...config };\n\t\tthis.config = {\n\t\t\ttimeout: 3e4,\n\t\t\tmaxRetries: 3,\n\t\t\t...config\n\t\t};\n\t\tthis.logger = config.logger || new NoOpLogger();\n\t}\n\tgetUserConfig() {\n\t\treturn { ...this.userConfig };\n\t}\n\tgetEffectiveConfig() {\n\t\treturn { ...this.config };\n\t}\n\tvalidateRequest(request) {\n\t\tconst validated = { ...request };\n\t\tif (validated.temperature !== void 0) validated.temperature = Math.max(0, Math.min(2, validated.temperature));\n\t\tif (validated.top_p !== void 0) validated.top_p = Math.max(0, Math.min(1, validated.top_p));\n\t\tif (validated.frequency_penalty !== void 0) validated.frequency_penalty = Math.max(-2, Math.min(2, validated.frequency_penalty));\n\t\tif (validated.presence_penalty !== void 0) validated.presence_penalty = Math.max(-2, Math.min(2, validated.presence_penalty));\n\t\treturn validated;\n\t}\n\tisInitialized() {\n\t\treturn true;\n\t}\n\tgetProviderId() {\n\t\treturn this.providerId;\n\t}\n\tgetConfig() {\n\t\treturn { ...this.config };\n\t}\n\thandleError(error, operation) {\n\t\tif (error instanceof Error) throw new Error(`${this.providerId} ${operation} failed: ${error.message}`);\n\t\tthrow new Error(`${this.providerId} ${operation} failed: Unknown error`);\n\t}\n\tsleep(ms) {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n};\n\n//#endregion\n//#region src/config.ts\n/**\n* Helper function to define a router configuration with full TypeScript support\n*/\nfunction defineConfig(config) {\n\treturn config;\n}\n\n//#endregion\nexport { BaseConnector, ConnectorError, ConnectorNotFoundError, ConnectorRegistry, ErrorHandler, router_default as GenAIGateway, router_default as GenAIRouter, MaxRetriesExceededError, ModelNotSupportedError, ProviderNotConfiguredError, RouterError, TimeoutError, ValidationError, createErrorHandler, createGateway, createRouter, router_default as default, defineConfig };\n//# sourceMappingURL=index.js.map","import { query, tool } from '@anthropic-ai/claude-agent-sdk';\nimport type { Options, SDKMessage } from '@anthropic-ai/claude-agent-sdk';\nimport Anthropic from '@anthropic-ai/sdk';\nimport {\n  BaseConnector,\n  type ConnectorConfig,\n  type ModelInfo,\n  type BaseChatCompletionRequest,\n  type BaseChatCompletionResponse,\n  type ConnectorFactory,\n  type ResponseRequest,\n  type ResponseResponse,\n} from '@anygpt/router';\n\n/**\n * Configuration for Claude Agent SDK connector\n */\nexport interface ClaudeAgentConnectorConfig extends ConnectorConfig {\n  apiKey?: string;\n  baseURL?: string;\n  model?: string;\n  maxTokens?: number;\n  temperature?: number;\n  systemPrompt?: string;\n  mcpServers?: Record<string, unknown>;\n  permissions?: Record<string, string>;\n}\n\n/**\n * Connector for Claude Agent SDK\n * Provides agentic capabilities with built-in tool support\n */\nexport class ClaudeAgentConnector extends BaseConnector {\n  static override readonly packageName = '@anygpt/claude-agent';\n  protected override config: ClaudeAgentConnectorConfig;\n  private client: Anthropic;\n\n  constructor(config: ClaudeAgentConnectorConfig = {}) {\n    super('claude-agent', config);\n    this.config = config;\n    \n    // Initialize Anthropic client for model listing\n    this.client = new Anthropic({\n      apiKey: config.apiKey || process.env['ANTHROPIC_API_KEY'] || '',\n      baseURL: config.baseURL || process.env['ANTHROPIC_BASE_URL'],\n    });\n  }\n\n  /**\n   * List available models from Anthropic API\n   */\n  override async listModels(): Promise<ModelInfo[]> {\n    try {\n      this.logger.debug('[Claude Agent] Fetching models from API...');\n      \n      // Fetch models from Anthropic API\n      const response = await this.client.models.list();\n      \n      this.logger.debug('[Claude Agent] Models fetched:', {\n        count: response.data.length,\n      });\n\n      // Convert to ModelInfo format\n      return response.data.map((model) => ({\n        id: model.id,\n        provider: this.providerId,\n        display_name: model.display_name || model.id,\n        capabilities: {\n          input: { text: true },\n          output: { \n            text: true, \n            function_calling: true, \n            streaming: false,\n          },\n        },\n      }));\n    } catch (error) {\n      // If API call fails, return default models\n      this.logger.debug(\n        `[${this.providerId}] Failed to fetch models from API: ${\n          error instanceof Error ? error.message : String(error)\n        }. Will use default models.`\n      );\n      \n      return [\n        {\n          id: 'claude-sonnet-4',\n          provider: this.providerId,\n          display_name: 'Claude Sonnet 4',\n          capabilities: {\n            input: { text: true },\n            output: { text: true, function_calling: true, streaming: false },\n          },\n        },\n        {\n          id: 'claude-opus-4',\n          provider: this.providerId,\n          display_name: 'Claude Opus 4',\n          capabilities: {\n            input: { text: true },\n            output: { text: true, function_calling: true, streaming: false },\n          },\n        },\n      ];\n    }\n  }\n\n  /**\n   * Response method (not supported by Agent SDK)\n   */\n  override async response(\n    _request: ResponseRequest\n  ): Promise<ResponseResponse> {\n    throw new Error('Response method not supported by Claude Agent SDK. Use chatCompletion instead.');\n  }\n\n  /**\n   * Chat completion using Claude Agent SDK\n   * Converts OpenAI-style messages to Agent SDK format\n   */\n  override async chatCompletion(\n    request: BaseChatCompletionRequest\n  ): Promise<BaseChatCompletionResponse> {\n    const { messages, model, max_tokens, temperature } = request;\n\n    // Build prompt from messages\n    // Agent SDK expects a string prompt or async iterable of user messages\n    const prompt = messages\n      .map((msg) => {\n        if (msg.role === 'system') {\n          return `System: ${msg.content}`;\n        } else if (msg.role === 'user') {\n          return `User: ${msg.content}`;\n        } else {\n          return `Assistant: ${msg.content}`;\n        }\n      })\n      .join('\\n\\n');\n\n    // Configure Agent SDK options\n    const options: Options = {\n      apiKey: this.config.apiKey || process.env['ANTHROPIC_API_KEY'],\n      model: model || this.config.model || 'claude-sonnet-4',\n      max_tokens: max_tokens || this.config.maxTokens || 4096,\n      temperature: temperature ?? this.config.temperature,\n      system_prompt: this.config.systemPrompt,\n      mcp_servers: this.config.mcpServers as any,\n      permissions: this.config.permissions as any,\n      // Pass baseURL and apiKey via environment variables (SDK spawns CLI process)\n      env: {\n        ...process.env,\n        ...(this.config.baseURL && { ANTHROPIC_BASE_URL: this.config.baseURL }),\n        ...(this.config.apiKey && { ANTHROPIC_API_KEY: this.config.apiKey }),\n      },\n    } as Options;\n\n    this.logger.debug('[Claude Agent] Starting query execution with options:', {\n      model: options.model,\n      maxTokens: max_tokens || this.config.maxTokens,\n      hasMcpServers: !!this.config.mcpServers,\n    });\n\n    // Execute query() for agentic capabilities\n    const queryGenerator = query({ prompt, options });\n    const collectedMessages: SDKMessage[] = [];\n    let finalContent = '';\n\n    try {\n      for await (const message of queryGenerator) {\n        collectedMessages.push(message);\n        \n        // Extract text content from assistant messages\n        if (message.type === 'assistant' && 'content' in message) {\n          const content = message.content;\n          if (Array.isArray(content)) {\n            for (const block of content) {\n              if (block.type === 'text' && 'text' in block) {\n                finalContent += block.text;\n              }\n            }\n          } else if (typeof content === 'string') {\n            finalContent += content;\n          }\n        }\n      }\n    } catch (error) {\n      this.logger.error('[Claude Agent] Tool execution failed:', error);\n      throw error;\n    }\n\n    this.logger.debug('[Claude Agent] Tool execution completed:', {\n      messageCount: collectedMessages.length,\n      contentLength: finalContent.length,\n    });\n\n    // Return in OpenAI ChatCompletionResponse format\n    return {\n      id: `chatcmpl-${Date.now()}`,\n      object: 'chat.completion',\n      created: Math.floor(Date.now() / 1000),\n      model: model || this.config.model || 'claude-sonnet-4',\n      provider: this.providerId,\n      choices: [\n        {\n          index: 0,\n          message: {\n            role: 'assistant',\n            content: finalContent || 'No response generated',\n          },\n          finish_reason: 'stop',\n        },\n      ],\n      usage: {\n        prompt_tokens: 0, // Agent SDK doesn't expose token counts\n        completion_tokens: 0,\n        total_tokens: 0,\n      },\n    };\n  }\n}\n\n/**\n * Factory for creating Claude Agent connectors\n */\nexport class ClaudeAgentConnectorFactory implements ConnectorFactory {\n  getProviderId(): string {\n    return 'claude-agent';\n  }\n\n  create(config: ConnectorConfig): ClaudeAgentConnector {\n    return new ClaudeAgentConnector(config as ClaudeAgentConnectorConfig);\n  }\n}\n\nexport default ClaudeAgentConnectorFactory;\n\n/**\n * Factory function for cleaner syntax\n */\nexport function claudeAgent(\n  config: ClaudeAgentConnectorConfig | string = {},\n  providerId?: string\n): ClaudeAgentConnector {\n  // If string is passed, treat it as apiKey\n  const finalConfig = typeof config === 'string' ? { apiKey: config } : config;\n\n  const connector = new ClaudeAgentConnector(finalConfig);\n\n  // Override provider ID if specified\n  if (providerId) {\n    Object.defineProperty(connector, 'providerId', {\n      value: providerId,\n      writable: false,\n      enumerable: true,\n      configurable: false,\n    });\n  }\n\n  return connector;\n}\n"],"mappings":"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"}