{"version":3,"file":"src-KcZw2Fgx.js","names":["fs","fs","conversation","conversationMessages: ConversationMessages","encryptedData: EncryptedData","logLevel: LogLevel","currentCommand: { parent?: unknown; opts?: () => { config?: string } }","fs","conversation","conversation","validConversation: ConversationMetadata","conversation","conversation","createAISummary","displaySummarizationPreview","conversation","conversation","conversation","conversation","chunks: Buffer[]","modelId: string","explicitProvider: string | undefined","messages: Array<{\n          role: 'system' | 'user' | 'assistant';\n          content: string;\n        }>","connectorInfo: { type: string; options?: any }","config: Partial<ConnectorConfig>","models: ModelInfo[]","providerId: string","modelsWithTags: ModelWithMetadata[]","modelsToTest: ModelToTest[]","iterationResults: BenchmarkResult[]","result: BenchmarkResult","results: BenchmarkResult[]","outputDir: string | undefined","chunks: Buffer[]","resolvedServer: string | undefined","matchingTools: Array<{ server: string; tool: string }>","positionalArgs: string[]","options: ExecuteOptions","resolvedServer: string","matchingTools: Array<{ server: string; tool: string }>","args: Record<string, unknown>"],"sources":["../src/utils/encryption.ts","../src/utils/keyManager.ts","../src/utils/conversations.ts","../src/utils/cli-context.ts","../src/commands/conversation/state.ts","../src/commands/conversation/start.ts","../src/commands/conversation/end.ts","../src/commands/conversation/list.ts","../src/commands/conversation/message.ts","../src/commands/conversation/context.ts","../src/utils/config.ts","../src/commands/conversation/condense.ts","../src/commands/conversation/fork.ts","../src/commands/conversation/summarize.ts","../src/commands/conversation/show.ts","../src/commands/conversation/continue.ts","../src/commands/conversation/delete.ts","../src/commands/chat.ts","../src/chat-loop/chat-loop.ts","../src/commands/chat-interactive.ts","../src/commands/config.ts","../src/commands/list-models.ts","../src/commands/list-tags.ts","../src/commands/benchmark/model-selector.ts","../src/commands/benchmark/executor.ts","../src/commands/benchmark/reporter.ts","../src/commands/benchmark/index.ts","../src/commands/mcp/search.ts","../src/commands/mcp/inspect.ts","../src/commands/mcp/execute.ts","../src/commands/mcp/config.ts","../src/index.ts"],"sourcesContent":["import { createCipheriv, createDecipheriv, randomBytes, pbkdf2Sync } from 'crypto';\n\nconst ALGORITHM = 'aes-256-cbc';\nconst KEY_LENGTH = 32;\nconst IV_LENGTH = 16;\nconst SALT_LENGTH = 32;\nconst ITERATIONS = 100000; // PBKDF2 iterations\n\nexport interface EncryptedData {\n  encrypted: string;\n  salt: string;\n  iv: string;\n}\n\n/**\n * Derive encryption key from password using PBKDF2\n */\nfunction deriveKey(password: string, salt: Buffer): Buffer {\n  return pbkdf2Sync(password, salt, ITERATIONS, KEY_LENGTH, 'sha256');\n}\n\n/**\n * Encrypt data using AES-256-CBC with password-derived key\n */\nexport function encrypt(data: string, password: string): EncryptedData {\n  const salt = randomBytes(SALT_LENGTH);\n  const iv = randomBytes(IV_LENGTH);\n  const key = deriveKey(password, salt);\n  \n  const cipher = createCipheriv(ALGORITHM, key, iv);\n  \n  let encrypted = cipher.update(data, 'utf8', 'base64');\n  encrypted += cipher.final('base64');\n  \n  return {\n    encrypted,\n    salt: salt.toString('base64'),\n    iv: iv.toString('base64')\n  };\n}\n\n/**\n * Decrypt data using AES-256-CBC with password-derived key\n */\nexport function decrypt(encryptedData: EncryptedData, password: string): string {\n  const salt = Buffer.from(encryptedData.salt, 'base64');\n  const iv = Buffer.from(encryptedData.iv, 'base64');\n  const key = deriveKey(password, salt);\n  \n  const decipher = createDecipheriv(ALGORITHM, key, iv);\n  \n  let decrypted = decipher.update(encryptedData.encrypted, 'base64', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n\n/**\n * Generate a secure random password for automatic encryption\n */\nexport function generateSecurePassword(): string {\n  return randomBytes(32).toString('base64');\n}\n","import { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { homedir } from 'os';\nimport { generateSecurePassword } from './encryption.js';\n\nconst ANYGPT_DIR = join(homedir(), '.anygpt');\nconst KEY_FILE = join(ANYGPT_DIR, '.encryption-key');\n\n/**\n * Get or create encryption key for conversations\n * Priority: ENV var > stored key file > generate new key\n */\nexport async function getEncryptionKey(): Promise<string> {\n  // 1. Check environment variable first\n  const envKey = process.env.ANYGPT_ENCRYPTION_KEY;\n  if (envKey) {\n    return envKey;\n  }\n\n  // 2. Try to load existing key from file\n  try {\n    const existingKey = await fs.readFile(KEY_FILE, 'utf-8');\n    return existingKey.trim();\n  } catch {\n    // Key file doesn't exist, generate new one\n  }\n\n  // 3. Generate new key and store it securely\n  const newKey = generateSecurePassword();\n  await ensureAnygptDir();\n  \n  // Write key file with restricted permissions\n  await fs.writeFile(KEY_FILE, newKey, { mode: 0o600 });\n  \n  console.log('üîê Generated new encryption key for conversation storage');\n  console.log('üí° Key stored securely in ~/.anygpt/.encryption-key');\n  \n  return newKey;\n}\n\n/**\n * Check if encryption is enabled\n */\nexport function isEncryptionEnabled(): boolean {\n  return process.env.ANYGPT_NO_ENCRYPTION !== 'true';\n}\n\n/**\n * Ensure .anygpt directory exists\n */\nasync function ensureAnygptDir(): Promise<void> {\n  try {\n    await fs.mkdir(ANYGPT_DIR, { recursive: true, mode: 0o700 });\n  } catch {\n    // Directory might already exist\n  }\n}\n\n/**\n * Reset encryption key (for testing or security reset)\n */\nexport async function resetEncryptionKey(): Promise<void> {\n  try {\n    await fs.unlink(KEY_FILE);\n    console.log('üîê Encryption key reset. New key will be generated on next use.');\n  } catch {\n    console.log('üîê No encryption key found to reset.');\n  }\n}\n","import { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { homedir } from 'os';\nimport { encrypt, decrypt, type EncryptedData } from './encryption.js';\nimport { getEncryptionKey, isEncryptionEnabled } from './keyManager.js';\n\nexport interface ConversationMessage {\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  timestamp: string;\n}\n\nexport interface ConversationMetadata {\n  id: string;\n  name: string;\n  provider: string;\n  model: string;\n  lastResponseId: string;\n  createdAt: string;\n  updatedAt: string;\n  messageCount: number;\n  totalTokens: number;\n  inputTokens: number;\n  outputTokens: number;\n}\n\nexport interface ConversationStorage {\n  conversations: Record<string, ConversationMetadata>;\n}\n\nexport interface ConversationMessages {\n  messages: ConversationMessage[];\n}\n\nconst CONVERSATIONS_DIR = join(homedir(), '.anygpt');\nconst CONVERSATIONS_FILE = join(CONVERSATIONS_DIR, 'conversations.json');\n\nfunction getConversationMessagesFile(conversationId: string): string {\n  return join(CONVERSATIONS_DIR, `${conversationId}.messages.json`);\n}\n\n/**\n * Ensure the conversations directory exists\n */\nasync function ensureConversationsDir(): Promise<void> {\n  try {\n    await fs.mkdir(CONVERSATIONS_DIR, { recursive: true });\n  } catch (error) {\n    // Directory might already exist, ignore error\n  }\n}\n\n/**\n * Load conversations from storage\n */\nexport async function loadConversations(): Promise<ConversationStorage> {\n  await ensureConversationsDir();\n  \n  try {\n    const data = await fs.readFile(CONVERSATIONS_FILE, 'utf-8');\n    return JSON.parse(data);\n  } catch (error) {\n    // File doesn't exist or is invalid, return empty storage\n    return { conversations: {} };\n  }\n}\n\n/**\n * Save conversations to storage\n */\nexport async function saveConversations(storage: ConversationStorage): Promise<void> {\n  await ensureConversationsDir();\n  await fs.writeFile(CONVERSATIONS_FILE, JSON.stringify(storage, null, 2));\n}\n\n/**\n * Create a new conversation\n */\nexport async function createConversation(\n  name: string,\n  provider: string,\n  model: string,\n  responseId: string\n): Promise<string> {\n  const storage = await loadConversations();\n  \n  const id = generateConversationId();\n  const now = new Date().toISOString();\n  \n  storage.conversations[id] = {\n    id,\n    name,\n    provider,\n    model,\n    lastResponseId: responseId,\n    createdAt: now,\n    updatedAt: now,\n    messageCount: 0,\n    totalTokens: 0,\n    inputTokens: 0,\n    outputTokens: 0\n  };\n  \n  await saveConversations(storage);\n  return id;\n}\n\n/**\n * Update conversation with new response\n */\nexport async function updateConversation(\n  conversationId: string,\n  responseId: string\n): Promise<void> {\n  const storage = await loadConversations();\n  \n  if (!storage.conversations[conversationId]) {\n    throw new Error(`Conversation ${conversationId} not found`);\n  }\n  \n  storage.conversations[conversationId].lastResponseId = responseId;\n  storage.conversations[conversationId].updatedAt = new Date().toISOString();\n  storage.conversations[conversationId].messageCount++;\n  \n  await saveConversations(storage);\n}\n\n/**\n * Update conversation with token usage\n */\nexport async function updateConversationTokens(\n  conversationId: string,\n  inputTokens: number,\n  outputTokens: number,\n  totalTokens: number\n): Promise<void> {\n  const storage = await loadConversations();\n  \n  if (!storage.conversations[conversationId]) {\n    throw new Error(`Conversation ${conversationId} not found`);\n  }\n  \n  const conversation = storage.conversations[conversationId];\n  conversation.inputTokens += inputTokens;\n  conversation.outputTokens += outputTokens;\n  conversation.totalTokens += totalTokens;\n  conversation.updatedAt = new Date().toISOString();\n  \n  await saveConversations(storage);\n}\n\n/**\n * Replace all messages in a conversation\n */\nexport async function replaceConversationMessages(\n  conversationId: string,\n  newMessages: ConversationMessage[]\n): Promise<void> {\n  await ensureConversationsDir();\n  \n  const messagesFile = getConversationMessagesFile(conversationId);\n  const conversationMessages: ConversationMessages = { messages: newMessages };\n  \n  const dataToWrite = JSON.stringify(conversationMessages, null, 2);\n  \n  if (isEncryptionEnabled()) {\n    const key = await getEncryptionKey();\n    const encryptedData = encrypt(dataToWrite, key);\n    await fs.writeFile(messagesFile, JSON.stringify(encryptedData, null, 2), { mode: 0o600 });\n  } else {\n    await fs.writeFile(messagesFile, dataToWrite, { mode: 0o600 });\n  }\n}\n\n/**\n * Get conversation by ID\n */\nexport async function getConversation(conversationId: string): Promise<ConversationMetadata | null> {\n  const storage = await loadConversations();\n  return storage.conversations[conversationId] || null;\n}\n\n/**\n * List all conversations\n */\nexport async function listConversations(): Promise<ConversationMetadata[]> {\n  const storage = await loadConversations();\n  return Object.values(storage.conversations)\n    .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());\n}\n\n/**\n * Delete a conversation\n */\nexport async function deleteConversation(conversationId: string): Promise<void> {\n  const storage = await loadConversations();\n  \n  if (!storage.conversations[conversationId]) {\n    throw new Error(`Conversation ${conversationId} not found`);\n  }\n  \n  delete storage.conversations[conversationId];\n  await saveConversations(storage);\n}\n\n/**\n * Generate a unique conversation ID\n */\nfunction generateConversationId(): string {\n  return `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Find conversation by name (partial match)\n */\nexport async function findConversationByName(name: string): Promise<ConversationMetadata | null> {\n  const storage = await loadConversations();\n  const conversations = Object.values(storage.conversations);\n  \n  // Try exact match first\n  let found = conversations.find(conv => conv.name.toLowerCase() === name.toLowerCase());\n  \n  // If no exact match, try partial match\n  if (!found) {\n    found = conversations.find(conv => \n      conv.name.toLowerCase().includes(name.toLowerCase())\n    );\n  }\n  \n  return found || null;\n}\n\n/**\n * Add a message to a conversation\n */\nexport async function addMessageToConversation(\n  conversationId: string, \n  role: 'user' | 'assistant' | 'system', \n  content: string\n): Promise<void> {\n  await ensureConversationsDir();\n  \n  const messagesFile = getConversationMessagesFile(conversationId);\n  let conversationMessages: ConversationMessages;\n  \n  try {\n    const fileContent = await fs.readFile(messagesFile, 'utf-8');\n    \n    if (isEncryptionEnabled()) {\n      // Try to decrypt existing file\n      try {\n        const encryptedData: EncryptedData = JSON.parse(fileContent);\n        const key = await getEncryptionKey();\n        const decryptedContent = decrypt(encryptedData, key);\n        conversationMessages = JSON.parse(decryptedContent);\n      } catch {\n        // Might be plain JSON from before encryption was enabled\n        conversationMessages = JSON.parse(fileContent);\n      }\n    } else {\n      conversationMessages = JSON.parse(fileContent);\n    }\n  } catch {\n    // File doesn't exist, create new\n    conversationMessages = { messages: [] };\n  }\n  \n  conversationMessages.messages.push({\n    role,\n    content,\n    timestamp: new Date().toISOString()\n  });\n  \n  const dataToWrite = JSON.stringify(conversationMessages, null, 2);\n  \n  if (isEncryptionEnabled()) {\n    const key = await getEncryptionKey();\n    const encryptedData = encrypt(dataToWrite, key);\n    await fs.writeFile(messagesFile, JSON.stringify(encryptedData, null, 2), { mode: 0o600 });\n  } else {\n    await fs.writeFile(messagesFile, dataToWrite, { mode: 0o600 });\n  }\n}\n\n/**\n * Get all messages from a conversation\n */\nexport async function getConversationMessages(conversationId: string): Promise<ConversationMessage[]> {\n  const messagesFile = getConversationMessagesFile(conversationId);\n  \n  try {\n    const fileContent = await fs.readFile(messagesFile, 'utf-8');\n    let conversationMessages: ConversationMessages;\n    \n    if (isEncryptionEnabled()) {\n      // Try to decrypt existing file\n      try {\n        const encryptedData: EncryptedData = JSON.parse(fileContent);\n        const key = await getEncryptionKey();\n        const decryptedContent = decrypt(encryptedData, key);\n        conversationMessages = JSON.parse(decryptedContent);\n      } catch {\n        // Might be plain JSON from before encryption was enabled\n        conversationMessages = JSON.parse(fileContent);\n      }\n    } else {\n      conversationMessages = JSON.parse(fileContent);\n    }\n    \n    return conversationMessages.messages;\n  } catch {\n    // File doesn't exist, return empty array\n    return [];\n  }\n}\n\n/**\n * Clear all messages from a conversation\n */\nexport async function clearConversationMessages(conversationId: string): Promise<void> {\n  const messagesFile = getConversationMessagesFile(conversationId);\n  \n  try {\n    await fs.unlink(messagesFile);\n  } catch {\n    // File might not exist, ignore error\n  }\n}\n","/**\n * Shared CLI context utilities\n */\n\nimport {\n  setupRouter,\n  setupRouterFromFactory,\n  resolveConfig,\n} from '@anygpt/config';\nimport type { Logger } from '@anygpt/types';\n\ntype LogLevel = 'quiet' | 'info' | 'debug';\n\n// Console logger implementation for CLI\nclass ConsoleLogger implements Logger {\n  constructor(private logLevel: LogLevel = 'quiet') {}\n\n  // Parse log level from environment and command line args\n  private getLogLevel(): LogLevel {\n    // Check environment variable first\n    if (process.env.VERBOSE === 'debug') return 'debug';\n    if (process.env.VERBOSE === 'true') return 'info';\n\n    // Check command line arguments\n    const verboseIndex = process.argv.findIndex(\n      (arg) => arg === '--verbose' || arg === '-v'\n    );\n\n    if (verboseIndex !== -1) {\n      // Check if next arg is a level value\n      const nextArg = process.argv[verboseIndex + 1];\n      if (nextArg === 'debug') return 'debug';\n      return 'info'; // Default verbose level\n    }\n\n    return this.logLevel;\n  }\n\n  debug(message: string, ...args: unknown[]): void {\n    if (this.getLogLevel() === 'debug') {\n      console.log('[DEBUG]', message, ...args);\n    }\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    const level = this.getLogLevel();\n    if (level === 'info' || level === 'debug') {\n      console.log(message, ...args);\n    }\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    console.warn(message, ...args);\n  }\n\n  error(message: string, ...args: unknown[]): void {\n    console.error(message, ...args);\n  }\n}\n\n// Console logger for CLI\nconst consoleLogger = new ConsoleLogger();\n\nimport type { ModelAlias, ProviderConfig, ModelRule } from '@anygpt/config';\nimport { buildTagRegistry, type TagRegistry } from '@anygpt/config';\n\nexport interface CLIContext {\n  router: unknown;\n  config: unknown;\n  configSource: string; // Path to the loaded config file\n  providers: Record<string, ProviderConfig>; // Provider configs with model metadata\n  tagRegistry?: TagRegistry; // Pre-computed tag mappings\n  logger: Logger;\n  defaults: {\n    provider?: string;\n    model?: string;\n    timeout?: number;\n    maxRetries?: number;\n    logging?: {\n      level?: 'debug' | 'info' | 'warn' | 'error';\n    };\n    providers?: Record<\n      string,\n      {\n        model?: string;\n        [key: string]: unknown;\n      }\n    >;\n    aliases?: Record<string, ModelAlias[]>;\n    modelRules?: ModelRule[];\n  };\n}\n\n/**\n * Global config and router setup - shared by all commands\n */\nexport async function setupCLIContext(\n  configPath?: string\n): Promise<CLIContext> {\n  try {\n    // Try to import the config directly (for factory configs)\n    // Resolve path relative to current working directory, not the CLI dist folder\n    const resolvedConfigPath = configPath || './.anygpt/anygpt.config.ts';\n    const absoluteConfigPath = new URL(\n      resolvedConfigPath,\n      `file://${process.cwd()}/`\n    ).href;\n    const module = await import(absoluteConfigPath);\n    let loadedConfig = module.default;\n\n    // Process plugins to generate mcp and other dynamic config\n    loadedConfig = await resolveConfig(loadedConfig);\n\n    // Check if it's a factory config (has providers with connector instances)\n    // A factory config has actual connector instances (with client property), not config objects\n    const hasConnectorInstances =\n      loadedConfig.providers &&\n      Object.values(loadedConfig.providers).some(\n        (p: unknown): p is { connector: { client: unknown } } =>\n          typeof p === 'object' &&\n          p !== null &&\n          'connector' in p &&\n          typeof p.connector === 'object' &&\n          p.connector !== null &&\n          'client' in p.connector\n      );\n\n    if (hasConnectorInstances) {\n      // It's a factory config - we already have the resolved config with plugins processed\n      // Now we just need to create the router and register connectors\n      const { router, config } = await setupRouterFromFactory(\n        loadedConfig,\n        consoleLogger\n      );\n\n      // Build tag registry (async, fetches models from providers)\n      consoleLogger.debug('Building tag registry...');\n      const tagRegistry = await buildTagRegistry(\n        config.providers || {},\n        config.defaults?.modelRules\n      );\n      consoleLogger.debug(\n        `Tag registry built with ${tagRegistry.tags.size} tags`\n      );\n\n      return {\n        router,\n        config: loadedConfig, // Use the resolved config with mcp from plugins\n        configSource: resolvedConfigPath,\n        providers: config.providers || {},\n        tagRegistry,\n        logger: consoleLogger,\n        defaults: {\n          provider: config.defaults?.provider,\n          model: config.defaults?.model,\n          timeout: config.defaults?.timeout,\n          maxRetries: config.defaults?.maxRetries,\n          logging: config.defaults?.logging,\n          providers: config.defaults?.providers,\n          aliases: config.defaults?.aliases,\n          modelRules: config.defaults?.modelRules,\n        },\n      };\n    } else {\n      // It's a standard config - use the resolved config directly\n      // Don't call setupRouter again as it would reload and re-process plugins\n      return {\n        router: null, // Standard configs don't have router\n        config: loadedConfig, // Use the resolved config with mcp from plugins\n        configSource: resolvedConfigPath,\n        providers: {}, // Standard configs don't have provider metadata\n        logger: consoleLogger,\n        defaults: {\n          provider: loadedConfig.settings?.defaultProvider,\n          model: undefined,\n        },\n      };\n    }\n  } catch {\n    // Fall back to standard config loading\n    const { router, config } = await setupRouter({ configPath }, consoleLogger);\n\n    return {\n      router,\n      config, // Return full config including mcp and discovery\n      configSource: configPath || 'fallback config search',\n      providers: {}, // Fallback configs don't have provider metadata\n      logger: consoleLogger,\n      defaults: {\n        provider: config.settings?.defaultProvider,\n        model: undefined, // AnyGPTConfig doesn't have a global default model\n      },\n    };\n  }\n}\n\n/**\n * Wrapper for command actions that need CLI context\n */\nexport function withCLIContext<T extends unknown[]>(\n  commandFn: (context: CLIContext, ...args: T) => Promise<void>\n) {\n  return async (...args: T) => {\n    // Extract global options from commander\n    const command = args[args.length - 1] as {\n      parent?: unknown;\n      opts?: () => { config?: string };\n    };\n\n    // Walk up the command tree to find the root program options\n    let currentCommand: { parent?: unknown; opts?: () => { config?: string } } =\n      command;\n    while (\n      currentCommand.parent &&\n      typeof currentCommand.parent === 'object' &&\n      'opts' in currentCommand.parent\n    ) {\n      currentCommand = currentCommand.parent as {\n        parent?: unknown;\n        opts?: () => { config?: string };\n      };\n    }\n    const globalOpts = currentCommand.opts?.() || {};\n\n    try {\n      const context = await setupCLIContext(globalOpts.config);\n      await commandFn(context, ...args);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  };\n}\n","import { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { homedir } from 'os';\n\nconst STATE_FILE = join(homedir(), '.anygpt', 'current-conversation');\n\nexport async function setCurrentConversation(conversationId: string): Promise<void> {\n  try {\n    await fs.mkdir(join(homedir(), '.anygpt'), { recursive: true });\n    await fs.writeFile(STATE_FILE, conversationId);\n  } catch {\n    console.error('Error setting current conversation');\n  }\n}\n\nexport async function getCurrentConversation(): Promise<string | null> {\n  try {\n    const content = await fs.readFile(STATE_FILE, 'utf-8');\n    return content.trim() || null;\n  } catch {\n    return null;\n  }\n}\n\nexport async function clearCurrentConversation(): Promise<void> {\n  try {\n    await fs.unlink(STATE_FILE);\n  } catch {\n    // File might not exist, ignore error\n  }\n}\n","import { createConversation } from '../../utils/conversations.js';\nimport { setupCLIContext } from '../../utils/cli-context.js';\nimport { setCurrentConversation } from './state.js';\n\ninterface StartOptions {\n  provider?: string;\n  model?: string;\n  name?: string;\n}\n\nexport async function conversationStartCommand(\n  options: StartOptions,\n  configPath?: string\n): Promise<void> {\n  // Use CLI context setup to handle factory configs properly\n  const context = await setupCLIContext(configPath);\n  \n  // Use provided options or fall back to config defaults\n  const provider = options.provider || context.defaults.provider;\n  const model = options.model || context.defaults.model;\n  \n  if (!provider) {\n    throw new Error('No provider specified. Either provide --provider or set defaults.provider in config.');\n  }\n  \n  if (!model) {\n    throw new Error('No model specified. Either provide --model or set defaults.model in config.');\n  }\n  \n  const name = options.name || `${provider}/${model} - ${new Date().toLocaleString()}`;\n  const conversationId = await createConversation(name, provider, model, 'pending');\n  \n  console.log(`üéØ Started new conversation: ${name}`);\n  console.log(`üìù Conversation ID: ${conversationId}`);\n  console.log(`üí° Use 'anygpt conversation message \"your message\"' to chat`);\n  \n  await setCurrentConversation(conversationId);\n}\n","import { getConversation } from '../../utils/conversations.js';\nimport { getCurrentConversation, clearCurrentConversation } from './state.js';\n\nexport async function conversationEndCommand(): Promise<void> {\n  const currentId = await getCurrentConversation();\n  \n  if (!currentId) {\n    console.log('‚ùå No active conversation to end');\n    return;\n  }\n  \n  const conversation = await getConversation(currentId);\n  if (conversation) {\n    console.log(`‚úÖ Ended conversation: ${conversation.name}`);\n    console.log(`üìä Messages: ${conversation.messageCount}`);\n  }\n  \n  await clearCurrentConversation();\n}\n","import { listConversations } from '../../utils/conversations.js';\nimport { getCurrentConversation } from './state.js';\n\nexport async function conversationListCommand(): Promise<void> {\n  const conversations = await listConversations();\n  \n  if (conversations.length === 0) {\n    console.log('üì≠ No conversations found');\n    return;\n  }\n  \n  const currentId = await getCurrentConversation();\n  \n  console.log('üìã Conversations:');\n  console.log('');\n  \n  for (const conv of conversations) {\n    const isActive = conv.id === currentId ? 'üü¢' : '‚ö™';\n    const updatedAt = new Date(conv.updatedAt).toLocaleString();\n    \n    console.log(`${isActive} ${conv.name}`);\n    console.log(`   ID: ${conv.id}`);\n    console.log(`   Provider: ${conv.provider}/${conv.model}`);\n    console.log(`   Messages: ${conv.messageCount}`);\n    console.log(`   Tokens: ${conv.totalTokens || 0} total (${conv.inputTokens || 0} input, ${conv.outputTokens || 0} output)`);\n    console.log(`   Updated: ${updatedAt}`);\n    console.log('');\n  }\n}\n","import { \n  getConversation, \n  findConversationByName, \n  updateConversation,\n  updateConversationTokens,\n  addMessageToConversation,\n  getConversationMessages,\n  createConversation\n} from '../../utils/conversations.js';\nimport { setupCLIContext } from '../../utils/cli-context.js';\nimport { getCurrentConversation, setCurrentConversation } from './state.js';\nimport type { GenAIRouter } from '@anygpt/router';\nimport type { ConversationMetadata } from '../../utils/conversations.js';\n\ninterface MessageOptions {\n  conversation?: string;\n}\n\nexport async function conversationMessageCommand(\n  message: string,\n  options: MessageOptions,\n  configPath?: string\n): Promise<void> {\n  let targetConversationId = options.conversation;\n  \n  // If no conversation specified, use current conversation\n  if (!targetConversationId) {\n    targetConversationId = await getCurrentConversation() || undefined;\n  }\n  \n  // Use CLI context setup to handle factory configs properly\n  const context = await setupCLIContext(configPath);\n  \n  // Check if provider exists (this will work with both factory and regular configs)\n  if (!context.router) {\n    throw new Error('Failed to initialize router');\n  }\n  \n  let conversation;\n  \n  if (!targetConversationId) {\n    // Auto-start a new conversation\n    console.log('üöÄ No active conversation found. Starting a new one...');\n    \n    const provider = context.defaults.provider;\n    const model = context.defaults.model;\n    \n    if (!provider) {\n      throw new Error('No default provider configured. Please configure a default provider or specify --conversation <id>.');\n    }\n    \n    if (!model) {\n      throw new Error('No default model configured. Please configure a default model or specify --conversation <id>.');\n    }\n    \n    const name = `${provider}/${model} - ${new Date().toLocaleString()}`;\n    targetConversationId = await createConversation(name, provider, model, 'pending');\n    \n    console.log(`üéØ Started new conversation: ${name}`);\n    console.log(`üìù Conversation ID: ${targetConversationId}`);\n    \n    await setCurrentConversation(targetConversationId);\n    conversation = await getConversation(targetConversationId);\n  } else {\n    conversation = await getConversation(targetConversationId);\n    \n    // If not found by ID, try to find by name\n    if (!conversation) {\n      conversation = await findConversationByName(targetConversationId);\n    }\n    \n    if (!conversation) {\n      throw new Error(`Conversation '${targetConversationId}' not found`);\n    }\n  }\n  \n  // TypeScript assertion: conversation is guaranteed to be non-null here\n  const validConversation: ConversationMetadata = conversation!;\n  \n  console.log(`üîÑ ${validConversation.name}`);\n  console.log(`üë§ ${message}`);\n  \n  // For now, always use Chat API since that's what the router supports\n  // TODO: Add support for Responses API in the router\n  await handleChatApi(context.router, validConversation, message);\n}\n\n// Note: Responses API support is planned for future implementation\n// Currently using Chat API for all conversation interactions\n\nasync function handleChatApi(router: GenAIRouter, conversation: ConversationMetadata, message: string): Promise<void> {\n  // Get conversation history for context\n  const previousMessages = await getConversationMessages(conversation.id);\n  \n  // Build messages array with full conversation context\n  const messages = [\n    ...previousMessages.map(msg => ({\n      role: msg.role as 'user' | 'assistant' | 'system',\n      content: msg.content\n    })),\n    { role: 'user' as const, content: message }\n  ];\n  \n  // Store the user message\n  await addMessageToConversation(conversation.id, 'user', message);\n  \n  // Use Chat Completions with full conversation context\n  const response = await router.chatCompletion({\n    provider: conversation.provider,\n    model: conversation.model,\n    messages: messages\n  });\n  \n  const assistantMessage = response.choices[0].message.content || '';\n  \n  // Update token tracking\n  await updateConversationTokens(\n    conversation.id,\n    response.usage.prompt_tokens || 0,\n    response.usage.completion_tokens || 0,\n    response.usage.total_tokens\n  );\n  \n  // Get updated conversation for cumulative stats\n  const updatedConversation = await getConversation(conversation.id);\n  \n  console.log(`ü§ñ ${assistantMessage}`);\n  console.log(`üìä Current: ${response.usage.prompt_tokens} input + ${response.usage.completion_tokens} output = ${response.usage.total_tokens} tokens`);\n  console.log(`üìà Total: ${updatedConversation?.inputTokens || 0} input + ${updatedConversation?.outputTokens || 0} output = ${updatedConversation?.totalTokens || 0} tokens`);\n  console.log(`üí¨ Context: ${messages.length} messages (Chat API + local context)`);\n  \n  // Store the assistant response\n  await addMessageToConversation(conversation.id, 'assistant', assistantMessage);\n  \n  // Update conversation metadata\n  await updateConversation(conversation.id, 'chat-with-context');\n}\n","import { getConversation, getConversationMessages } from '../../utils/conversations.js';\nimport { getCurrentConversation } from './state.js';\n\ninterface ContextOptions {\n  conversation?: string;\n}\n\n/**\n * Show detailed context statistics for a conversation\n */\nexport async function conversationContextCommand(\n  options: ContextOptions = {}\n): Promise<void> {\n  let targetConversationId = options.conversation;\n  \n  // If no conversation specified, use current conversation\n  if (!targetConversationId) {\n    targetConversationId = await getCurrentConversation() || undefined;\n  }\n  \n  if (!targetConversationId) {\n    throw new Error('No active conversation. Use --conversation <id> or start a conversation first.');\n  }\n  \n  const conversation = await getConversation(targetConversationId);\n  if (!conversation) {\n    throw new Error(`Conversation ${targetConversationId} not found`);\n  }\n  \n  const messages = await getConversationMessages(targetConversationId);\n  \n  // Calculate context statistics\n  const stats = calculateContextStats(messages, conversation);\n  \n  // Display formatted statistics\n  displayContextStats(conversation, stats);\n}\n\ninterface ContextStats {\n  totalMessages: number;\n  userMessages: number;\n  assistantMessages: number;\n  systemMessages: number;\n  totalCharacters: number;\n  estimatedTokens: number;\n  averageMessageLength: number;\n  longestMessage: number;\n  shortestMessage: number;\n  conversationAge: string;\n  lastActivity: string;\n}\n\nfunction calculateContextStats(messages: any[], conversation: any): ContextStats {\n  const userMessages = messages.filter(m => m.role === 'user');\n  const assistantMessages = messages.filter(m => m.role === 'assistant');\n  const systemMessages = messages.filter(m => m.role === 'system');\n  \n  const totalCharacters = messages.reduce((sum, msg) => sum + msg.content.length, 0);\n  const messageLengths = messages.map(msg => msg.content.length);\n  \n  const createdAt = new Date(conversation.createdAt);\n  const updatedAt = new Date(conversation.updatedAt);\n  const now = new Date();\n  \n  return {\n    totalMessages: messages.length,\n    userMessages: userMessages.length,\n    assistantMessages: assistantMessages.length,\n    systemMessages: systemMessages.length,\n    totalCharacters,\n    estimatedTokens: Math.ceil(totalCharacters / 4), // Rough estimation\n    averageMessageLength: Math.round(totalCharacters / messages.length),\n    longestMessage: Math.max(...messageLengths, 0),\n    shortestMessage: Math.min(...messageLengths, 0),\n    conversationAge: formatDuration(now.getTime() - createdAt.getTime()),\n    lastActivity: formatDuration(now.getTime() - updatedAt.getTime())\n  };\n}\n\nfunction displayContextStats(conversation: any, stats: ContextStats): void {\n  console.log(`üìä Context Statistics for: ${conversation.name}`);\n  console.log(`üÜî ID: ${conversation.id}`);\n  console.log(`ü§ñ Provider: ${conversation.provider}/${conversation.model}`);\n  console.log('');\n  \n  // Message breakdown\n  console.log('üí¨ Messages:');\n  console.log(`   Total: ${stats.totalMessages}`);\n  console.log(`   üë§ User: ${stats.userMessages}`);\n  console.log(`   ü§ñ Assistant: ${stats.assistantMessages}`);\n  if (stats.systemMessages > 0) {\n    console.log(`   ‚öôÔ∏è  System: ${stats.systemMessages}`);\n  }\n  console.log('');\n  \n  // Token and cost information\n  console.log('üéØ Token Usage:');\n  console.log(`   Input tokens: ${conversation.inputTokens || 0}`);\n  console.log(`   Output tokens: ${conversation.outputTokens || 0}`);\n  console.log(`   Total tokens: ${conversation.totalTokens || 0}`);\n  console.log(`   Estimated context: ~${stats.estimatedTokens} tokens`);\n  console.log('');\n  \n  \n  // Content statistics\n  console.log('üìù Content Analysis:');\n  console.log(`   Total characters: ${stats.totalCharacters.toLocaleString()}`);\n  console.log(`   Average message: ${stats.averageMessageLength} characters`);\n  console.log(`   Longest message: ${stats.longestMessage} characters`);\n  console.log(`   Shortest message: ${stats.shortestMessage} characters`);\n  console.log('');\n  \n  // Timing information\n  console.log('‚è∞ Timeline:');\n  console.log(`   Conversation age: ${stats.conversationAge}`);\n  console.log(`   Last activity: ${stats.lastActivity} ago`);\n  console.log(`   Created: ${new Date(conversation.createdAt).toLocaleString()}`);\n  console.log(`   Updated: ${new Date(conversation.updatedAt).toLocaleString()}`);\n  \n  // Context optimization suggestions\n  console.log('');\n  console.log('üí° Optimization Suggestions:');\n  \n  if (stats.estimatedTokens > 8000) {\n    console.log('   ‚ö†Ô∏è  Large context detected - consider using context condensation');\n  }\n  \n  if (stats.totalMessages > 50) {\n    console.log('   üìâ Long conversation - sliding window optimization could reduce costs');\n  }\n  \n  if ((conversation.totalTokens || 0) > 10000) {\n    console.log('   üí∏ High token usage - monitor costs carefully');\n  }\n  \n  if (stats.averageMessageLength > 500) {\n    console.log('   üìè Long messages - consider breaking into smaller interactions');\n  }\n}\n\nfunction formatDuration(ms: number): string {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n  \n  if (days > 0) return `${days} day${days > 1 ? 's' : ''}`;\n  if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''}`;\n  if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''}`;\n  return `${seconds} second${seconds > 1 ? 's' : ''}`;\n}\n","import { existsSync } from 'fs';\nimport { extname } from 'path';\nimport { pathToFileURL } from 'url';\nimport type { RouterConfig } from '@anygpt/router';\n\n// Extensions that Node.js can import as modules\nconst IMPORTABLE_EXTENSIONS = ['.js', '.ts', '.mjs', '.cjs', '.jsx', '.tsx'];\n\nfunction isImportableModule(ext: string): boolean {\n  return IMPORTABLE_EXTENSIONS.includes(ext);\n}\n\nexport async function loadConfig(configPath?: string): Promise<RouterConfig> {\n  if (configPath) {\n    // Use specific path if provided\n    return await loadConfigFromPath(configPath);\n  }\n\n  // No config specified - use default hardcoded config\n  return getDefaultConfig();\n}\n\nasync function loadConfigFromPath(path: string): Promise<RouterConfig> {\n  // First, check if it's a file path\n  if (existsSync(path)) {\n    return await loadConfigFromFilePath(path);\n  }\n\n  // If not a file, try as module path\n  try {\n    const module = await import(path);\n    return module.default || module;\n  } catch {\n    console.error('Error loading config');\n    throw new Error('Failed to load config');\n  }\n}\n\nasync function loadConfigFromFilePath(path: string): Promise<RouterConfig> {\n  const ext = extname(path);\n  if (ext === '.json') {\n    // Use modern JSON import with assertion\n    const fileUrl = pathToFileURL(path).href;\n    const module = await import(fileUrl, { with: { type: 'json' } });\n    return module.default;\n  } else if (isImportableModule(ext) || !ext) {\n    // Dynamic import for any importable module or extensionless files\n    const fileUrl = pathToFileURL(path).href;\n    const module = await import(fileUrl);\n    return module.default || module;\n  }\n\n  throw new Error(`Unsupported config file extension: ${ext}`);\n}\n\nfunction getDefaultConfig(): RouterConfig {\n  // Return default config if no file found\n  return {\n    providers: {\n      openai: {\n        type: 'openai',\n        api: {\n          url: 'https://api.openai.com/v1',\n          token: process.env.OPENAI_API_KEY,\n        },\n      },\n    },\n  };\n}\n","import { GenAIGateway } from '@anygpt/router';\nimport { getConversation, getConversationMessages, updateConversationTokens, replaceConversationMessages } from '../../utils/conversations.js';\nimport { loadConfig } from '../../utils/config.js';\nimport { getCurrentConversation } from './state.js';\n\ninterface CondenseOptions {\n  conversation?: string;\n  keepRecent?: number;\n  dryRun?: boolean;\n}\n\n/**\n * Condense conversation context using AI summarization\n */\nexport async function conversationCondenseCommand(\n  options: CondenseOptions = {}\n): Promise<void> {\n  let targetConversationId = options.conversation;\n  \n  // If no conversation specified, use current conversation\n  if (!targetConversationId) {\n    targetConversationId = await getCurrentConversation() || undefined;\n  }\n  \n  if (!targetConversationId) {\n    throw new Error('No active conversation. Use --conversation <id> or start a conversation first.');\n  }\n  \n  const conversation = await getConversation(targetConversationId);\n  if (!conversation) {\n    throw new Error(`Conversation ${targetConversationId} not found`);\n  }\n  \n  const messages = await getConversationMessages(targetConversationId);\n  \n  if (messages.length < 5) {\n    console.log('‚ö†Ô∏è  Conversation too short to condense (need at least 5 messages)');\n    return;\n  }\n  \n  const keepRecent = options.keepRecent || 3;\n  \n  if (messages.length <= keepRecent + 2) {\n    console.log(`‚ö†Ô∏è  Conversation only has ${messages.length} messages, keeping recent ${keepRecent} would leave too few to summarize`);\n    return;\n  }\n  \n  // Split messages into older (to summarize) and recent (to keep)\n  const messagesToSummarize = messages.slice(0, -keepRecent);\n  const recentMessages = messages.slice(-keepRecent);\n  \n  console.log(`üîÑ Condensing conversation: ${conversation.name}`);\n  console.log(`üìä Summarizing ${messagesToSummarize.length} messages, keeping ${recentMessages.length} recent`);\n  \n  // Calculate current context size\n  const currentTokens = messages.reduce((sum, msg) => sum + Math.ceil(msg.content.length / 4), 0);\n  console.log(`üìè Current estimated context: ~${currentTokens} tokens`);\n  \n  if (options.dryRun) {\n    console.log('üß™ Dry run - showing what would be summarized:');\n    displaySummarizationPreview(messagesToSummarize, recentMessages);\n    return;\n  }\n  \n  // Load config and create gateway\n  const config = await loadConfig() as any;\n  if (!config.providers?.[conversation.provider]) {\n    throw new Error(`Provider '${conversation.provider}' not found in config`);\n  }\n  \n  const gateway = new GenAIGateway(config);\n  \n  // Create summarization prompt\n  const summary = await createAISummary(gateway, conversation, messagesToSummarize);\n  \n  // Calculate token savings\n  const originalTokens = messagesToSummarize.reduce((sum, msg) => sum + Math.ceil(msg.content.length / 4), 0);\n  const summaryTokens = Math.ceil(summary.length / 4);\n  const tokenSavings = originalTokens - summaryTokens;\n  const savingsPercent = Math.round((tokenSavings / originalTokens) * 100);\n  \n  console.log('');\n  console.log('üìã Generated Summary:');\n  console.log('‚îÄ'.repeat(60));\n  console.log(summary);\n  console.log('‚îÄ'.repeat(60));\n  console.log('');\n  console.log(`üíæ Token Optimization:`);\n  console.log(`   Original: ~${originalTokens} tokens`);\n  console.log(`   Summary: ~${summaryTokens} tokens`);\n  console.log(`   Savings: ~${tokenSavings} tokens (${savingsPercent}%)`);\n  console.log('');\n  \n  // Ask for confirmation\n  console.log('‚ö†Ô∏è  This will replace the older messages with the summary.');\n  console.log('   Recent messages will be preserved.');\n  console.log('   This action cannot be undone.');\n  console.log('');\n  console.log('üí° Applying condensation:');\n  console.log(`   1. Replace ${messagesToSummarize.length} older messages with 1 summary`);\n  console.log(`   2. Keep ${recentMessages.length} recent messages unchanged`);\n  console.log(`   3. Update conversation metadata`);\n  console.log('');\n  \n  // Create new message array with summary + recent messages\n  const summaryMessage = {\n    role: 'system' as const,\n    content: `[CONVERSATION SUMMARY]: ${summary}`,\n    timestamp: new Date().toISOString()\n  };\n  \n  const newMessages = [\n    summaryMessage,\n    ...recentMessages\n  ];\n  \n  // Replace messages in the conversation\n  await replaceConversationMessages(conversation.id, newMessages);\n  \n  console.log('‚úÖ Conversation condensed successfully!');\n  console.log(`üìä Messages: ${messages.length} ‚Üí ${newMessages.length}`);\n  console.log(`üíæ Token savings: ~${tokenSavings} tokens (${savingsPercent}%)`);\n  console.log('');\n  console.log('üéØ Your current conversation now has optimized context');\n  console.log('üí¨ Continue chatting with reduced token costs');\n}\n\nasync function createAISummary(\n  gateway: any, \n  conversation: any, \n  messages: any[]\n): Promise<string> {\n  const conversationText = messages\n    .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)\n    .join('\\n\\n');\n  \n  const summarizationPrompt = `Please create a concise summary of this conversation that preserves the key information, context, and important details. The summary should be much shorter than the original but retain all essential information that might be needed for future conversation context.\n\nConversation to summarize:\n${conversationText}\n\nPlease provide a clear, structured summary that captures:\n1. Key topics discussed\n2. Important information shared (names, preferences, etc.)\n3. Main questions asked and answers provided\n4. Any ongoing context that should be preserved\n\nSummary:`;\n\n  console.log('ü§ñ Generating AI summary...');\n  \n  const response = await gateway.chatCompletion({\n    provider: conversation.provider,\n    model: conversation.model,\n    messages: [{ role: 'user', content: summarizationPrompt }]\n  });\n  \n  // Track tokens used for summarization\n  await updateConversationTokens(\n    conversation.id,\n    response.usage.prompt_tokens || 0,\n    response.usage.completion_tokens || 0,\n    response.usage.total_tokens\n  );\n  \n  console.log(`üìä Summarization cost: ${response.usage.prompt_tokens} input + ${response.usage.completion_tokens} output = ${response.usage.total_tokens} tokens`);\n  \n  return response.choices[0].message.content || 'Summary generation failed';\n}\n\nfunction displaySummarizationPreview(messagesToSummarize: any[], recentMessages: any[]): void {\n  console.log('');\n  console.log('üìù Messages to be summarized:');\n  messagesToSummarize.forEach((msg, i) => {\n    const preview = msg.content.length > 100 ? msg.content.substring(0, 100) + '...' : msg.content;\n    console.log(`   ${i + 1}. [${msg.role}] ${preview}`);\n  });\n  \n  console.log('');\n  console.log('‚úÖ Messages to be kept (recent):');\n  recentMessages.forEach((msg, i) => {\n    const preview = msg.content.length > 100 ? msg.content.substring(0, 100) + '...' : msg.content;\n    console.log(`   ${i + 1}. [${msg.role}] ${preview}`);\n  });\n}\n","import { getConversation, getConversationMessages, createConversation, addMessageToConversation } from '../../utils/conversations.js';\nimport { getCurrentConversation, setCurrentConversation } from './state.js';\n\ninterface ForkOptions {\n  conversation?: string;\n  model?: string;\n  provider?: string;\n  name?: string;\n}\n\n/**\n * Fork a conversation - create a new conversation with the same history\n */\nexport async function conversationForkCommand(\n  options: ForkOptions = {}\n): Promise<void> {\n  let sourceConversationId = options.conversation;\n  \n  // If no conversation specified, use current conversation\n  if (!sourceConversationId) {\n    sourceConversationId = await getCurrentConversation() || undefined;\n  }\n  \n  if (!sourceConversationId) {\n    throw new Error('No active conversation. Use --conversation <id> or start a conversation first.');\n  }\n  \n  const sourceConversation = await getConversation(sourceConversationId);\n  if (!sourceConversation) {\n    throw new Error(`Conversation ${sourceConversationId} not found`);\n  }\n  \n  const messages = await getConversationMessages(sourceConversationId);\n  \n  // Determine new conversation parameters\n  const newProvider = options.provider || sourceConversation.provider;\n  const newModel = options.model || sourceConversation.model;\n  const newName = options.name || `${sourceConversation.name} (Fork)`;\n  \n  console.log(`üîÄ Forking conversation: ${sourceConversation.name}`);\n  console.log(`üìä Copying ${messages.length} messages`);\n  console.log(`ü§ñ Target: ${newProvider}/${newModel}`);\n  \n  // Create new conversation\n  const newConversationId = await createConversation(\n    newName,\n    newProvider,\n    newModel,\n    'forked'\n  );\n  \n  // Copy all messages\n  for (const message of messages) {\n    await addMessageToConversation(\n      newConversationId, \n      message.role as 'user' | 'assistant' | 'system', \n      message.content\n    );\n  }\n  \n  // Switch to new conversation\n  await setCurrentConversation(newConversationId);\n  \n  console.log('');\n  console.log(`‚úÖ Fork created successfully!`);\n  console.log(`üÜî New conversation ID: ${newConversationId}`);\n  console.log(`üéØ Now active: ${newName}`);\n  console.log('');\n  console.log('üí° Use cases:');\n  console.log('   ‚Ä¢ Test different models with same context');\n  console.log('   ‚Ä¢ Experiment with different conversation paths');\n  console.log('   ‚Ä¢ Create backups before major changes');\n}\n","import { GenAIGateway } from '@anygpt/router';\nimport { getConversation, getConversationMessages, createConversation, addMessageToConversation } from '../../utils/conversations.js';\nimport { loadConfig } from '../../utils/config.js';\nimport { getCurrentConversation, setCurrentConversation } from './state.js';\n\ninterface SummarizeOptions {\n  conversation?: string;\n  keepRecent?: number;\n  model?: string;\n  provider?: string;\n  name?: string;\n  dryRun?: boolean;\n}\n\n/**\n * Create a new conversation with AI-generated summary of older messages\n */\nexport async function conversationSummarizeCommand(\n  options: SummarizeOptions = {}\n): Promise<void> {\n  let sourceConversationId = options.conversation;\n  \n  // If no conversation specified, use current conversation\n  if (!sourceConversationId) {\n    sourceConversationId = await getCurrentConversation() || undefined;\n  }\n  \n  if (!sourceConversationId) {\n    throw new Error('No active conversation. Use --conversation <id> or start a conversation first.');\n  }\n  \n  const sourceConversation = await getConversation(sourceConversationId);\n  if (!sourceConversation) {\n    throw new Error(`Conversation ${sourceConversationId} not found`);\n  }\n  \n  const messages = await getConversationMessages(sourceConversationId);\n  \n  if (messages.length < 5) {\n    console.log('‚ö†Ô∏è  Conversation too short to summarize (need at least 5 messages)');\n    return;\n  }\n  \n  const keepRecent = options.keepRecent || 3;\n  \n  if (messages.length <= keepRecent + 2) {\n    console.log(`‚ö†Ô∏è  Conversation only has ${messages.length} messages, keeping recent ${keepRecent} would leave too few to summarize`);\n    return;\n  }\n  \n  // Split messages into older (to summarize) and recent (to keep)\n  const messagesToSummarize = messages.slice(0, -keepRecent);\n  const recentMessages = messages.slice(-keepRecent);\n  \n  console.log(`üìù Summarizing conversation: ${sourceConversation.name}`);\n  console.log(`üìä Summarizing ${messagesToSummarize.length} messages, keeping ${recentMessages.length} recent`);\n  \n  // Calculate current context size\n  const originalTokens = messages.reduce((sum, msg) => sum + Math.ceil(msg.content.length / 4), 0);\n  console.log(`üìè Original estimated context: ~${originalTokens} tokens`);\n  \n  if (options.dryRun) {\n    console.log('üß™ Dry run - showing what would be summarized:');\n    displaySummarizationPreview(messagesToSummarize, recentMessages);\n    return;\n  }\n  \n  // Load config and create gateway\n  const config = await loadConfig() as any;\n  if (!config.providers?.[sourceConversation.provider]) {\n    throw new Error(`Provider '${sourceConversation.provider}' not found in config`);\n  }\n  \n  const gateway = new GenAIGateway(config);\n  \n  // Create AI summary\n  const summary = await createAISummary(gateway, sourceConversation, messagesToSummarize);\n  \n  // Calculate token savings\n  const summaryTokens = Math.ceil(summary.length / 4);\n  const recentTokens = recentMessages.reduce((sum, msg) => sum + Math.ceil(msg.content.length / 4), 0);\n  const newTotalTokens = summaryTokens + recentTokens;\n  const tokenSavings = originalTokens - newTotalTokens;\n  const savingsPercent = Math.round((tokenSavings / originalTokens) * 100);\n  \n  console.log('');\n  console.log('üìã Generated Summary:');\n  console.log('‚îÄ'.repeat(60));\n  console.log(summary);\n  console.log('‚îÄ'.repeat(60));\n  console.log('');\n  console.log(`üíæ Token Optimization:`);\n  console.log(`   Original: ~${originalTokens} tokens`);\n  console.log(`   New total: ~${newTotalTokens} tokens (${summaryTokens} summary + ${recentTokens} recent)`);\n  console.log(`   Savings: ~${tokenSavings} tokens (${savingsPercent}%)`);\n  console.log('');\n  \n  // Determine new conversation parameters\n  const newProvider = options.provider || sourceConversation.provider;\n  const newModel = options.model || sourceConversation.model;\n  const newName = options.name || `${sourceConversation.name} (Summarized)`;\n  \n  // Create new conversation\n  console.log(`üÜï Creating new conversation: ${newName}`);\n  const newConversationId = await createConversation(\n    newName,\n    newProvider,\n    newModel,\n    'summarized'\n  );\n  \n  // Add summary as system message\n  await addMessageToConversation(\n    newConversationId,\n    'system',\n    `[CONVERSATION SUMMARY]: ${summary}`\n  );\n  \n  // Copy recent messages\n  for (const message of recentMessages) {\n    await addMessageToConversation(\n      newConversationId,\n      message.role as 'user' | 'assistant' | 'system',\n      message.content\n    );\n  }\n  \n  // Switch to new conversation\n  await setCurrentConversation(newConversationId);\n  \n  console.log('');\n  console.log(`‚úÖ Summarized conversation created!`);\n  console.log(`üÜî New conversation ID: ${newConversationId}`);\n  console.log(`üéØ Now active: ${newName}`);\n  console.log(`üí∞ Token savings: ${savingsPercent}% reduction`);\n  console.log('');\n  console.log('üí° Original conversation preserved unchanged');\n}\n\nasync function createAISummary(\n  gateway: any, \n  conversation: any, \n  messages: any[]\n): Promise<string> {\n  const conversationText = messages\n    .map(msg => `${msg.role.toUpperCase()}: ${msg.content}`)\n    .join('\\n\\n');\n  \n  const summarizationPrompt = `Please create a concise summary of this conversation that preserves the key information, context, and important details. The summary should be much shorter than the original but retain all essential information that might be needed for future conversation context.\n\nConversation to summarize:\n${conversationText}\n\nPlease provide a clear, structured summary that captures:\n1. Key topics discussed\n2. Important information shared (names, preferences, etc.)\n3. Main questions asked and answers provided\n4. Any ongoing context that should be preserved\n\nSummary:`;\n\n  console.log('ü§ñ Generating AI summary...');\n  \n  const response = await gateway.chatCompletion({\n    provider: conversation.provider,\n    model: conversation.model,\n    messages: [{ role: 'user', content: summarizationPrompt }]\n  });\n  \n  console.log(`üìä Summarization cost: ${response.usage.prompt_tokens} input + ${response.usage.completion_tokens} output = ${response.usage.total_tokens} tokens`);\n  \n  return response.choices[0].message.content || 'Summary generation failed';\n}\n\nfunction displaySummarizationPreview(messagesToSummarize: any[], recentMessages: any[]): void {\n  console.log('');\n  console.log('üìù Messages to be summarized:');\n  messagesToSummarize.forEach((msg, i) => {\n    const preview = msg.content.length > 100 ? msg.content.substring(0, 100) + '...' : msg.content;\n    console.log(`   ${i + 1}. [${msg.role}] ${preview}`);\n  });\n  \n  console.log('');\n  console.log('‚úÖ Messages to be kept (recent):');\n  recentMessages.forEach((msg, i) => {\n    const preview = msg.content.length > 100 ? msg.content.substring(0, 100) + '...' : msg.content;\n    console.log(`   ${i + 1}. [${msg.role}] ${preview}`);\n  });\n}\n","import { getConversation, getConversationMessages } from '../../utils/conversations.js';\nimport { getCurrentConversation } from './state.js';\n\ninterface ShowOptions {\n  conversation?: string;\n  limit?: number;\n  format?: 'full' | 'compact' | 'json';\n}\n\n/**\n * Show full conversation history\n */\nexport async function conversationShowCommand(\n  options: ShowOptions = {}\n): Promise<void> {\n  let targetConversationId = options.conversation;\n  \n  // If no conversation specified, use current conversation\n  if (!targetConversationId) {\n    targetConversationId = await getCurrentConversation() || undefined;\n  }\n  \n  if (!targetConversationId) {\n    throw new Error('No active conversation. Use --conversation <id> or start a conversation first.');\n  }\n  \n  const conversation = await getConversation(targetConversationId);\n  if (!conversation) {\n    throw new Error(`Conversation ${targetConversationId} not found`);\n  }\n  \n  const messages = await getConversationMessages(targetConversationId);\n  \n  if (messages.length === 0) {\n    console.log('üì≠ No messages in this conversation yet');\n    return;\n  }\n  \n  // Apply limit if specified\n  const displayMessages = options.limit ? messages.slice(-options.limit) : messages;\n  const format = options.format || 'full';\n  \n  // Show conversation header\n  console.log(`üí¨ Conversation: ${conversation.name}`);\n  console.log(`üÜî ID: ${conversation.id}`);\n  console.log(`ü§ñ Provider: ${conversation.provider}/${conversation.model}`);\n  console.log(`üìä Messages: ${messages.length} total${options.limit ? ` (showing last ${displayMessages.length})` : ''}`);\n  console.log(`üéØ Tokens: ${conversation.totalTokens || 0} total`);\n  console.log('');\n  \n  if (format === 'json') {\n    console.log(JSON.stringify(displayMessages, null, 2));\n    return;\n  }\n  \n  // Display messages\n  console.log('üìù Messages:');\n  console.log('‚îÄ'.repeat(80));\n  \n  displayMessages.forEach((message, index) => {\n    const messageNumber = options.limit ? \n      messages.length - displayMessages.length + index + 1 : \n      index + 1;\n    \n    const timestamp = new Date(message.timestamp).toLocaleString();\n    const roleIcon = getRoleIcon(message.role);\n    const roleName = message.role.toUpperCase();\n    \n    if (format === 'compact') {\n      // Compact format - one line per message\n      const preview = message.content.length > 100 ? \n        message.content.substring(0, 100) + '...' : \n        message.content;\n      console.log(`${messageNumber}. ${roleIcon} [${roleName}] ${preview}`);\n    } else {\n      // Full format - complete messages\n      console.log(`${messageNumber}. ${roleIcon} ${roleName} (${timestamp})`);\n      console.log('');\n      \n      // Handle long messages with proper formatting\n      const content = message.content;\n      if (content.length > 500) {\n        // For very long messages, add some formatting\n        const lines = content.split('\\n');\n        lines.forEach(line => {\n          if (line.trim()) {\n            console.log(`   ${line}`);\n          } else {\n            console.log('');\n          }\n        });\n      } else {\n        // For shorter messages, simple indentation\n        const lines = content.split('\\n');\n        lines.forEach(line => console.log(`   ${line}`));\n      }\n      \n      console.log('');\n      console.log('‚îÄ'.repeat(80));\n    }\n  });\n  \n  // Show summary\n  if (format !== 'compact') {\n    console.log('');\n    console.log('üìà Summary:');\n    console.log(`   Total messages: ${messages.length}`);\n    console.log(`   User messages: ${messages.filter(m => m.role === 'user').length}`);\n    console.log(`   Assistant messages: ${messages.filter(m => m.role === 'assistant').length}`);\n    console.log(`   System messages: ${messages.filter(m => m.role === 'system').length}`);\n    console.log(`   Total characters: ${messages.reduce((sum, m) => sum + m.content.length, 0).toLocaleString()}`);\n    console.log(`   Estimated tokens: ~${Math.ceil(messages.reduce((sum, m) => sum + m.content.length, 0) / 4)}`);\n    \n    if (conversation.totalTokens > 0) {\n      console.log(`   Actual tokens used: ${conversation.totalTokens}`);\n    }\n  }\n}\n\nfunction getRoleIcon(role: string): string {\n  switch (role) {\n    case 'user': return 'üë§';\n    case 'assistant': return 'ü§ñ';\n    case 'system': return '‚öôÔ∏è';\n    default: return '‚ùì';\n  }\n}\n","import { getConversation, findConversationByName } from '../../utils/conversations.js';\nimport { setCurrentConversation } from './state.js';\n\nexport async function conversationContinueCommand(conversationIdentifier: string): Promise<void> {\n  let conversation = await getConversation(conversationIdentifier);\n  \n  // If not found by ID, try to find by name\n  if (!conversation) {\n    conversation = await findConversationByName(conversationIdentifier);\n  }\n  \n  if (!conversation) {\n    throw new Error(`Conversation '${conversationIdentifier}' not found`);\n  }\n  \n  await setCurrentConversation(conversation.id);\n  \n  console.log(`üîÑ Switched to conversation: ${conversation.name}`);\n  console.log(`üìù ID: ${conversation.id}`);\n  console.log(`ü§ñ Provider: ${conversation.provider}/${conversation.model}`);\n  console.log(`üìä Messages: ${conversation.messageCount}`);\n}\n","import { getConversation, findConversationByName, deleteConversation } from '../../utils/conversations.js';\nimport { getCurrentConversation, clearCurrentConversation } from './state.js';\n\nexport async function conversationDeleteCommand(conversationIdentifier: string): Promise<void> {\n  let conversation = await getConversation(conversationIdentifier);\n  \n  // If not found by ID, try to find by name\n  if (!conversation) {\n    conversation = await findConversationByName(conversationIdentifier);\n  }\n  \n  if (!conversation) {\n    throw new Error(`Conversation '${conversationIdentifier}' not found`);\n  }\n  \n  await deleteConversation(conversation.id);\n  \n  // Clear current conversation if it was the deleted one\n  const currentId = await getCurrentConversation();\n  if (currentId === conversation.id) {\n    await clearCurrentConversation();\n  }\n  \n  console.log(`üóëÔ∏è Deleted conversation: ${conversation.name}`);\n}\n","import type { CLIContext } from '../utils/cli-context.js';\nimport { resolveModel, resolveModelConfig } from '@anygpt/config';\n\ninterface ChatOptions {\n  provider?: string;\n  type?: 'openai' | 'anthropic' | 'google';\n  url?: string;\n  token?: string;\n  model?: string;\n  tag?: string;\n  maxTokens?: number;\n  usage?: boolean;\n  stdin?: boolean;\n}\n\nexport async function chatCommand(\n  context: CLIContext,\n  message: string | undefined,\n  options: ChatOptions\n) {\n  // Read from stdin if --stdin flag is set\n  let actualMessage = message;\n  if (options.stdin) {\n    const chunks: Buffer[] = [];\n    for await (const chunk of process.stdin) {\n      chunks.push(chunk);\n    }\n    actualMessage = Buffer.concat(chunks).toString('utf-8').trim();\n  }\n\n  if (!actualMessage) {\n    throw new Error(\n      'No message provided. Either pass a message argument or use --stdin flag to read from stdin.'\n    );\n  }\n  // Validate that only one of --model or --tag is specified\n  if (options.model && options.tag) {\n    throw new Error(\n      'Cannot specify both --model and --tag. Use --model for direct model names or --tag for tag resolution.'\n    );\n  }\n\n  // Determine which provider to use\n  let providerId = options.provider || context.defaults.provider;\n\n  if (!providerId) {\n    throw new Error(\n      'No provider specified. Use --provider or configure a default provider.'\n    );\n  }\n\n  let modelId: string;\n\n  if (options.tag) {\n    // --tag: Resolve tag to model using tag registry\n    // Support provider:tag syntax (e.g., \"openai:gemini\", \"cody:sonnet\")\n    let tagToResolve = options.tag;\n    let explicitProvider: string | undefined;\n\n    if (options.tag.includes(':')) {\n      const parts = options.tag.split(':', 2);\n      explicitProvider = parts[0];\n      tagToResolve = parts[1];\n\n      // Override providerId if provider:tag syntax is used\n      if (explicitProvider) {\n        providerId = explicitProvider;\n      }\n    }\n\n    // Use tag registry if available (fast lookup)\n    if (context.tagRegistry) {\n      const resolution = context.tagRegistry.resolve(tagToResolve, providerId);\n\n      if (!resolution) {\n        throw new Error(\n          `Tag '${tagToResolve}' not found in provider '${providerId}'. ` +\n            `Run 'anygpt list-tags --provider ${providerId}' to see available tags.`\n        );\n      }\n\n      providerId = resolution.provider;\n      modelId = resolution.model;\n    } else {\n      // Fallback to old resolution method (for non-factory configs)\n      const resolution = resolveModel(\n        tagToResolve,\n        {\n          providers: context.providers,\n          aliases: context.defaults.aliases,\n          defaultProvider: context.defaults.provider,\n        },\n        providerId\n      );\n\n      if (!resolution) {\n        throw new Error(\n          `Tag '${tagToResolve}' not found in provider '${providerId}'. ` +\n            `Run 'anygpt list-tags --provider ${providerId}' to see available tags.`\n        );\n      }\n\n      providerId = resolution.provider;\n      modelId = resolution.model;\n    }\n\n    if (explicitProvider) {\n      context.logger.info(`üîó Resolved tag '${options.tag}' ‚Üí ${modelId}`);\n    } else {\n      context.logger.info(\n        `üîó Resolved tag '${tagToResolve}' ‚Üí ${providerId}:${modelId}`\n      );\n    }\n  } else if (options.model) {\n    // --model: Use model name directly (no resolution)\n    modelId = options.model;\n    context.logger.info(`üìå Using direct model: ${providerId}:${modelId}`);\n  } else {\n    // No --model or --tag: Use defaults\n    const defaultTag = context.defaults.providers?.[providerId]?.tag;\n    const defaultModel =\n      context.defaults.providers?.[providerId]?.model || context.defaults.model;\n\n    // If default tag is specified, resolve it\n    if (defaultTag && !defaultModel) {\n      // Use tag registry if available (fast lookup)\n      if (context.tagRegistry) {\n        const resolution = context.tagRegistry.resolve(defaultTag, providerId);\n\n        if (!resolution) {\n          throw new Error(\n            `Could not resolve default tag '${defaultTag}' for provider '${providerId}'.\\n` +\n              `Run 'anygpt list-tags --provider ${providerId}' to see available tags.`\n          );\n        }\n\n        providerId = resolution.provider;\n        modelId = resolution.model;\n      } else {\n        // Fallback to old resolution method (for non-factory configs)\n        const resolution = resolveModel(\n          defaultTag,\n          {\n            providers: context.providers,\n            aliases: context.defaults.aliases,\n            defaultProvider: context.defaults.provider,\n          },\n          providerId\n        );\n\n        if (!resolution) {\n          throw new Error(\n            `Could not resolve default tag '${defaultTag}' for provider '${providerId}'.\\n` +\n              `Run 'anygpt list-tags --provider ${providerId}' to see available tags.`\n          );\n        }\n\n        providerId = resolution.provider;\n        modelId = resolution.model;\n      }\n\n      context.logger.info(`üìå Using default tag '${defaultTag}' ‚Üí ${modelId}`);\n    } else if (defaultModel) {\n      modelId = defaultModel;\n      context.logger.info(`üìå Using default model: ${providerId}:${modelId}`);\n    } else {\n      throw new Error(\n        `No model specified. Use --model <model-name>, --tag <tag>, or configure a default model.\\n` +\n          `Run 'anygpt list-tags' to see available tags.`\n      );\n    }\n  }\n\n  // Verbose mode: show request metrics\n  context.logger.info(`üì§ Request: provider=${providerId}, model=${modelId}`);\n  context.logger.info(`üí¨ Message length: ${actualMessage.length} chars`);\n  context.logger.info(''); // Empty line before response\n\n  try {\n    const startTime = Date.now();\n\n    // Resolve model configuration using rule matching\n    const providers = context.config?.providers || {};\n    const providerConfig = providers[providerId];\n    const globalRules = context.defaults?.modelRules;\n    const modelConfig = resolveModelConfig(\n      modelId,\n      providerId,\n      providerConfig,\n      globalRules\n    );\n\n    context.logger.debug('Model config:', {\n      model: modelId,\n      provider: providerId,\n      max_tokens: modelConfig.max_tokens,\n      useLegacyMaxTokens: modelConfig.useLegacyMaxTokens,\n      useLegacyCompletionAPI: modelConfig.useLegacyCompletionAPI,\n      fallbackToChatCompletion: modelConfig.fallbackToChatCompletion,\n    });\n\n    const requestParams = {\n      provider: providerId,\n      model: modelId,\n      messages: [{ role: 'user', content: actualMessage }],\n      // CLI flag takes precedence over model config\n      ...((options.maxTokens || modelConfig.max_tokens) && {\n        max_tokens: options.maxTokens || modelConfig.max_tokens,\n        useLegacyMaxTokens: modelConfig.useLegacyMaxTokens, // Pass capability flag\n      }),\n      ...(modelConfig.useLegacyCompletionAPI !== undefined && {\n        useLegacyCompletionAPI: modelConfig.useLegacyCompletionAPI,\n      }),\n      ...(modelConfig.fallbackToChatCompletion !== undefined && {\n        fallbackToChatCompletion: modelConfig.fallbackToChatCompletion,\n      }),\n      ...(modelConfig.reasoning && { reasoning: modelConfig.reasoning }),\n      ...(modelConfig.extra_body && { extra_body: modelConfig.extra_body }),\n    };\n\n    const response = await context.router.chatCompletion(requestParams);\n\n    const duration = Date.now() - startTime;\n\n    const reply = response.choices[0]?.message?.content;\n    const finishReason = response.choices[0]?.finish_reason;\n\n    // Debug: Log finish reason if response seems truncated\n    if (finishReason && finishReason !== 'stop') {\n      context.logger.debug(`‚ö†Ô∏è  Finish reason: ${finishReason}`);\n    }\n\n    // Print the actual response (clearly visible)\n    if (reply) {\n      console.log(reply);\n    } else {\n      console.log('No response received');\n    }\n\n    // Verbose mode: show response metrics after the response\n    context.logger.info(''); // Empty line after response\n    context.logger.info(`‚è±Ô∏è  Response time: ${duration}ms`);\n    if (response.usage) {\n      context.logger.info(\n        `üìä Tokens: ${response.usage.prompt_tokens} input + ${response.usage.completion_tokens} output = ${response.usage.total_tokens} total`\n      );\n    }\n    if (response.model) {\n      context.logger.info(`ü§ñ Model used: ${response.model}`);\n    }\n    if (reply) {\n      context.logger.info(`üìù Response length: ${reply.length} chars`);\n    }\n\n    // Show usage info only if --usage flag is provided (for non-verbose mode)\n    // In verbose mode, usage is already shown above via context.logger.info\n    const hasVerboseFlag = process.argv.some(\n      (arg) => arg === '--verbose' || arg === '-v'\n    );\n    if (options.usage && response.usage && !hasVerboseFlag) {\n      console.log('');\n      console.log(\n        `üìä Usage: ${response.usage.prompt_tokens} input + ${response.usage.completion_tokens} output = ${response.usage.total_tokens} tokens`\n      );\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    // Enhanced error messages for common issues\n    if (errorMessage.includes('422')) {\n      throw new Error(\n        `Model '${modelId}' not found or not supported by provider '${providerId}'.\\n` +\n          `\\nTroubleshooting:\\n` +\n          `  1. Run 'anygpt list-tags --provider ${providerId}' to see available tags\\n` +\n          `  2. Run 'anygpt list-models --provider ${providerId}' to see available models\\n` +\n          `  3. Use --tag instead of --model if you want tag resolution\\n` +\n          `\\nOriginal error: ${errorMessage}`\n      );\n    }\n\n    if (errorMessage.includes('401') || errorMessage.includes('403')) {\n      throw new Error(\n        `Authentication failed for provider '${providerId}'.\\n` +\n          `Check your API credentials in the configuration.\\n` +\n          `\\nOriginal error: ${errorMessage}`\n      );\n    }\n\n    // If error already has emoji, print directly without \"Error:\" prefix\n    if (errorMessage.startsWith('‚ùå')) {\n      console.error(errorMessage);\n      process.exit(1);\n    }\n    throw new Error(`‚ùå Chat request failed: ${errorMessage}`);\n  }\n}\n","import * as readline from 'node:readline';\nimport type {\n  IChatLoop,\n  ChatLoopOptions,\n  Message,\n  Commands,\n} from './types.js';\n\n/**\n * Interactive chat loop with REPL and history management\n */\nexport class ChatLoop implements IChatLoop {\n  private history: Message[] = [];\n  private running = false;\n  private rl: readline.Interface | null = null;\n  private options: ChatLoopOptions = {};\n  private commands: Commands = {};\n\n  constructor() {\n    this.setupCommands();\n  }\n\n  /**\n   * Setup built-in commands\n   */\n  private setupCommands(): void {\n    this.commands = {\n      exit: {\n        handler: () => {\n          this.stop();\n        },\n        description: 'Exit the chat',\n      },\n      quit: {\n        handler: () => {\n          this.stop();\n        },\n        description: 'Exit the chat (alias for /exit)',\n      },\n      help: {\n        handler: () => {\n          console.log('\\nAvailable commands:');\n          for (const [cmd, { description }] of Object.entries(this.commands)) {\n            console.log(`  /${cmd} - ${description}`);\n          }\n          console.log('');\n        },\n        description: 'Show this help message',\n      },\n      clear: {\n        handler: () => {\n          this.clearHistory();\n          console.log('History cleared.');\n        },\n        description: 'Clear message history',\n      },\n      history: {\n        handler: () => {\n          const history = this.getHistory();\n          if (history.length === 0) {\n            console.log('No messages in history.');\n            return;\n          }\n          console.log(`\\nMessage history (${history.length} messages):`);\n          for (const msg of history) {\n            const time = msg.timestamp.toLocaleTimeString();\n            console.log(`[${time}] ${msg.role}: ${msg.content}`);\n          }\n          console.log('');\n        },\n        description: 'Show message history',\n      },\n    };\n  }\n\n  /**\n   * Start the chat loop\n   */\n  async start(options: ChatLoopOptions = {}): Promise<void> {\n    if (this.running) {\n      throw new Error('Chat loop is already running');\n    }\n\n    this.options = {\n      prompt: options.prompt || '> ',\n      maxHistory: options.maxHistory || 100,\n      onMessage: options.onMessage || this.defaultMessageHandler.bind(this),\n    };\n\n    this.running = true;\n\n    // Create readline interface\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n      prompt: this.options.prompt,\n      historySize: this.options.maxHistory,\n    });\n\n    // Handle SIGINT (Ctrl+C)\n    this.rl.on('SIGINT', () => {\n      console.log('\\n(To exit, type /exit or press Ctrl+C again)');\n      this.rl?.prompt();\n    });\n\n    // Handle line input\n    this.rl.on('line', async (input: string) => {\n      const trimmed = input.trim();\n\n      if (!trimmed) {\n        this.rl?.prompt();\n        return;\n      }\n\n      // Check for commands\n      if (trimmed.startsWith('/')) {\n        await this.handleCommand(trimmed);\n        this.rl?.prompt();\n        return;\n      }\n\n      // Add user message to history\n      this.addMessage({\n        role: 'user',\n        content: trimmed,\n        timestamp: new Date(),\n      });\n\n      try {\n        // Call message handler\n        if (!this.options.onMessage) {\n          throw new Error('No message handler configured');\n        }\n        const response = await this.options.onMessage(trimmed);\n\n        // Add assistant response to history\n        this.addMessage({\n          role: 'assistant',\n          content: response,\n          timestamp: new Date(),\n        });\n\n        // Display response\n        console.log(response);\n      } catch (error) {\n        const errorMsg =\n          error instanceof Error ? error.message : String(error);\n        console.error(`Error: ${errorMsg}`);\n      }\n\n      this.rl?.prompt();\n    });\n\n    // Handle close\n    this.rl.on('close', () => {\n      this.running = false;\n    });\n\n    // Show initial prompt\n    console.log('Chat started. Type /help for commands, /exit to quit.\\n');\n    this.rl.prompt();\n\n    // Wait for the readline to close\n    return new Promise<void>((resolve) => {\n      this.rl?.on('close', () => {\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Stop the chat loop\n   */\n  async stop(): Promise<void> {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n\n    if (this.rl) {\n      this.rl.close();\n      this.rl = null;\n    }\n  }\n\n  /**\n   * Add a message to history\n   */\n  addMessage(message: Message): void {\n    this.history.push(message);\n\n    // Enforce max history limit\n    const maxHistory = this.options.maxHistory || 100;\n    if (this.history.length > maxHistory) {\n      this.history = this.history.slice(-maxHistory);\n    }\n  }\n\n  /**\n   * Get all messages from history\n   */\n  getHistory(): Message[] {\n    return [...this.history];\n  }\n\n  /**\n   * Clear message history\n   */\n  clearHistory(): void {\n    this.history = [];\n  }\n\n  /**\n   * Check if chat loop is running\n   */\n  isRunning(): boolean {\n    return this.running;\n  }\n\n  /**\n   * Default message handler (echo)\n   */\n  private async defaultMessageHandler(message: string): Promise<string> {\n    return `Echo: ${message}`;\n  }\n\n  /**\n   * Handle command execution\n   */\n  private async handleCommand(input: string): Promise<void> {\n    const parts = input.slice(1).split(' ');\n    const command = parts[0].toLowerCase();\n    const args = parts.slice(1);\n\n    const cmd = this.commands[command];\n    if (!cmd) {\n      console.log(`Unknown command: /${command}. Type /help for available commands.`);\n      return;\n    }\n\n    try {\n      await cmd.handler(args);\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      console.error(`Command error: ${errorMsg}`);\n    }\n  }\n}\n","import { ChatLoop } from '../chat-loop/index.js';\nimport { AIProvider } from '@anygpt/ai-provider';\nimport type { CLIContext } from '../utils/cli-context.js';\nimport type { Message } from '../chat-loop/types.js';\n\ninterface ChatInteractiveOptions {\n  echo?: boolean;\n  model?: string;\n  provider?: string;\n}\n\n/**\n * Start an interactive chat session with AI\n */\nexport async function chatInteractiveCommand(\n  context: CLIContext,\n  options: ChatInteractiveOptions\n) {\n  const chatLoop = new ChatLoop();\n\n  // Determine provider and model\n  const providerId = options.provider || context.defaults.provider || 'openai';\n  const modelId = options.model || context.defaults.model || 'gpt-4o-mini';\n\n  console.log('ü§ñ Interactive AI Chat');\n  console.log(`Provider: ${providerId}`);\n  console.log(`Model: ${modelId}`);\n  console.log('Type /help for commands, /exit to quit.\\n');\n\n  // Create AI provider\n  const aiProvider = new AIProvider(context.router, {\n    provider: providerId,\n    model: modelId,\n  });\n\n  await chatLoop.start({\n    prompt: 'üí¨ ',\n    maxHistory: 50,\n    onMessage: async (message: string) => {\n      // Echo mode for testing\n      if (options.echo) {\n        return `Echo: ${message}`;\n      }\n\n      try {\n        // Get conversation history\n        const history = chatLoop.getHistory();\n\n        // Convert to AI provider format\n        const messages: Array<{\n          role: 'system' | 'user' | 'assistant';\n          content: string;\n        }> = history.map((msg: Message) => ({\n          role: msg.role as 'system' | 'user' | 'assistant',\n          content: msg.content,\n        }));\n\n        // Call AI\n        context.logger.debug('Sending request to AI...');\n        const response = await aiProvider.chat({ messages });\n\n        // Log token usage\n        context.logger.info(\n          `üìä Tokens: ${response.usage.promptTokens} input + ${response.usage.completionTokens} output = ${response.usage.totalTokens} total`\n        );\n\n        return response.message;\n      } catch (error) {\n        const errorMsg =\n          error instanceof Error ? error.message : String(error);\n        context.logger.error(`AI Error: ${errorMsg}`);\n        return `‚ùå Error: ${errorMsg}`;\n      }\n    },\n  });\n\n  console.log('\\nüëã Chat ended. Goodbye!');\n}\n","/**\n * Configuration inspection command\n */\n\n\ninterface ConfigOptions {\n  json?: boolean;\n}\n\nimport type { CLIContext } from '../utils/cli-context.js';\n\nexport async function configCommand(\n  context: CLIContext,\n  options: ConfigOptions\n) {\n  try {\n    const config = context.config;\n    const configSource = context.configSource;\n    \n    if (options.json) {\n      // JSON output - pure config, no sanitization needed since we use tokenEnv\n      console.log(JSON.stringify(processConfigForDisplay(config), null, 2));\n    } else {\n      // Tree output\n      console.log('üìã AnyGPT Configuration');\n      console.log('‚ïê'.repeat(50));\n      console.log(`üìÅ Source: ${configSource}`);\n      console.log();\n      printConfigTree(processConfigForDisplay(config));\n    }\n    \n  } catch (error) {\n    throw new Error(`Failed to load configuration: ${error instanceof Error ? error.message : error}`);\n  }\n}\n\n/**\n * Process config for display - convert connector instances to declarative format\n * No sanitization needed since we use tokenEnv instead of storing secrets\n */\nfunction processConfigForDisplay(config: any): any {\n  return JSON.parse(JSON.stringify(config, (key, value) => {\n    // Handle connector objects - both instances and declarative configs\n    if (key === 'connector' && typeof value === 'object' && value !== null) {\n      // Check if it's already in declarative format (from JSON config)\n      if (value.type && typeof value.type === 'string') {\n        // Already declarative - pass through as-is\n        return value;\n      }\n      \n      // It's a connector instance - extract config from it\n      if (value.constructor) {\n        // Get package name from the connector's static property\n        const packageName = (value.constructor as any).packageName || `@anygpt/${value.constructor.name.toLowerCase().replace('connector', '')}`;\n        \n        const connectorInfo: { type: string; options?: any } = {\n          type: packageName\n        };\n        \n        try {\n          if (value.getUserConfig && typeof value.getUserConfig === 'function') {\n            // Use user config (only explicitly set values)\n            const userConfig = value.getUserConfig();\n            if (userConfig && typeof userConfig === 'object' && Object.keys(userConfig).length > 0) {\n              connectorInfo.options = userConfig;\n            }\n          } else if (value.config || value.getConfig) {\n            // Fallback to full config if getUserConfig not available\n            const connectorConfig = value.config || value.getConfig?.();\n            if (connectorConfig && typeof connectorConfig === 'object' && Object.keys(connectorConfig).length > 0) {\n              connectorInfo.options = connectorConfig;\n            }\n          }\n        } catch {\n          connectorInfo.options = '[Unable to serialize]';\n        }\n        \n        return connectorInfo;\n      }\n    }\n    \n    return value;\n  }));\n}\n\n/**\n * Print configuration as a tree structure\n */\nfunction printConfigTree(config: any, indent = ''): void {\n  for (const [key, value] of Object.entries(config)) {\n    if (value === null || value === undefined) {\n      console.log(`${indent}‚îú‚îÄ ${key}: ${value}`);\n    } else if (typeof value === 'object' && !Array.isArray(value)) {\n      console.log(`${indent}‚îú‚îÄ ${key}:`);\n      printConfigTree(value, indent + '‚îÇ  ');\n    } else if (Array.isArray(value)) {\n      console.log(`${indent}‚îú‚îÄ ${key}: [${value.length} items]`);\n      value.forEach((item, i) => {\n        if (typeof item === 'object') {\n          console.log(`${indent}‚îÇ  ‚îú‚îÄ [${i}]:`);\n          printConfigTree(item, indent + '‚îÇ  ‚îÇ  ');\n        } else {\n          console.log(`${indent}‚îÇ  ‚îú‚îÄ [${i}]: ${item}`);\n        }\n      });\n    } else {\n      const displayValue = typeof value === 'string' && value.length > 50 \n        ? value.substring(0, 47) + '...'\n        : value;\n      console.log(`${indent}‚îú‚îÄ ${key}: ${displayValue}`);\n    }\n  }\n}\n","import type { CLIContext } from '../utils/cli-context.js';\nimport { resolveModelConfig } from '@anygpt/config';\nimport type {\n  ConnectorConfig,\n  IConnector,\n  ConnectorFactory,\n  ModelInfo,\n} from '@anygpt/router';\n\ninterface ListModelsOptions {\n  provider?: string;\n  json?: boolean;\n  tags?: boolean;\n  filterTags?: string; // Comma-separated tags, use ! prefix for exclusion\n  enabled?: boolean; // Filter by enabled status\n}\n\n/**\n * Create default config from generic environment variables\n */\nfunction createDefaultConfig(): Partial<ConnectorConfig> {\n  const config: Partial<ConnectorConfig> = {};\n\n  // Generic environment variables that connectors may use\n  if (process.env.SRC_ACCESS_TOKEN) {\n    config.accessToken = process.env.SRC_ACCESS_TOKEN;\n  }\n  if (process.env.SRC_ENDPOINT) {\n    config.endpoint = process.env.SRC_ENDPOINT;\n  }\n  if (process.env.OPENAI_API_KEY) {\n    (config as Record<string, unknown>).apiKey = process.env.OPENAI_API_KEY;\n  }\n  if (process.env.OPENAI_API_URL) {\n    (config as Record<string, unknown>).apiUrl = process.env.OPENAI_API_URL;\n  }\n\n  return config;\n}\n\n/**\n * Dynamically import and create a connector from a package name\n */\nasync function createConnectorFromPackage(\n  packageName: string,\n  config?: Partial<ConnectorConfig>\n): Promise<IConnector> {\n  try {\n    // Import the package\n    const module = await import(packageName);\n\n    // Try to get the default export (should be a factory or connector)\n    const defaultExport = module.default;\n\n    if (!defaultExport) {\n      throw new Error(`Package ${packageName} has no default export`);\n    }\n\n    // Merge provided config with defaults from environment variables\n    const finalConfig = { ...createDefaultConfig(), ...config };\n\n    // If it's a factory class, create the connector\n    if (typeof defaultExport === 'function') {\n      // Check if it looks like a connector factory (has create method)\n      if (\n        defaultExport.prototype &&\n        typeof defaultExport.prototype.create === 'function'\n      ) {\n        const factory = new defaultExport() as ConnectorFactory;\n        return factory.create(finalConfig);\n      }\n      // Otherwise assume it's a direct factory function\n      return defaultExport(finalConfig) as IConnector;\n    }\n\n    // If it's already a connector instance\n    if (typeof defaultExport === 'object' && 'listModels' in defaultExport) {\n      return defaultExport as IConnector;\n    }\n\n    throw new Error(\n      `Package ${packageName} does not export a valid connector or factory`\n    );\n  } catch (error) {\n    if (\n      error instanceof Error &&\n      error.message.includes('Cannot resolve module')\n    ) {\n      throw new Error(\n        `Package ${packageName} is not installed. Install it with: npm install ${packageName}`\n      );\n    }\n    throw error;\n  }\n}\n\n/**\n * Check if a string looks like a package name (contains @ or / or starts with a letter)\n */\nfunction isPackageName(provider: string): boolean {\n  return (\n    provider.includes('@') || provider.includes('/') || /^[a-z]/.test(provider)\n  );\n}\n\nexport async function listModelsCommand(\n  context: CLIContext,\n  options: ListModelsOptions\n) {\n  // Determine which provider to use\n  const providerSpec = options.provider || context.defaults.provider;\n\n  if (!providerSpec) {\n    throw new Error(\n      'No provider specified. Use --provider or configure a default provider.'\n    );\n  }\n\n  try {\n    let models: ModelInfo[];\n    let providerId: string;\n\n    // First, try to use the provider from the router (configured providers)\n    // Only fall back to package import if the provider is not configured\n    try {\n      models = await context.router.listModels(providerSpec);\n      providerId = providerSpec;\n    } catch (routerError) {\n      // If router fails and the provider looks like a package name, try importing it\n      if (isPackageName(providerSpec)) {\n        console.log(`üì¶ Importing connector from package: ${providerSpec}`);\n\n        // Try to import and create the connector\n        const connector = await createConnectorFromPackage(providerSpec);\n\n        // Call listModels directly on the connector\n        models = await connector.listModels();\n        providerId = providerSpec;\n      } else {\n        // Re-throw the router error if it's not a package name\n        throw routerError;\n      }\n    }\n\n    // Resolve tags and enabled status\n    type ModelWithMetadata = ModelInfo & {\n      resolvedTags?: string[];\n      enabled: boolean;\n    };\n    let modelsWithTags: ModelWithMetadata[] = models;\n    const providerConfig = context.providers[providerId];\n    const globalRules = context.defaults?.modelRules;\n\n    // Always resolve enabled status, resolve tags only if needed\n    modelsWithTags = models.map((model) => {\n      const config = resolveModelConfig(\n        model.id,\n        providerId,\n        providerConfig,\n        globalRules\n      );\n      return {\n        ...model,\n        resolvedTags:\n          options.tags || options.filterTags ? config.tags || [] : undefined,\n        enabled: config.enabled !== false, // enabled is true by default (undefined means enabled)\n      };\n    });\n\n    if (options.tags || options.filterTags) {\n      // Apply tag filtering if specified\n      if (options.filterTags) {\n        const filters = options.filterTags.split(',').map((t) => t.trim());\n        const includeTags = filters\n          .filter((t) => !t.startsWith('!'))\n          .map((t) => t.toLowerCase());\n        const excludeTags = filters\n          .filter((t) => t.startsWith('!'))\n          .map((t) => t.substring(1).toLowerCase());\n\n        modelsWithTags = modelsWithTags.filter((model) => {\n          const modelTags = (model.resolvedTags || []).map((t) =>\n            t.toLowerCase()\n          );\n\n          // Check exclusions first\n          for (const excludeTag of excludeTags) {\n            if (modelTags.includes(excludeTag)) {\n              return false; // Exclude this model\n            }\n          }\n\n          // If there are include filters, model must have at least one\n          if (includeTags.length > 0) {\n            return includeTags.some((includeTag) =>\n              modelTags.includes(includeTag)\n            );\n          }\n\n          return true; // No include filters or passed exclusions\n        });\n      }\n    }\n\n    // Apply enabled filtering if specified\n    if (options.enabled !== undefined) {\n      modelsWithTags = modelsWithTags.filter(\n        (model) => model.enabled === options.enabled\n      );\n    }\n\n    if (options.json) {\n      console.log(JSON.stringify(modelsWithTags, null, 2));\n    } else {\n      console.log(`\\nüìã Available models from provider '${providerId}':\\n`);\n\n      if (modelsWithTags.length === 0) {\n        console.log('  No models available');\n      } else if (options.tags) {\n        // Show models with tags and enabled status\n        for (const model of modelsWithTags) {\n          const statusIcon = model.enabled ? '‚úÖ' : '‚ùå';\n          console.log(`  ${statusIcon} ${model.id}`);\n          if (model.resolvedTags && model.resolvedTags.length > 0) {\n            console.log(`    Tags: ${model.resolvedTags.join(', ')}`);\n          } else {\n            console.log(`    Tags: (none)`);\n          }\n          console.log();\n        }\n      } else {\n        // Find max lengths for table formatting\n        const maxIdLength = Math.max(\n          ...modelsWithTags.map((m) => m.id.length),\n          10\n        );\n        const maxProviderLength = Math.max(\n          ...modelsWithTags.map((m) => (m.provider || '').length),\n          10\n        );\n        const maxDisplayLength = Math.max(\n          ...modelsWithTags.map((m) => (m.display_name || '').length),\n          15\n        );\n\n        // Print table header with Enabled column\n        console.log(\n          `  ${'‚úì'.padEnd(3)}  ${'Model ID'.padEnd(\n            maxIdLength\n          )}  ${'Provider'.padEnd(maxProviderLength)}  ${'Display Name'.padEnd(\n            maxDisplayLength\n          )}`\n        );\n        console.log(\n          `  ${'‚îÄ'.repeat(3)}  ${'‚îÄ'.repeat(maxIdLength)}  ${'‚îÄ'.repeat(\n            maxProviderLength\n          )}  ${'‚îÄ'.repeat(maxDisplayLength)}`\n        );\n\n        // Print table rows\n        for (const model of modelsWithTags) {\n          const statusIcon = model.enabled ? '‚úÖ' : '‚ùå';\n          const provider = model.provider || '-';\n          const displayName = model.display_name || '-';\n          console.log(\n            `  ${statusIcon.padEnd(3)}  ${model.id.padEnd(\n              maxIdLength\n            )}  ${provider.padEnd(maxProviderLength)}  ${displayName.padEnd(\n              maxDisplayLength\n            )}`\n          );\n        }\n      }\n\n      // Count enabled and disabled models\n      const enabledCount = modelsWithTags.filter((m) => m.enabled).length;\n      const disabledCount = modelsWithTags.length - enabledCount;\n\n      console.log(\n        `\\n‚úÖ Found ${modelsWithTags.length} model${\n          modelsWithTags.length !== 1 ? 's' : ''\n        } (${enabledCount} enabled, ${disabledCount} disabled)\\n`\n      );\n    }\n  } catch (error) {\n    throw new Error(\n      `Failed to list models: ${error instanceof Error ? error.message : error}`\n    );\n  }\n}\n","import type { CLIContext } from '../utils/cli-context.js';\nimport { listAvailableTags } from '@anygpt/config';\n\ninterface ListTagsOptions {\n  json?: boolean;\n  provider?: string;\n}\n\n/**\n * List all available tags and their model mappings from configuration\n * This makes tag resolution discoverable without calling provider APIs\n */\nexport async function listTagsCommand(\n  context: CLIContext,\n  options: ListTagsOptions\n) {\n  const result = listAvailableTags({\n    providers: context.providers,\n    aliases: context.defaults.aliases,\n    defaultProvider: context.defaults.provider,\n    globalModelRules: context.defaults.modelRules,\n  });\n\n  // Filter by provider if specified\n  const filteredTags = options.provider\n    ? result.tags.filter((t) => t.provider === options.provider)\n    : result.tags;\n\n  const filteredAliases = options.provider\n    ? result.aliases.filter((a) => a.provider === options.provider)\n    : result.aliases;\n\n  if (options.json) {\n    console.log(\n      JSON.stringify(\n        {\n          providers: result.providers,\n          tags: filteredTags,\n          aliases: filteredAliases,\n        },\n        null,\n        2\n      )\n    );\n    return;\n  }\n\n  // Human-readable output\n  console.log('\\nüè∑Ô∏è  Available Tags and Model Mappings\\n');\n\n  // Show providers\n  console.log('üì¶ Configured Providers:');\n  for (const provider of result.providers) {\n    const defaultMarker = provider.isDefault ? ' (default)' : '';\n    const name = provider.name ? ` - ${provider.name}` : '';\n    console.log(`  ‚Ä¢ ${provider.id}${name}${defaultMarker}`);\n  }\n  console.log();\n\n  // Group tags by provider\n  const tagsByProvider = new Map<string, typeof filteredTags>();\n  for (const tag of filteredTags) {\n    if (!tagsByProvider.has(tag.provider)) {\n      tagsByProvider.set(tag.provider, []);\n    }\n    const providerTags = tagsByProvider.get(tag.provider);\n    if (providerTags) {\n      providerTags.push(tag);\n    }\n  }\n\n  // Group tags across all providers to show each tag once\n  console.log('üè∑Ô∏è  Tags (showing unique tags with provider mappings):');\n\n  // Build a map: tag -> array of {provider, providerName, model}\n  const tagToProviders = new Map<\n    string,\n    Array<{\n      provider: string;\n      providerName: string;\n      model: string;\n      isDefault: boolean;\n    }>\n  >();\n\n  for (const tagInfo of filteredTags) {\n    if (!tagToProviders.has(tagInfo.tag)) {\n      tagToProviders.set(tagInfo.tag, []);\n    }\n    const providers = tagToProviders.get(tagInfo.tag);\n    if (providers) {\n      providers.push({\n        provider: tagInfo.provider,\n        providerName: tagInfo.providerName || tagInfo.provider,\n        model: tagInfo.model,\n        isDefault: tagInfo.isDefault || false,\n      });\n    }\n  }\n\n  // Sort tags alphabetically\n  const sortedTags = Array.from(tagToProviders.keys()).sort();\n\n  for (const tag of sortedTags) {\n    const providers = tagToProviders.get(tag);\n    if (!providers) continue;\n\n    if (providers.length === 1) {\n      // Single provider - show inline with provider:tag syntax\n      const p = providers[0];\n      const defaultMarker = p.isDefault ? ' ‚≠ê' : '';\n      const providerTag = `${p.provider}:${tag}`;\n      console.log(\n        `  ‚Ä¢ ${tag.padEnd(15)} (${providerTag.padEnd(20)}) ‚Üí ${\n          p.providerName\n        }${defaultMarker}: ${p.model}`\n      );\n    } else {\n      // Multiple providers - show as list with provider:tag syntax\n      console.log(`  ‚Ä¢ ${tag.padEnd(15)} ‚Üí [${providers.length} providers]`);\n      for (const p of providers) {\n        const defaultMarker = p.isDefault ? ' ‚≠ê' : '';\n        const providerTag = `${p.provider}:${tag}`;\n        console.log(\n          `      - ${providerTag.padEnd(20)} ‚Üí ${\n            p.providerName\n          }${defaultMarker}: ${p.model}`\n        );\n      }\n    }\n  }\n\n  // Show aliases if any\n  if (filteredAliases.length > 0) {\n    console.log('\\nüîó Aliases:');\n    for (const alias of filteredAliases) {\n      const providerName = alias.providerName || alias.provider;\n      if (alias.model) {\n        console.log(`  ‚Ä¢ ${alias.alias} ‚Üí ${providerName}:${alias.model}`);\n      } else if (alias.tag && alias.resolvedModel) {\n        console.log(\n          `  ‚Ä¢ ${alias.alias} ‚Üí ${providerName}:${alias.tag} (${alias.resolvedModel})`\n        );\n      } else if (alias.tag) {\n        console.log(`  ‚Ä¢ ${alias.alias} ‚Üí ${providerName}:${alias.tag}`);\n      }\n    }\n  }\n\n  console.log('\\nüí° Usage Examples:');\n  console.log('  # Use a tag (with resolution):');\n  console.log('  anygpt chat --tag sonnet \"Hello\"');\n  console.log('  anygpt chat --tag opus \"Hello\"');\n  console.log();\n  console.log('  # Use provider:tag syntax (recommended for clarity):');\n  console.log('  anygpt chat --tag provider1:sonnet \"Hello\"');\n  console.log('  anygpt chat --tag provider2:gemini \"Hello\"');\n  console.log();\n  console.log('  # Or specify provider separately:');\n  console.log('  anygpt chat --provider provider1 --tag sonnet \"Hello\"');\n  console.log();\n  console.log('  # Use direct model name (no resolution):');\n  console.log(\n    '  anygpt chat --model \"ml-asset:static-model/claude-sonnet-4-5\" \"Hello\"'\n  );\n  console.log();\n\n  const totalTags = new Set(filteredTags.map((t) => t.tag)).size;\n  console.log(\n    `‚úÖ Found ${totalTags} unique tag${totalTags !== 1 ? 's' : ''} across ${\n      tagsByProvider.size\n    } provider${tagsByProvider.size !== 1 ? 's' : ''}\\n`\n  );\n}\n","/**\n * Model selection logic for benchmarking\n */\n\nimport { resolveModelConfig } from '@anygpt/config';\nimport type { CLIContext } from '../../utils/cli-context.js';\nimport type { BenchmarkOptions, ModelToTest } from './types.js';\n\n/**\n * Select models to benchmark based on options\n */\nexport async function selectModels(\n  context: CLIContext,\n  options: BenchmarkOptions\n): Promise<ModelToTest[]> {\n  const { router, providers } = context;\n\n  if (options.models) {\n    return selectFromModelsList(options);\n  } else if (options.model && options.provider) {\n    return selectSingleModel(options);\n  } else if (options.provider) {\n    return await selectFromProvider(context, options);\n  } else if (options.all) {\n    return await selectFromAllProviders(context, options);\n  } else {\n    // No provider specified: use default provider (same as --provider=<default>)\n    return await selectDefaultModels(context, options);\n  }\n}\n\n/**\n * Parse --models flag (comma-separated list)\n */\nfunction selectFromModelsList(options: BenchmarkOptions): ModelToTest[] {\n  const modelsToTest: ModelToTest[] = [];\n\n  if (options.provider) {\n    // If --provider is also specified, treat --models as comma-separated model IDs for that provider\n    const modelIds = options.models!.split(',').map((m) => m.trim());\n    return modelIds.map((modelId) => ({\n      provider: options.provider!,\n      model: modelId,\n    }));\n  } else {\n    // Parse comma-separated list of model specs: \"provider:model,provider:model\"\n    // Note: model IDs can contain colons (e.g., anthropic::2024-10-22::claude-sonnet-4-latest)\n    // So we split on comma first, then split on FIRST colon only\n    const modelSpecs = options.models!.split(',');\n    for (const spec of modelSpecs) {\n      const trimmed = spec.trim();\n      const colonIndex = trimmed.indexOf(':');\n      if (colonIndex > 0) {\n        const provider = trimmed.substring(0, colonIndex);\n        const model = trimmed.substring(colonIndex + 1);\n        modelsToTest.push({ provider, model });\n      }\n    }\n  }\n\n  return modelsToTest;\n}\n\n/**\n * Select single model (--model and --provider)\n */\nfunction selectSingleModel(options: BenchmarkOptions): ModelToTest[] {\n  return [{ provider: options.provider!, model: options.model! }];\n}\n\n/**\n * Select all models from a specific provider\n */\nasync function selectFromProvider(\n  context: CLIContext,\n  options: BenchmarkOptions\n): Promise<ModelToTest[]> {\n  const { router, providers } = context;\n  const provider = options.provider!;\n\n  try {\n    let models = await router.listModels(provider);\n    const providerConfig = providers[provider];\n    const globalRules = context.defaults?.modelRules;\n\n    // Fallback: If connector returned no models, use config-defined models\n    if (models.length === 0 && providerConfig.models) {\n      context.logger.info(\n        `[verbose] Provider '${provider}' connector returned no models. Using ${\n          Object.keys(providerConfig.models).length\n        } models from config.`\n      );\n      models = Object.keys(providerConfig.models).map((id) => ({\n        id,\n        provider,\n        display_name: id,\n        capabilities: {\n          input: { text: true },\n          output: { text: true },\n        },\n      }));\n    }\n\n    // Error if still no models available\n    if (models.length === 0) {\n      throw new Error(\n        `No models available for provider '${provider}'. ` +\n          `The connector does not support listing models and no models are defined in the config. ` +\n          `Please add models to your config under providers.${provider}.models`\n      );\n    }\n\n    // Filter models by enabled status and tags\n    const modelsToTest = models\n      .filter((m) => {\n        const config = resolveModelConfig(\n          m.id,\n          provider,\n          providerConfig,\n          globalRules\n        );\n        // enabled is true by default (undefined means enabled)\n        if (config.enabled === false) return false;\n\n        // Apply tag filtering if specified\n        return applyTagFilter(config.tags || [], options.filterTags);\n      })\n      .map((m) => ({\n        provider,\n        model: m.id,\n      }));\n\n    if (!options.json) {\n      const filterMsg = options.filterTags\n        ? ` (filtered by tags: ${options.filterTags})`\n        : '';\n      console.log(\n        `üîç Filtered to ${modelsToTest.length} enabled models${filterMsg}`\n      );\n    }\n\n    return modelsToTest;\n  } catch (error) {\n    console.error(`Error listing models for provider ${provider}:`, error);\n    process.exit(1);\n  }\n}\n\n/**\n * Select models from all providers\n */\nasync function selectFromAllProviders(\n  context: CLIContext,\n  options: BenchmarkOptions\n): Promise<ModelToTest[]> {\n  const { router, providers } = context;\n  const providerNames = Object.keys(providers);\n  const globalRules = context.defaults?.modelRules;\n  const modelsToTest: ModelToTest[] = [];\n\n  for (const provider of providerNames) {\n    try {\n      const models = await router.listModels(provider);\n      const providerConfig = providers[provider];\n\n      for (const model of models) {\n        // Check if model is enabled via modelRules\n        const config = resolveModelConfig(\n          model.id,\n          provider,\n          providerConfig,\n          globalRules\n        );\n        if (config.enabled === false) continue;\n\n        // Apply tag filtering if specified\n        if (!applyTagFilter(config.tags || [], options.filterTags)) continue;\n\n        modelsToTest.push({ provider, model: model.id });\n      }\n    } catch (error) {\n      console.error(`Skipping provider ${provider}: ${error}`);\n    }\n  }\n\n  return modelsToTest;\n}\n\n/**\n * Select models from the default provider\n * Behaves exactly like --provider=<default_provider>\n */\nasync function selectDefaultModels(\n  context: CLIContext,\n  options: BenchmarkOptions\n): Promise<ModelToTest[]> {\n  const { providers } = context;\n  const defaultProvider = context.defaults?.provider;\n\n  if (!defaultProvider) {\n    console.error('No default provider configured');\n    return [];\n  }\n\n  if (!providers[defaultProvider]) {\n    console.error(`Default provider '${defaultProvider}' not found in config`);\n    return [];\n  }\n\n  // Behave exactly like --provider=<default_provider>\n  return await selectFromProvider(context, { ...options, provider: defaultProvider });\n}\n\n/**\n * Apply tag filtering to a model\n */\nfunction applyTagFilter(modelTags: string[], filterTags?: string): boolean {\n  if (!filterTags) return true;\n\n  const filters = filterTags.split(',').map((t) => t.trim());\n  const includeTags = filters\n    .filter((t) => !t.startsWith('!'))\n    .map((t) => t.toLowerCase());\n  const excludeTags = filters\n    .filter((t) => t.startsWith('!'))\n    .map((t) => t.substring(1).toLowerCase());\n  const tags = modelTags.map((t) => t.toLowerCase());\n\n  // Check exclusions first\n  for (const excludeTag of excludeTags) {\n    if (tags.includes(excludeTag)) {\n      return false; // Exclude this model\n    }\n  }\n\n  // If there are include filters, model must have at least one\n  if (includeTags.length > 0) {\n    return includeTags.some((includeTag) => tags.includes(includeTag));\n  }\n\n  return true;\n}\n","/**\n * Benchmark execution logic (parallel and sequential)\n */\n\nimport { Readable } from 'stream';\nimport { writeFileSync, mkdirSync, existsSync } from 'fs';\nimport { join } from 'path';\nimport { resolveModelConfig } from '@anygpt/config';\nimport type { CLIContext } from '../../utils/cli-context.js';\nimport type {\n  BenchmarkOptions,\n  BenchmarkResult,\n  ModelToTest,\n} from './types.js';\n\n/**\n * Execute benchmark for a single model with iterations\n */\nexport async function benchmarkModel(\n  context: CLIContext,\n  provider: string,\n  model: string,\n  prompt: string,\n  options: BenchmarkOptions,\n  outputDir?: string\n): Promise<BenchmarkResult> {\n  const { router, providers } = context;\n  const iterations = options.iterations || 1;\n  const maxTokens = options.maxTokens;\n  const iterationResults: BenchmarkResult[] = [];\n\n  for (let i = 0; i < iterations; i++) {\n    if (!options.json && iterations > 1) {\n      process.stdout.write(`‚è≥ ${model} (${i + 1}/${iterations}) `);\n    } else if (!options.json) {\n      process.stdout.write(`‚è≥ ${model} `);\n    }\n\n    const startTime = Date.now();\n    let result: BenchmarkResult;\n\n    try {\n      // Resolve model configuration using rule matching\n      const providerConfig = providers[provider];\n      const globalRules = context.defaults?.modelRules;\n      const modelConfig = resolveModelConfig(\n        model,\n        provider,\n        providerConfig,\n        globalRules\n      );\n\n      // CLI flag takes precedence over model config for max_tokens\n      const effectiveMaxTokens = maxTokens ?? modelConfig.max_tokens;\n\n      // Debug logging\n      if (process.env.DEBUG_BENCHMARK) {\n        console.log(`\\n[DEBUG] Calling router.chatCompletion with:`);\n        console.log(`  provider: ${provider}`);\n        console.log(`  model: ${model}`);\n        console.log(`  prompt: ${prompt}`);\n        console.log(`  max_tokens: ${effectiveMaxTokens}`);\n        console.log(`  reasoning: ${JSON.stringify(modelConfig?.reasoning)}`);\n      }\n\n      const response = await router.chatCompletion({\n        provider,\n        model,\n        messages: [{ role: 'user', content: prompt }],\n        ...(effectiveMaxTokens !== undefined && {\n          max_tokens: effectiveMaxTokens,\n        }),\n        ...(modelConfig.useLegacyCompletionAPI !== undefined && {\n          useLegacyCompletionAPI: modelConfig.useLegacyCompletionAPI,\n        }),\n        ...(modelConfig.fallbackToChatCompletion !== undefined && {\n          fallbackToChatCompletion: modelConfig.fallbackToChatCompletion,\n        }),\n        ...(modelConfig.useLegacyMaxTokens !== undefined && {\n          useLegacyMaxTokens: modelConfig.useLegacyMaxTokens,\n        }),\n        ...(modelConfig.reasoning && { reasoning: modelConfig.reasoning }),\n        ...(modelConfig.extra_body && { extra_body: modelConfig.extra_body }),\n      });\n\n      const responseTime = Date.now() - startTime;\n      const responseContent = response.choices[0]?.message?.content || '';\n      const responseSize = responseContent.length;\n\n      result = {\n        provider,\n        model,\n        status: 'success',\n        responseTime,\n        responseSize,\n        tokenUsage: response.usage\n          ? {\n              prompt: response.usage.prompt_tokens,\n              completion: response.usage.completion_tokens,\n              total: response.usage.total_tokens,\n            }\n          : undefined,\n        finishReason: response.choices[0]?.finish_reason,\n        response: responseContent,\n      };\n\n      if (!options.json) {\n        // Clear the line and rewrite with success\n        process.stdout.clearLine(0);\n        process.stdout.cursorTo(0);\n        console.log(`‚úÖ ${model} ${responseTime}ms (${responseSize} chars)`);\n      }\n\n      // Save response to file if output directory specified\n      if (outputDir) {\n        saveResponseToFile(\n          outputDir,\n          provider,\n          model,\n          i + 1,\n          iterations,\n          prompt,\n          result,\n          responseContent\n        );\n      }\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      result = {\n        provider,\n        model,\n        status: 'error',\n        responseTime,\n        responseSize: 0,\n        error: error instanceof Error ? error.message : String(error),\n      };\n\n      if (!options.json) {\n        // Clear the line and rewrite with error\n        process.stdout.clearLine(0);\n        process.stdout.cursorTo(0);\n        console.log(\n          `‚ùå ${model} ${\n            error instanceof Error ? error.message : String(error)\n          }`\n        );\n      }\n    }\n\n    iterationResults.push(result);\n  }\n\n  // Calculate average if multiple iterations\n  return calculateAverageResult(iterationResults, provider, model, iterations);\n}\n\n/**\n * Execute benchmarks in parallel using Readable.from().map()\n */\nexport async function executeParallel(\n  context: CLIContext,\n  modelsToTest: ModelToTest[],\n  prompt: string,\n  options: BenchmarkOptions,\n  outputDir?: string\n): Promise<BenchmarkResult[]> {\n  const concurrency = options.concurrency || 3;\n  const results: BenchmarkResult[] = [];\n\n  if (!options.json) {\n    console.log(`‚ö° Running in parallel mode (concurrency: ${concurrency})\\n`);\n  }\n\n  const stream = Readable.from(modelsToTest).map(\n    async ({ provider, model }) => {\n      return await benchmarkModel(\n        context,\n        provider,\n        model,\n        prompt,\n        options,\n        outputDir\n      );\n    },\n    { concurrency } // CRITICAL: Limit concurrent operations\n  );\n\n  // Collect results from stream\n  for await (const result of stream) {\n    results.push(result);\n  }\n\n  return results;\n}\n\n/**\n * Execute benchmarks sequentially (original behavior)\n */\nexport async function executeSequential(\n  context: CLIContext,\n  modelsToTest: ModelToTest[],\n  prompt: string,\n  options: BenchmarkOptions,\n  outputDir?: string\n): Promise<BenchmarkResult[]> {\n  const results: BenchmarkResult[] = [];\n\n  for (const { provider, model } of modelsToTest) {\n    const result = await benchmarkModel(\n      context,\n      provider,\n      model,\n      prompt,\n      options,\n      outputDir\n    );\n    results.push(result);\n  }\n\n  return results;\n}\n\n/**\n * Calculate average result from multiple iterations\n */\nfunction calculateAverageResult(\n  iterationResults: BenchmarkResult[],\n  provider: string,\n  model: string,\n  iterations: number\n): BenchmarkResult {\n  if (iterations > 1) {\n    const successfulRuns = iterationResults.filter(\n      (r) => r.status === 'success'\n    );\n    if (successfulRuns.length > 0) {\n      const avgTime =\n        successfulRuns.reduce((sum, r) => sum + r.responseTime, 0) /\n        successfulRuns.length;\n      const avgSize =\n        successfulRuns.reduce((sum, r) => sum + r.responseSize, 0) /\n        successfulRuns.length;\n      const avgTokens = successfulRuns[0].tokenUsage\n        ? {\n            prompt: Math.round(\n              successfulRuns.reduce(\n                (sum, r) => sum + (r.tokenUsage?.prompt || 0),\n                0\n              ) / successfulRuns.length\n            ),\n            completion: Math.round(\n              successfulRuns.reduce(\n                (sum, r) => sum + (r.tokenUsage?.completion || 0),\n                0\n              ) / successfulRuns.length\n            ),\n            total: Math.round(\n              successfulRuns.reduce(\n                (sum, r) => sum + (r.tokenUsage?.total || 0),\n                0\n              ) / successfulRuns.length\n            ),\n          }\n        : undefined;\n\n      return {\n        provider,\n        model,\n        status: 'success',\n        responseTime: Math.round(avgTime),\n        responseSize: Math.round(avgSize),\n        tokenUsage: avgTokens,\n        finishReason: successfulRuns[0].finishReason,\n        response: successfulRuns[0].response,\n      };\n    } else {\n      return iterationResults[0]; // Use first error\n    }\n  } else {\n    return iterationResults[0];\n  }\n}\n\n/**\n * Save individual response to file\n */\nfunction saveResponseToFile(\n  outputDir: string,\n  provider: string,\n  model: string,\n  iteration: number,\n  totalIterations: number,\n  prompt: string,\n  result: BenchmarkResult,\n  responseContent: string\n): void {\n  const sanitizedProvider = provider.replace(/[^a-z0-9]/gi, '_');\n  const sanitizedModel = model.replace(/[^a-z0-9]/gi, '_');\n  const filename = `${sanitizedProvider}_${sanitizedModel}_${iteration}.txt`;\n  const filepath = join(outputDir, filename);\n  const fileContent = `# Benchmark Result\nProvider: ${provider}\nModel: ${model}\nIteration: ${iteration}/${totalIterations}\nResponse Time: ${result.responseTime}ms\nResponse Size: ${result.responseSize} chars\nFinish Reason: ${result.finishReason}\n${\n  result.tokenUsage\n    ? `Token Usage: ${result.tokenUsage.prompt} prompt + ${result.tokenUsage.completion} completion = ${result.tokenUsage.total} total`\n    : ''\n}\n\n## Prompt\n${prompt}\n\n## Response\n${responseContent}\n`;\n  writeFileSync(filepath, fileContent, 'utf-8');\n}\n","/**\n * Benchmark results reporting and formatting\n */\n\nimport { writeFileSync } from 'fs';\nimport { join } from 'path';\nimport type { BenchmarkOptions, BenchmarkResult } from './types.js';\n\n/**\n * Output benchmark results in table or JSON format\n */\nexport function outputResults(\n  results: BenchmarkResult[],\n  options: BenchmarkOptions\n): void {\n  if (options.json) {\n    console.log(JSON.stringify(results, null, 2));\n  } else {\n    printResultsTable(results);\n    printSummary(results);\n    printErrorReport(results);\n  }\n}\n\n/**\n * Print results in table format\n */\nfunction printResultsTable(results: BenchmarkResult[]): void {\n  console.log('\\nüìä Benchmark Results:\\n');\n\n  // Sort by response time (successful ones first)\n  const sortedResults = [...results].sort((a, b) => {\n    if (a.status === 'success' && b.status === 'error') return -1;\n    if (a.status === 'error' && b.status === 'success') return 1;\n    return a.responseTime - b.responseTime;\n  });\n\n  // Calculate column widths dynamically\n  const maxProviderLen = Math.max(\n    ...sortedResults.map((r) => r.provider.length),\n    8\n  );\n  const maxModelLen = Math.max(...sortedResults.map((r) => r.model.length), 5);\n  const providerWidth = Math.min(maxProviderLen, 20);\n  const modelWidth = Math.min(maxModelLen, 60);\n  const totalWidth = providerWidth + modelWidth + 40; // +40 for other columns and padding\n\n  // Print table header\n  const headerLine = '‚îÄ'.repeat(totalWidth);\n  console.log(`‚îå${headerLine}‚îê`);\n  console.log(\n    `‚îÇ ${'Provider'.padEnd(providerWidth)} ‚îÇ ${'Model'.padEnd(\n      modelWidth\n    )} ‚îÇ Status ‚îÇ  Time   ‚îÇ  Size ‚îÇ Tokens ‚îÇ`\n  );\n  console.log(`‚îú${headerLine}‚î§`);\n\n  for (const result of sortedResults) {\n    const provider = result.provider\n      .substring(0, providerWidth)\n      .padEnd(providerWidth);\n    const model = result.model.substring(0, modelWidth).padEnd(modelWidth);\n    const status = result.status === 'success' ? '‚úÖ OK ' : '‚ùå ERR';\n    const time = `${result.responseTime}ms`.padEnd(7);\n    const size = `${result.responseSize}ch`.padEnd(5);\n    const tokens = result.tokenUsage\n      ? `${result.tokenUsage.total}`.padEnd(6)\n      : '-'.padEnd(6);\n\n    console.log(\n      `‚îÇ ${provider} ‚îÇ ${model} ‚îÇ ${status} ‚îÇ ${time} ‚îÇ ${size} ‚îÇ ${tokens} ‚îÇ`\n    );\n  }\n\n  console.log(`‚îî${headerLine}‚îò`);\n}\n\n/**\n * Print summary statistics\n */\nfunction printSummary(results: BenchmarkResult[]): void {\n  const successful = results.filter((r) => r.status === 'success');\n  const failed = results.filter((r) => r.status === 'error');\n\n  if (successful.length > 0) {\n    const fastest = successful.reduce((min, r) =>\n      r.responseTime < min.responseTime ? r : min\n    );\n    const slowest = successful.reduce((max, r) =>\n      r.responseTime > max.responseTime ? r : max\n    );\n\n    console.log('\\nüìà Summary:');\n    console.log(`  Total: ${results.length} models`);\n    console.log(`  Successful: ${successful.length}`);\n    console.log(`  Failed: ${failed.length}`);\n    console.log(\n      `  Fastest: ${fastest.responseTime}ms (${fastest.provider}:${fastest.model})`\n    );\n    console.log(\n      `  Slowest: ${slowest.responseTime}ms (${slowest.provider}:${slowest.model})`\n    );\n    console.log(\n      `  Average: ${Math.round(\n        successful.reduce((sum, r) => sum + r.responseTime, 0) /\n          successful.length\n      )}ms`\n    );\n  }\n}\n\n/**\n * Print error report for failed models\n */\nfunction printErrorReport(results: BenchmarkResult[]): void {\n  const failed = results.filter((r) => r.status === 'error');\n\n  if (failed.length > 0) {\n    console.log('\\n‚ùå Error Report:\\n');\n    for (const result of failed) {\n      console.log(`  ${result.provider}:${result.model}`);\n      console.log(`    ${result.error}`);\n      console.log('');\n    }\n  }\n}\n\n/**\n * Save summary JSON to file\n */\nexport function saveSummaryJson(\n  outputDir: string,\n  prompt: string,\n  maxTokens: number | undefined,\n  iterations: number,\n  results: BenchmarkResult[]\n): void {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const summaryFile = join(outputDir, `benchmark-summary-${timestamp}.json`);\n  const summary = {\n    timestamp: new Date().toISOString(),\n    prompt,\n    maxTokens,\n    iterations,\n    totalModels: results.length,\n    successful: results.filter((r) => r.status === 'success').length,\n    failed: results.filter((r) => r.status === 'error').length,\n    results: results.map((r) => ({\n      provider: r.provider,\n      model: r.model,\n      status: r.status,\n      responseTime: r.responseTime,\n      responseSize: r.responseSize,\n      tokenUsage: r.tokenUsage,\n      finishReason: r.finishReason,\n      error: r.error,\n      // Include first 200 chars of response for preview\n      responsePreview: r.response ? r.response.substring(0, 200) : undefined,\n    })),\n  };\n  writeFileSync(summaryFile, JSON.stringify(summary, null, 2), 'utf-8');\n  console.log(`\\nüíæ Summary saved to: ${summaryFile}`);\n}\n","/**\n * Benchmark command - Main orchestration\n */\n\nimport { mkdirSync, existsSync } from 'fs';\nimport type { CLIContext } from '../../utils/cli-context.js';\nimport type { BenchmarkOptions } from './types.js';\nimport { selectModels } from './model-selector.js';\nimport { executeParallel, executeSequential } from './executor.js';\nimport { outputResults, saveSummaryJson } from './reporter.js';\n\nexport async function benchmarkCommand(\n  context: CLIContext,\n  options: BenchmarkOptions\n) {\n  // Get prompt from stdin, option, or default\n  const prompt = await getPrompt(options);\n\n  // Select models to benchmark\n  const modelsToTest = await selectModels(context, options);\n\n  if (modelsToTest.length === 0) {\n    console.error(\n      'No models to benchmark. Specify --provider, --model, --models, or --all'\n    );\n    process.exit(1);\n  }\n\n  const iterations = options.iterations || 1;\n  const maxTokens = options.maxTokens;\n\n  // Create output directory if specified\n  let outputDir: string | undefined;\n  if (options.output) {\n    outputDir = options.output;\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n    if (!options.json) {\n      console.log(`üìÅ Output directory: ${outputDir}\\n`);\n    }\n  }\n\n  // Print benchmark header\n  if (!options.json) {\n    console.log(\n      `üî¨ Benchmarking ${modelsToTest.length} model(s) with ${iterations} iteration(s)\\n`\n    );\n    console.log(`Prompt: \"${prompt}\"`);\n    if (maxTokens !== undefined) {\n      console.log(`Max tokens: ${maxTokens}`);\n    }\n    console.log();\n  }\n\n  // Execute benchmarks (parallel or sequential)\n  const results = options.parallel\n    ? await executeParallel(context, modelsToTest, prompt, options, outputDir)\n    : await executeSequential(\n        context,\n        modelsToTest,\n        prompt,\n        options,\n        outputDir\n      );\n\n  // Save summary JSON if output directory specified\n  if (outputDir && !options.json) {\n    saveSummaryJson(outputDir, prompt, maxTokens, iterations, results);\n  }\n\n  // Output results\n  outputResults(results, options);\n}\n\n/**\n * Get prompt from stdin, option, or default\n */\nasync function getPrompt(options: BenchmarkOptions): Promise<string> {\n  let prompt = options.prompt;\n\n  // Auto-detect stdin if it's piped (not a TTY) or if --stdin flag is set\n  const hasStdin = options.stdin || (!process.stdin.isTTY && !options.prompt);\n\n  if (hasStdin) {\n    const chunks: Buffer[] = [];\n    for await (const chunk of process.stdin) {\n      chunks.push(chunk);\n    }\n    prompt = Buffer.concat(chunks).toString('utf-8').trim();\n  }\n\n  if (!prompt) {\n    prompt = 'What is 2+2? Answer in one sentence.';\n  }\n\n  return prompt;\n}\n","import { DiscoveryEngine } from '@anygpt/mcp-discovery';\nimport type { CLIContext } from '../../utils/cli-context.js';\n\ninterface SearchOptions {\n  server?: string;\n  limit?: number;\n  json?: boolean;\n}\n\n/**\n * Search for tools across all MCP servers\n */\nexport async function mcpSearchCommand(\n  context: CLIContext,\n  query: string,\n  options: SearchOptions\n): Promise<void> {\n  const { config, logger } = context;\n\n  // Initialize discovery engine\n  const discoveryConfig = config.discovery || {\n    enabled: true,\n    cache: { enabled: true, ttl: 3600 },\n  };\n\n  const engine = new DiscoveryEngine(discoveryConfig, config.mcp?.servers);\n\n  try {\n    // Search for tools\n    const results = await engine.searchTools(query, {\n      server: options.server,\n      limit: options.limit || 10,\n    });\n\n    if (options.json) {\n      console.log(JSON.stringify(results, null, 2));\n      return;\n    }\n\n    // Human-friendly output\n    if (results.length === 0) {\n      console.log(`\\nNo tools found matching \"${query}\"`);\n      if (options.server) {\n        console.log(`  (searched in server: ${options.server})`);\n      }\n      return;\n    }\n\n    console.log(`\\nüîç Search Results for \"${query}\" (${results.length})\\n`);\n\n    for (const result of results) {\n      console.log(`  ${result.tool}`);\n      console.log(`    ${result.summary}`);\n\n      // Only show relevance if it exists\n      if (result.relevance !== undefined && result.relevance !== null) {\n        console.log(`    Relevance: ${result.relevance.toFixed(2)}`);\n      }\n\n      if (result.tags && result.tags.length > 0) {\n        console.log(`    Tags: ${result.tags.join(', ')}`);\n      }\n\n      console.log('');\n    }\n  } catch (error) {\n    logger.error('Failed to search tools:', error);\n    throw error;\n  } finally {\n    // Always cleanup: disconnect from all MCP servers\n    await engine.dispose();\n  }\n}\n","import { DiscoveryEngine } from '@anygpt/mcp-discovery';\nimport type { ServerProgress } from '@anygpt/mcp-discovery';\nimport type { CLIContext } from '../../utils/cli-context.js';\nimport logUpdate from 'log-update';\nimport chalk from 'chalk';\n\ninterface InspectOptions {\n  server?: string;\n  tools?: boolean; // Show tools when inspecting server or listing all\n  compact?: boolean; // Compact tool format\n  args?: boolean; // Show detailed parameter schemas\n  examples?: boolean; // Show usage examples\n  enabled?: boolean; // Filter: only enabled servers\n  disabled?: boolean; // Filter: only disabled servers\n  all?: boolean; // Filter: all servers (default)\n  json?: boolean;\n}\n\n/**\n * Unified inspect command:\n * - No target: List all servers (like old mcp list)\n * - <server> target: Inspect server config + tools (like old mcp tools)\n * - <tool> target: Inspect tool details (old mcp inspect)\n */\nexport async function mcpInspectCommand(\n  context: CLIContext,\n  target?: string,\n  options: InspectOptions = {}\n): Promise<void> {\n  const { config, logger } = context;\n\n  // Initialize discovery engine\n  const discoveryConfig = config.discovery || {\n    enabled: true,\n    cache: { enabled: true, ttl: 3600 },\n  };\n\n  const engine = new DiscoveryEngine(discoveryConfig, config.mcp?.servers);\n\n  try {\n    // Case 1: --server flag provided (inspect specific server)\n    if (options.server && !target) {\n      await inspectServer(engine, config, options.server, options);\n      return;\n    }\n\n    // Case 2: No target (list all servers)\n    if (!target) {\n      await listAllServers(engine, config, options);\n      return;\n    }\n\n    // Case 3: Target provided - need to resolve if it's a server or tool\n    await resolveAndInspect(engine, config, target, options);\n  } catch (error) {\n    logUpdate.clear();\n    logger.error('Failed to inspect:', error);\n    throw error;\n  } finally {\n    // Always cleanup: disconnect from all MCP servers\n    await engine.dispose();\n\n    // Force exit if process is hanging\n    setTimeout(() => {\n      if (!process.exitCode) {\n        process.exit(0);\n      }\n    }, 100);\n  }\n}\n\n/**\n * List all servers (Case 1: no target)\n */\nasync function listAllServers(\n  engine: DiscoveryEngine,\n  config: unknown,\n  options: InspectOptions\n): Promise<void> {\n  const allServerNames = Object.keys(config.mcp?.servers || {});\n  const serverNames = allServerNames.filter((name) => {\n    const serverConfig = config.mcp?.servers?.[name];\n    const isDisabled = serverConfig?.enabled === false;\n\n    if (options.enabled) return !isDisabled;\n    if (options.disabled) return isDisabled;\n    return true;\n  });\n\n  const serverCount = serverNames.length;\n  const serverStatus = new Map<\n    string,\n    {\n      status: string;\n      error?: string;\n      toolCount?: number;\n    }\n  >();\n\n  // Handle Ctrl+C gracefully\n  const cleanup = () => {\n    logUpdate.clear();\n    engine.dispose().catch(() => {\n      /* ignore */\n    });\n    process.exit(130);\n  };\n\n  process.once('SIGINT', cleanup);\n  process.once('SIGTERM', cleanup);\n\n  // Render dashboard during progress\n  const renderDashboard = () => {\n    const lines = ['\\nüì¶ MCP Servers\\n'];\n\n    for (const name of serverNames) {\n      const status = serverStatus.get(name);\n\n      let icon = 'üü°';\n      let statusText = 'Waiting...';\n\n      if (status) {\n        if (status.status === 'connecting') {\n          icon = 'üü°';\n          statusText = 'Connecting...';\n        } else if (status.status === 'discovering') {\n          icon = 'üü°';\n          statusText = 'Discovering...';\n        } else if (status.status === 'connected') {\n          icon = 'üü¢';\n          statusText = `${status.toolCount} tools`;\n        } else if (status.status === 'error') {\n          icon = 'üî¥';\n          statusText = 'unavailable';\n        }\n      }\n\n      const serverConfig = config.mcp?.servers?.[name];\n      const source = serverConfig?.source;\n      const isDisabled = serverConfig?.enabled === false;\n\n      if (isDisabled) {\n        icon = '‚ö™';\n        const toolCount = serverConfig?.metadata?.toolCount;\n        statusText =\n          toolCount !== undefined\n            ? chalk.gray(`${toolCount} tools (disabled)`)\n            : chalk.gray('disabled');\n      }\n\n      const plainTextName = source ? `${name}(${source})` : name;\n      const paddingNeeded = Math.max(0, 45 - plainTextName.length);\n\n      const serverNameWithSource = source\n        ? `${name}${chalk.gray(`(${source})`)}`\n        : name;\n      const serverName = isDisabled\n        ? chalk.gray(serverNameWithSource)\n        : chalk.bold.cyan(serverNameWithSource);\n\n      lines.push(\n        `  ${icon} ${serverName}${' '.repeat(paddingNeeded)} ${statusText}`\n      );\n\n      if (status?.status === 'error' && status.error && !isDisabled) {\n        const errorLines = status.error\n          .split('\\n')\n          .map((line) => (line.trim() ? chalk.red(`     ${line}`) : ''))\n          .filter((line) => line);\n\n        lines.push(...errorLines);\n\n        const cmd = `${serverConfig.command} ${\n          serverConfig.args?.join(' ') || ''\n        }`.trim();\n        lines.push(chalk.gray(`     Command: ${cmd}`));\n      }\n    }\n\n    const disabledCount = serverNames.filter((name) => {\n      const serverConfig = config.mcp?.servers?.[name];\n      return serverConfig?.enabled === false;\n    }).length;\n\n    const completed = Array.from(serverStatus.values()).filter(\n      (s) => s.status === 'connected' || s.status === 'error'\n    ).length;\n    const connected = Array.from(serverStatus.values()).filter(\n      (s) => s.status === 'connected'\n    ).length;\n\n    if (completed < serverCount) {\n      lines.push(`\\n  Progress: ${completed}/${serverCount}`);\n    } else {\n      const actualFailed = serverCount - connected - disabledCount;\n      const totalActive = serverCount - disabledCount;\n\n      if (options.disabled && disabledCount > 0) {\n        lines.push(\n          `\\n  ${chalk.gray(\n            `${disabledCount} disabled ${\n              disabledCount === 1 ? 'server' : 'servers'\n            }`\n          )}`\n        );\n      } else if (options.enabled) {\n        if (actualFailed === 0) {\n          lines.push(`\\n  ${chalk.green(`‚úì All ${connected} servers loaded`)}`);\n        } else {\n          lines.push(\n            `\\n  ${chalk.yellow(\n              `‚ö† ${connected}/${totalActive} servers loaded`\n            )} ${chalk.gray(`(${actualFailed} failed)`)}`\n          );\n        }\n      } else {\n        if (actualFailed === 0 && disabledCount === 0) {\n          lines.push(\n            `\\n  ${chalk.green(`‚úì All ${serverCount} servers loaded`)}`\n          );\n        } else if (actualFailed === 0 && disabledCount > 0) {\n          lines.push(\n            `\\n  ${chalk.green(\n              `‚úì All ${totalActive} servers loaded`\n            )} ${chalk.gray(`(${disabledCount} disabled)`)}`\n          );\n        } else {\n          const failedText =\n            actualFailed > 0 ? chalk.gray(`${actualFailed} failed`) : '';\n          const disabledText =\n            disabledCount > 0 ? chalk.gray(`${disabledCount} disabled`) : '';\n          const parts = [failedText, disabledText].filter(Boolean).join(', ');\n          lines.push(\n            `\\n  ${chalk.yellow(\n              `‚ö† ${connected}/${totalActive} servers loaded`\n            )} ${chalk.gray(`(${parts})`)}`\n          );\n        }\n      }\n    }\n\n    logUpdate(lines.join('\\n'));\n  };\n\n  renderDashboard();\n\n  await engine.initialize((progress: ServerProgress) => {\n    serverStatus.set(progress.server, {\n      status: progress.status,\n      error: progress.error,\n      toolCount: progress.toolCount,\n    });\n    renderDashboard();\n  });\n\n  const servers = await engine.listServers();\n\n  process.removeAllListeners('SIGINT');\n  process.removeAllListeners('SIGTERM');\n\n  renderDashboard();\n\n  if (options.json) {\n    logUpdate.clear();\n    console.log(JSON.stringify(servers, null, 2));\n    return;\n  }\n\n  if (servers.length === 0) {\n    logUpdate.clear();\n    console.log('No MCP servers configured.');\n    console.log(\n      '\\nTo add MCP servers, configure them in your AnyGPT config file.'\n    );\n    return;\n  }\n\n  // Show tools if --tools flag is used\n  if (options.tools) {\n    console.log('');\n    for (const server of servers) {\n      if (server.status === 'connected') {\n        const tools = await engine.listTools(server.name, true);\n        if (tools.length > 0) {\n          const enabledCount = tools.filter((t) => t.enabled).length;\n          const totalCount = tools.length;\n\n          console.log(`  ${chalk.bold.cyan(server.name)}:`);\n\n          if (options.compact) {\n            const statsText =\n              enabledCount === totalCount\n                ? chalk.green(`(${enabledCount}/${totalCount} enabled)`)\n                : chalk.yellow(`(${enabledCount}/${totalCount} enabled)`);\n\n            const toolNames = tools.map((t) =>\n              t.enabled ? t.name : chalk.gray(t.name)\n            );\n            console.log(`     ${toolNames.join(', ')} ` + statsText);\n          } else {\n            const statsText =\n              enabledCount === totalCount\n                ? chalk.green(`(${enabledCount}/${totalCount} enabled)`)\n                : chalk.yellow(`(${enabledCount}/${totalCount} enabled)`);\n            console.log(`     ${statsText}`);\n\n            for (const tool of tools) {\n              const toolName = tool.enabled\n                ? chalk.white(tool.name)\n                : chalk.gray(tool.name);\n              const description =\n                tool.description || tool.summary || 'No description';\n              console.log(`       ‚Ä¢ ${toolName}`);\n              console.log(chalk.gray(`         ${description}`));\n            }\n          }\n          console.log('');\n        }\n      }\n    }\n  }\n}\n\n/**\n * Initialize engine with timeout\n */\nasync function initializeWithTimeout(\n  engine: DiscoveryEngine,\n  timeoutMs = 10000\n): Promise<void> {\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    setTimeout(() => reject(new Error('Initialization timeout')), timeoutMs);\n  });\n\n  try {\n    await Promise.race([engine.initialize(), timeoutPromise]);\n  } catch (error) {\n    if (error instanceof Error && error.message === 'Initialization timeout') {\n      console.log(\n        chalk.yellow(\n          '\\n‚ö† Initialization timed out after 10s, showing available servers only\\n'\n        )\n      );\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Inspect specific server (Case 2: --server or server target)\n */\nasync function inspectServer(\n  engine: DiscoveryEngine,\n  config: unknown,\n  serverName: string,\n  options: InspectOptions\n): Promise<void> {\n  // Initialize silently with timeout\n  process.stdout.write('üîÑ Initializing MCP servers...');\n  await initializeWithTimeout(engine);\n  process.stdout.write('\\r\\x1b[K');\n\n  const serverConfig = config.mcp?.servers?.[serverName];\n  if (!serverConfig) {\n    console.log(`\\n‚úó Server \"${serverName}\" not found in configuration\\n`);\n    return;\n  }\n\n  if (options.json) {\n    const tools = await engine.listTools(serverName, true);\n    console.log(\n      JSON.stringify(\n        { server: serverName, config: serverConfig, tools },\n        null,\n        2\n      )\n    );\n    return;\n  }\n\n  // Human-friendly output\n  console.log(`\\nüì¶ Server: ${chalk.bold.cyan(serverName)}\\n`);\n\n  const isDisabled = serverConfig.enabled === false;\n  console.log(\n    `  Status: ${isDisabled ? chalk.gray('disabled') : chalk.green('enabled')}`\n  );\n\n  // Show full command line\n  const fullCommand =\n    serverConfig.args && serverConfig.args.length > 0\n      ? `${serverConfig.command} ${serverConfig.args.join(' ')}`\n      : serverConfig.command;\n  console.log(`  Command: ${fullCommand}`);\n\n  if (serverConfig.source) {\n    console.log(`  Source: ${chalk.gray(serverConfig.source)}`);\n  }\n\n  // Show tools if requested or by default\n  if (options.tools !== false) {\n    try {\n      const tools = await engine.listTools(serverName, true);\n\n      if (tools.length === 0) {\n        console.log(`\\n  No tools available`);\n      } else {\n        const enabledCount = tools.filter((t) => t.enabled).length;\n        const totalCount = tools.length;\n\n        console.log(`\\n  Tools (${enabledCount}/${totalCount} enabled):\\n`);\n\n        for (const tool of tools) {\n          const toolName = tool.enabled\n            ? chalk.white(tool.name)\n            : chalk.gray(tool.name);\n          const description =\n            tool.description || tool.summary || 'No description';\n          console.log(`    ‚Ä¢ ${toolName}`);\n          console.log(chalk.gray(`      ${description}`));\n        }\n      }\n    } catch (error) {\n      console.log(`\\n  ${chalk.red('Failed to load tools')}`);\n      if (error instanceof Error) {\n        console.log(chalk.gray(`  ${error.message}`));\n      }\n    }\n  }\n\n  console.log('');\n}\n\n/**\n * Inspect specific tool (Case 3: tool target)\n */\nasync function inspectTool(\n  engine: DiscoveryEngine,\n  toolName: string,\n  serverName: string,\n  options: InspectOptions\n): Promise<void> {\n  const tool = await engine.getToolDetails(serverName, toolName);\n\n  if (!tool) {\n    console.log(`\\nTool \"${toolName}\" not found in server \"${serverName}\"`);\n    return;\n  }\n\n  if (options.json) {\n    console.log(JSON.stringify(tool, null, 2));\n    return;\n  }\n\n  // Human-friendly output\n  console.log(`\\nüîç Tool: ${chalk.bold.cyan(tool.name)}\\n`);\n  console.log(`  Server: ${tool.server}`);\n\n  const description = tool.description || tool.summary;\n  if (description) {\n    console.log(`  Description: ${description}`);\n  }\n\n  console.log(\n    `  Enabled: ${tool.enabled ? chalk.green('‚úì Yes') : chalk.gray('‚úó No')}`\n  );\n\n  if (tool.tags.length > 0) {\n    console.log(`  Tags: ${tool.tags.join(', ')}`);\n  }\n\n  // Parameters (always show by default)\n  if (tool.parameters && tool.parameters.length > 0) {\n    console.log(`\\n  Parameters:`);\n    for (const param of tool.parameters) {\n      const required = param.required\n        ? chalk.yellow('(required)')\n        : chalk.gray('(optional)');\n      console.log(\n        `    ‚Ä¢ ${chalk.white(param.name)}: ${chalk.cyan(\n          param.type\n        )} ${required}`\n      );\n      if (param.description) {\n        console.log(chalk.gray(`      ${param.description}`));\n      }\n      // Show defaults by default (not just with --args)\n      if (param.default !== undefined) {\n        console.log(\n          chalk.gray(`      Default: ${JSON.stringify(param.default)}`)\n        );\n      }\n    }\n  }\n\n  // Examples (only with --examples)\n  if (options.examples && tool.examples && tool.examples.length > 0) {\n    console.log(`\\n  Examples:`);\n    for (const example of tool.examples) {\n      console.log(`    ${example.description}`);\n      console.log(\n        `    Parameters: ${JSON.stringify(example.parameters, null, 2)}`\n      );\n      console.log('');\n    }\n  }\n\n  console.log('');\n}\n\n/**\n * Resolve target and inspect (Case 3: target provided)\n */\nasync function resolveAndInspect(\n  engine: DiscoveryEngine,\n  config: unknown,\n  target: string,\n  options: InspectOptions\n): Promise<void> {\n  // Initialize silently with timeout\n  process.stdout.write('üîÑ Initializing MCP servers...');\n  await initializeWithTimeout(engine);\n  process.stdout.write('\\r\\x1b[K');\n\n  // Check if target is a server name\n  const serverConfig = config.mcp?.servers?.[target];\n  if (serverConfig) {\n    // Target is a server\n    await inspectServer(engine, config, target, options);\n    return;\n  }\n\n  // Target might be a tool - search for it\n  let resolvedServer: string | undefined;\n\n  if (options.server) {\n    // Server explicitly provided via --server flag\n    resolvedServer = options.server;\n  } else {\n    // Auto-resolve: search for tool across all servers\n    process.stdout.write('üîç Searching for tool across servers...');\n    const allServers = await engine.listServers();\n    process.stdout.write('\\r\\x1b[K');\n    const matchingTools: Array<{ server: string; tool: string }> = [];\n\n    for (const server of allServers) {\n      if (server.status === 'connected') {\n        const tools = await engine.listTools(server.name, false);\n        const exactMatch = tools.find((t) => t.name === target);\n        if (exactMatch) {\n          matchingTools.push({ server: server.name, tool: target });\n        }\n      }\n    }\n\n    if (matchingTools.length === 1) {\n      resolvedServer = matchingTools[0].server;\n      console.log(\n        `\\n${chalk.gray(`Auto-resolved from server \"${resolvedServer}\"`)}`\n      );\n    } else if (matchingTools.length > 1) {\n      console.log(\n        `\\n${chalk.yellow(\n          '‚ö† Ambiguous:'\n        )} \"${target}\" matches multiple items:\\n`\n      );\n      for (const match of matchingTools) {\n        console.log(\n          `  ${chalk.cyan('Tool:')} ${target} ${chalk.gray(\n            `(server: ${match.server})`\n          )}`\n        );\n      }\n      console.log(\n        `\\n${chalk.gray('Use:')} anygpt mcp inspect ${target} --server=<name>\\n`\n      );\n      return;\n    } else {\n      console.log(\n        `\\n${chalk.red('‚úó')} \"${target}\" not found (not a server or tool)\\n`\n      );\n      return;\n    }\n  }\n\n  // Inspect the tool\n  await inspectTool(engine, target, resolvedServer, options);\n}\n","import { DiscoveryEngine } from '@anygpt/mcp-discovery';\nimport type { CLIContext } from '../../utils/cli-context.js';\n\ninterface ExecuteOptions {\n  server?: string;\n  args?: string;\n  json?: boolean;\n  stream?: boolean;\n}\n\n/**\n * Execute a tool from any discovered MCP server\n */\nexport async function mcpExecuteCommand(\n  context: CLIContext,\n  toolName: string,\n  argsOrOptions: string[] | ExecuteOptions,\n  optionsIfArgs?: ExecuteOptions\n): Promise<void> {\n  // Handle both signatures:\n  // 1. execute <tool> arg1 arg2 arg3 --options (args array + options)\n  // 2. execute <tool> --options (just options)\n  let positionalArgs: string[];\n  let options: ExecuteOptions;\n\n  if (Array.isArray(argsOrOptions)) {\n    // Positional args provided\n    positionalArgs = argsOrOptions;\n    options = optionsIfArgs || {};\n  } else {\n    // No positional args\n    positionalArgs = [];\n    options = argsOrOptions;\n  }\n\n  const serverName = options.server; // Optional - will auto-resolve if not provided\n\n  const { config, logger } = context;\n\n  // Initialize discovery engine\n  const discoveryConfig = config.discovery || {\n    enabled: true,\n    cache: { enabled: true, ttl: 3600 },\n  };\n\n  const engine = new DiscoveryEngine(discoveryConfig, config.mcp?.servers);\n\n  try {\n    // Initialize engine first with progress\n    process.stdout.write('üîÑ Initializing MCP servers...');\n    await engine.initialize();\n    process.stdout.write('\\r\\x1b[K'); // Clear line\n\n    // Auto-resolve server if not provided\n    let resolvedServer: string;\n\n    if (serverName) {\n      // Server explicitly provided via --server flag\n      resolvedServer = serverName;\n    } else {\n      // Auto-resolve: search for tool across all servers\n      process.stdout.write('üîç Searching for tool across servers...');\n      const allServers = await engine.listServers();\n      process.stdout.write('\\r\\x1b[K'); // Clear line\n      const matchingTools: Array<{ server: string; tool: string }> = [];\n\n      for (const server of allServers) {\n        if (server.status === 'connected') {\n          const tools = await engine.listTools(server.name, false);\n          const exactMatch = tools.find((t) => t.name === toolName);\n          if (exactMatch) {\n            matchingTools.push({ server: server.name, tool: toolName });\n          }\n        }\n      }\n\n      // If exactly one match, auto-resolve\n      if (matchingTools.length === 1) {\n        resolvedServer = matchingTools[0].server;\n        console.log(\n          `\\nüîç Auto-resolved tool \"${toolName}\" from server \"${resolvedServer}\"\\n`\n        );\n      } else if (matchingTools.length > 1) {\n        console.log(`\\n‚ö† Multiple servers provide tool \"${toolName}\":\\n`);\n        for (const match of matchingTools) {\n          console.log(`  - ${match.server}`);\n        }\n        console.log(\n          `\\nPlease specify the server: npx anygpt mcp execute ${toolName} --server <server-name>\\n`\n        );\n        return;\n      } else {\n        console.log(\n          `\\n‚úó Tool \"${toolName}\" not found on any connected server\\n`\n        );\n        return;\n      }\n    }\n\n    // Parse arguments - do this after server resolution so we can get tool schema\n    let args: Record<string, unknown> = {};\n    if (options.args) {\n      // --args flag takes precedence\n      try {\n        args = JSON.parse(options.args);\n      } catch (error) {\n        throw new Error(\n          `Invalid JSON arguments: ${\n            error instanceof Error ? error.message : 'Unknown error'\n          }`\n        );\n      }\n    } else if (positionalArgs.length > 0) {\n      // Map positional args to parameter names\n      // Get tool details to find the parameter names\n      const tool = await engine.getToolDetails(resolvedServer, toolName);\n      if (tool && tool.parameters && tool.parameters.length > 0) {\n        // Map each positional arg to corresponding parameter\n        for (\n          let i = 0;\n          i < positionalArgs.length && i < tool.parameters.length;\n          i++\n        ) {\n          const param = tool.parameters[i];\n          args[param.name] = positionalArgs[i];\n        }\n      } else {\n        // Fallback: use common parameter names\n        if (positionalArgs.length > 0) args['query'] = positionalArgs[0];\n        if (positionalArgs.length > 1) args['max_results'] = positionalArgs[1];\n      }\n    }\n\n    // Execute tool\n    const result = await engine.executeTool(resolvedServer, toolName, args);\n\n    if (options.json) {\n      console.log(JSON.stringify(result, null, 2));\n      return;\n    }\n\n    // Human-friendly output\n    if (result.success) {\n      console.log(`\\n‚úì Tool executed successfully\\n`);\n\n      // Format the result based on content type\n      const resultData = result.result;\n\n      // Check if it's MCP content format (array with type/text objects)\n      if (\n        resultData &&\n        typeof resultData === 'object' &&\n        'content' in resultData\n      ) {\n        const content = (\n          resultData as { content: Array<{ type: string; text?: string }> }\n        ).content;\n        if (Array.isArray(content)) {\n          for (const item of content) {\n            if (item.type === 'text' && item.text) {\n              // Print text content directly (already formatted)\n              console.log(item.text);\n            } else {\n              // Other content types - show as JSON\n              console.log(JSON.stringify(item, null, 2));\n            }\n          }\n        } else {\n          console.log(JSON.stringify(resultData, null, 2));\n        }\n      } else {\n        // Not MCP format - show as formatted JSON\n        console.log(JSON.stringify(resultData, null, 2));\n      }\n    } else {\n      console.log(`\\n‚úó Tool execution failed\\n`);\n      if (result.error) {\n        console.log(`Error: ${result.error.message}`);\n        console.log(`Code: ${result.error.code}`);\n        if (result.error.details) {\n          console.log(\n            `Details: ${JSON.stringify(result.error.details, null, 2)}`\n          );\n        }\n      }\n    }\n\n    console.log('');\n  } catch (error) {\n    logger.error('Failed to execute tool:', error);\n    throw error;\n  } finally {\n    // Always cleanup: disconnect from all MCP servers\n    await engine.dispose();\n  }\n}\n","import { DiscoveryEngine } from '@anygpt/mcp-discovery';\nimport type { MCPServerConfig } from '@anygpt/mcp-discovery';\nimport type { CLIContext } from '../../utils/cli-context.js';\n\ninterface ConfigOptions {\n  json?: boolean;\n}\n\n/**\n * Show MCP discovery configuration\n */\nexport async function mcpConfigShowCommand(\n  context: CLIContext,\n  options: ConfigOptions\n): Promise<void> {\n  const { config, logger } = context;\n\n  try {\n    const discoveryConfig = config.discovery || {\n      enabled: true,\n      cache: { enabled: true, ttl: 3600 },\n    };\n\n    if (options.json) {\n      console.log(JSON.stringify(discoveryConfig, null, 2));\n      return;\n    }\n\n    // Human-friendly output\n    console.log(`\\n‚öôÔ∏è  MCP Discovery Configuration\\n`);\n    console.log(`  Enabled: ${discoveryConfig.enabled ? '‚úì Yes' : '‚úó No'}`);\n\n    if (discoveryConfig.cache) {\n      console.log(`\\n  Cache:`);\n      console.log(\n        `    Enabled: ${discoveryConfig.cache.enabled ? '‚úì Yes' : '‚úó No'}`\n      );\n      console.log(`    TTL: ${discoveryConfig.cache.ttl}s`);\n    }\n\n    if (discoveryConfig.sources && discoveryConfig.sources.length > 0) {\n      console.log(`\\n  Sources (${discoveryConfig.sources.length}):`);\n      for (const source of discoveryConfig.sources) {\n        console.log(\n          `    ‚Ä¢ ${source.type}: ${source.path || source.url || 'default'}`\n        );\n      }\n    }\n\n    if (discoveryConfig.toolRules && discoveryConfig.toolRules.length > 0) {\n      console.log(`\\n  Tool Rules (${discoveryConfig.toolRules.length}):`);\n      for (const rule of discoveryConfig.toolRules) {\n        const patterns = Array.isArray(rule.pattern)\n          ? rule.pattern.join(', ')\n          : rule.pattern;\n        const status =\n          rule.enabled === true\n            ? '‚úì enabled'\n            : rule.enabled === false\n            ? '‚úó disabled'\n            : 'default';\n        console.log(`    ‚Ä¢ ${patterns} ‚Üí ${status}`);\n        if (rule.server) {\n          console.log(`      Server: ${rule.server}`);\n        }\n        if (rule.tags && rule.tags.length > 0) {\n          console.log(`      Tags: ${rule.tags.join(', ')}`);\n        }\n      }\n    }\n\n    // Show MCP servers\n    const serverCount = Object.keys(config.mcp?.servers || {}).length;\n    if (serverCount > 0) {\n      console.log(`\\n  MCP Servers (${serverCount}):`);\n      for (const [name, serverConfig] of Object.entries(\n        config.mcp?.servers || {}\n      )) {\n        const cfg = serverConfig as MCPServerConfig;\n        console.log(`    ‚Ä¢ ${name}`);\n        console.log(\n          `      Command: ${cfg.command} ${cfg.args?.join(' ') || ''}`\n        );\n        if (cfg.env && Object.keys(cfg.env).length > 0) {\n          console.log(`      Env vars: ${Object.keys(cfg.env).join(', ')}`);\n        }\n      }\n    } else {\n      console.log(`\\n  MCP Servers: None configured`);\n    }\n\n    console.log('');\n  } catch (error) {\n    logger.error('Failed to show config:', error);\n    throw error;\n  }\n}\n\n/**\n * Validate MCP discovery configuration\n */\nexport async function mcpConfigValidateCommand(\n  context: CLIContext,\n  options: ConfigOptions\n): Promise<void> {\n  const { config, logger } = context;\n\n  const discoveryConfig = config.discovery || {\n    enabled: true,\n    cache: { enabled: true, ttl: 3600 },\n  };\n\n  // Initialize engine to validate config\n  const engine = new DiscoveryEngine(discoveryConfig, config.mcp?.servers);\n\n  try {\n    if (options.json) {\n      console.log(\n        JSON.stringify({ valid: true, config: discoveryConfig }, null, 2)\n      );\n      return;\n    }\n\n    console.log(`\\n‚úì Configuration is valid\\n`);\n  } catch (error) {\n    if (options.json) {\n      console.log(\n        JSON.stringify(\n          {\n            valid: false,\n            error: error instanceof Error ? error.message : 'Unknown error',\n          },\n          null,\n          2\n        )\n      );\n      return;\n    }\n\n    console.log(`\\n‚úó Configuration is invalid\\n`);\n    logger.error('Validation failed:', error);\n    throw error;\n  } finally {\n    // Always cleanup: disconnect from all MCP servers\n    await engine.dispose();\n  }\n}\n\n/**\n * Reload MCP discovery configuration\n */\nexport async function mcpConfigReloadCommand(\n  context: CLIContext,\n  options: ConfigOptions\n): Promise<void> {\n  const { config, logger } = context;\n\n  const discoveryConfig = config.discovery || {\n    enabled: true,\n    cache: { enabled: true, ttl: 3600 },\n  };\n\n  const engine = new DiscoveryEngine(discoveryConfig, config.mcp?.servers);\n\n  try {\n    await engine.reload();\n\n    if (options.json) {\n      console.log(JSON.stringify({ reloaded: true }, null, 2));\n      return;\n    }\n\n    console.log(`\\n‚úì Configuration reloaded successfully\\n`);\n  } catch (error) {\n    logger.error('Failed to reload config:', error);\n    throw error;\n  } finally {\n    // Always cleanup: disconnect from all MCP servers\n    await engine.dispose();\n  }\n}\n","import { Command } from 'commander';\nimport { conversationStartCommand } from './commands/conversation/start.js';\nimport { conversationEndCommand } from './commands/conversation/end.js';\nimport { conversationListCommand } from './commands/conversation/list.js';\nimport { conversationMessageCommand } from './commands/conversation/message.js';\nimport { conversationContextCommand } from './commands/conversation/context.js';\nimport { conversationCondenseCommand } from './commands/conversation/condense.js';\nimport { conversationForkCommand } from './commands/conversation/fork.js';\nimport { conversationSummarizeCommand } from './commands/conversation/summarize.js';\nimport { conversationShowCommand } from './commands/conversation/show.js';\nimport { conversationContinueCommand } from './commands/conversation/continue.js';\nimport { conversationDeleteCommand } from './commands/conversation/delete.js';\nimport { chatCommand } from './commands/chat.js';\nimport { chatInteractiveCommand } from './commands/chat-interactive.js';\nimport { configCommand } from './commands/config.js';\nimport { listModelsCommand } from './commands/list-models.js';\nimport { listTagsCommand } from './commands/list-tags.js';\nimport { benchmarkCommand } from './commands/benchmark.js';\nimport {\n  mcpSearchCommand,\n  mcpInspectCommand,\n  mcpExecuteCommand,\n  mcpConfigShowCommand,\n  mcpConfigValidateCommand,\n  mcpConfigReloadCommand,\n} from './commands/mcp.js';\nimport { withCLIContext } from './utils/cli-context.js';\n\nconst program = new Command();\n\nprogram\n  .name('anygpt')\n  .description('AnyGPT - Universal AI Gateway CLI')\n  .version('0.0.1')\n  .option('-c, --config <path>', 'path to config file')\n  .option(\n    '-v, --verbose [level]',\n    'verbose output: no value = info (metrics), \"debug\" = debug logs'\n  );\n\n// Stateless chat command\nprogram\n  .command('chat')\n  .description('Send chat message (stateless)')\n  .option('--provider <name>', 'provider name from config')\n  .option('--type <type>', 'provider type (openai, anthropic, google)')\n  .option('--url <url>', 'API endpoint URL')\n  .option('--token <token>', 'API token')\n  .option(\n    '--model <model>',\n    'direct model name (no tag resolution, passed as-is to provider)'\n  )\n  .option(\n    '--tag <tag>',\n    'tag name for model resolution (e.g., \"sonnet\", \"openai:gemini\", \"cody:opus\")'\n  )\n  .option('--max-tokens <number>', 'maximum tokens to generate', parseInt)\n  .option('--usage', 'show token usage statistics')\n  .option('--stdin', 'read message from stdin instead of argument')\n  .argument('[message]', 'message to send (optional if --stdin is used)')\n  .action(withCLIContext(chatCommand));\n\n// Interactive chat command (with AI)\nprogram\n  .command('chat-interactive')\n  .alias('repl')\n  .description('Start interactive chat session with AI')\n  .option('--echo', 'use simple echo mode (no AI)')\n  .option('--model <model>', 'model to use (e.g., gpt-4o-mini, claude-3-5-sonnet)')\n  .option('--provider <provider>', 'provider to use (e.g., openai, anthropic)')\n  .action(withCLIContext(chatInteractiveCommand));\n\n// Config inspection command\nprogram\n  .command('config')\n  .description('Show resolved configuration')\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(configCommand));\n\n// List models command\nprogram\n  .command('list-models')\n  .description('List available models from a provider')\n  .option(\n    '--provider <name>',\n    'provider name from config (uses default from config if not specified)'\n  )\n  .option('--tags', 'show resolved tags for each model')\n  .option(\n    '--filter-tags <tags>',\n    'filter models by tags (comma-separated, use ! prefix to exclude). Examples: \"reasoning\", \"!reasoning\", \"claude,sonnet\"'\n  )\n  .option(\n    '--enabled [value]',\n    'filter by enabled status (true/false, default: true if flag present)',\n    (val) => {\n      if (val === 'false' || val === '0') return false;\n      if (val === 'true' || val === '1') return true;\n      return true; // Default to true if just --enabled is passed\n    }\n  )\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(listModelsCommand));\n\n// List tags command\nprogram\n  .command('list-tags')\n  .description('List all available tags and their model mappings')\n  .option('--provider <name>', 'filter by provider name')\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(listTagsCommand));\n\n// Benchmark command\nprogram\n  .command('benchmark')\n  .description('Benchmark models across providers')\n  .option('--provider <name>', 'benchmark all models from this provider')\n  .option(\n    '--model <model>',\n    'specific model to benchmark (requires --provider)'\n  )\n  .option(\n    '--models <list>',\n    'comma-separated list of provider:model pairs (e.g., \"openai:gpt-4o,anthropic:claude-3-5-sonnet\")'\n  )\n  .option(\n    '--prompt <text>',\n    'prompt to use for benchmarking (default: \"What is 2+2? Answer in one sentence.\")'\n  )\n  .option('--stdin', 'read prompt from stdin')\n  .option(\n    '--max-tokens <number>',\n    'maximum tokens to generate (optional, some models may not support this)',\n    (val) => parseInt(val, 10)\n  )\n  .option(\n    '--iterations <number>',\n    'number of iterations per model',\n    (val) => parseInt(val, 10),\n    1\n  )\n  .option('--all', 'benchmark all models from all providers')\n  .option(\n    '--filter-tags <tags>',\n    'filter models by tags (comma-separated, use ! prefix to exclude)'\n  )\n  .option('--parallel', 'run models in parallel instead of sequentially')\n  .option(\n    '--concurrency <number>',\n    'max parallel requests when using --parallel (default: 3)',\n    (val) => parseInt(val, 10),\n    3\n  )\n  .option('--output <directory>', 'directory to save response files')\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(benchmarkCommand));\n\n// Conversation commands\nconst conversation = program\n  .command('conversation')\n  .description('Manage stateful conversations');\n\nconversation\n  .command('start')\n  .description('Start a new conversation')\n  .option(\n    '--provider <name>',\n    'provider name from config (uses default from config if not specified)'\n  )\n  .option(\n    '--model <model>',\n    'model name (uses default from config if not specified)'\n  )\n  .option('--name <name>', 'conversation name')\n  .action(async (options: any, command: any) => {\n    const globalOpts = command.parent.parent.opts();\n\n    try {\n      await conversationStartCommand(options, globalOpts.config);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('end')\n  .description('End the current conversation')\n  .action(async () => {\n    try {\n      await conversationEndCommand();\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('list')\n  .description('List all conversations')\n  .action(async () => {\n    try {\n      await conversationListCommand();\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('continue <id>')\n  .description('Continue a specific conversation')\n  .action(async (id: string) => {\n    try {\n      await conversationContinueCommand(id);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('delete <id>')\n  .description('Delete a conversation')\n  .action(async (id: string) => {\n    try {\n      await conversationDeleteCommand(id);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('message <message>')\n  .description('Send a message in the current conversation')\n  .option('--conversation <id>', 'conversation ID to send message to')\n  .action(async (message: string, options: any, command: any) => {\n    const globalOpts = command.parent.parent.opts();\n\n    try {\n      await conversationMessageCommand(message, options, globalOpts.config);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('context')\n  .description('Show detailed context statistics for the current conversation')\n  .option('--conversation <id>', 'conversation ID to analyze')\n  .action(async (options: any) => {\n    try {\n      await conversationContextCommand(options);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('condense')\n  .description('Condense conversation context using AI summarization')\n  .option('--conversation <id>', 'conversation ID to condense')\n  .option('--keep-recent <number>', 'number of recent messages to keep', '3')\n  .option('--dry-run', 'show what would be condensed without applying changes')\n  .action(async (options: any) => {\n    try {\n      const condenseOptions = {\n        ...options,\n        keepRecent: parseInt(options.keepRecent) || 3,\n      };\n      await conversationCondenseCommand(condenseOptions);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('fork')\n  .description('Fork conversation - create new conversation with same history')\n  .option('--conversation <id>', 'conversation ID to fork')\n  .option('--model <model>', 'model for the new conversation')\n  .option('--provider <provider>', 'provider for the new conversation')\n  .option('--name <name>', 'name for the new conversation')\n  .action(async (options: any) => {\n    try {\n      await conversationForkCommand(options);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('summarize')\n  .description('Create new conversation with AI-generated summary')\n  .option('--conversation <id>', 'conversation ID to summarize')\n  .option('--keep-recent <number>', 'number of recent messages to keep', '3')\n  .option('--model <model>', 'model for the new conversation')\n  .option('--provider <provider>', 'provider for the new conversation')\n  .option('--name <name>', 'name for the new conversation')\n  .option(\n    '--dry-run',\n    'show what would be summarized without creating new conversation'\n  )\n  .action(async (options: any) => {\n    try {\n      const summarizeOptions = {\n        ...options,\n        keepRecent: parseInt(options.keepRecent) || 3,\n      };\n      await conversationSummarizeCommand(summarizeOptions);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\nconversation\n  .command('show')\n  .description('Show full conversation history')\n  .option('--conversation <id>', 'conversation ID to show')\n  .option(\n    '--limit <number>',\n    'limit number of messages to show (shows last N messages)'\n  )\n  .option('--format <format>', 'output format: full, compact, or json', 'full')\n  .action(async (options: any) => {\n    try {\n      const showOptions = {\n        ...options,\n        limit: options.limit ? parseInt(options.limit) : undefined,\n      };\n      await conversationShowCommand(showOptions);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// MCP Discovery commands\nconst mcp = program.command('mcp').description('Manage MCP servers and tools');\n\nmcp\n  .command('inspect [target]')\n  .description(\n    'Inspect servers and tools (no target = list all servers, <server> = inspect server, <tool> = inspect tool)'\n  )\n  .option('--server <name>', 'specify server to inspect or disambiguate tool')\n  .option('--tools', 'show tools when listing servers or inspecting server')\n  .option('--compact', 'show tools in compact format (use with --tools)')\n  .option('--args', 'show detailed parameter schemas for tools')\n  .option('--examples', 'show usage examples for tools')\n  .option('--enabled', 'show only enabled servers (when listing)')\n  .option('--disabled', 'show only disabled servers (when listing)')\n  .option('--all', 'show all servers including disabled (when listing)')\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(mcpInspectCommand));\n\nmcp\n  .command('search <query>')\n  .description('Search for tools across all MCP servers')\n  .option('--server <name>', 'filter by server name')\n  .option('--limit <number>', 'maximum number of results', parseInt, 10)\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(mcpSearchCommand));\n\nmcp\n  .command('execute <tool> [args...]')\n  .description('Execute a tool (auto-resolves server if tool name is unique)')\n  .option('--server <name>', 'specify server name (optional if tool is unique)')\n  .option(\n    '--args <json>',\n    'tool arguments as JSON string (overrides positional args)'\n  )\n  .option('--json', 'output as JSON')\n  .option('--stream', 'stream output (if supported)')\n  .action(withCLIContext(mcpExecuteCommand));\n\n// MCP config subcommands\nconst mcpConfig = mcp\n  .command('config')\n  .description('Manage MCP discovery configuration');\n\nmcpConfig\n  .command('show')\n  .description('Show current configuration')\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(mcpConfigShowCommand));\n\nmcpConfig\n  .command('validate')\n  .description('Validate configuration')\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(mcpConfigValidateCommand));\n\nmcpConfig\n  .command('reload')\n  .description('Reload configuration')\n  .option('--json', 'output as JSON')\n  .action(withCLIContext(mcpConfigReloadCommand));\n\nprogram.parse();\n"],"mappings":"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"}